---
title: Migrate to using Qiskit Runtime primitives
description: Migrate from using backend.run to using Qiskit Runtime primitives


in_page_toc_max_heading_level: 2
---

<span id="migrate-to-qr"></span>
# Migrate to using Qiskit Runtime primitives

This guide describes key patterns of behavior and use cases with code
examples to help you migrate code from the legacy `backend.run()` interface (`qiskit-ibmq-provider` package) to use the Qiskit Runtime primitives interface (`qiskit-ibm-runtime` package). 

<Admonition>
Because both `backend.run()` and the "version 1" primitives are being deprecated, this guide uses only the V2 primitives. 
</Admonition>

## Overview

The `qiskit-ibm-runtime` package provides cloud access to the IBM Quantum&trade; systems through the primitives interface, which supersedes (and fully replaces) the former hardware interface, `backend.run()`. The `backend.run()` interface coexisted with the original (V1) primitives model as the dedicated “direct hardware access” entry point.  With the introduction of the V2 primitives interface, the new `SamplerV2` class now fulfills that role. Consequentially, `qiskit-ibmq-provider`, the package that exposed the `backend.run()` interface, has been deprecated. 

The Qiskit Runtime primitives implement the reference Sampler V2 and Estimator V2 interfaces found in `qiskit.primitives`, and enable capabilities not available with the legacy `backend.run()` interface. These capabilities include application of advanced processing techniques for error suppression and mitigation in Estimator, the ability to efficiently sweep between arrays of parameter value sets or observables in both Sampler and Estimator, and access to the new local testing mode. Additionally, Qiskit Runtime lets users run iterative algorithm circuits back to back (session mode) or in collections of circuits without having to re-queue each job (batch mode). This results in more efficient quantum processor use and reduces the time spent running complex computations. 

<Admonition type="note">
Different packages expose different "flavors" of the primitive interfaces, for example: 

-   The primitives in `qiskit` can perform local state vector
    simulations - useful for quickly prototyping algorithms.
-   The primitives in `qiskit_aer` give access to the local Aer
    simulators for tasks such as noisy simulation.
-   The primitives in `qiskit_ibm_runtime` provide access to cloud
    simulators and real hardware through the Qiskit Runtime service.
    They include exclusive features such as built-in circuit
    optimization and error mitigation support.
    
The **only primitives that provide access to the Qiskit Runtime service** are those imported from `qiskit_ibm_runtime` (Qiskit Runtime Primitives).
</Admonition>

When migrating, the key to writing an equivalent algorithm using
primitives is to first identify what is the minimal unit of information
your algorithm is based on:

-   If it uses an **expectation value**, you will need an `Estimator`.
-   If it uses a **probability distribution** (from sampling the device), you will need a `Sampler`.

After determining which primitive to use, identify where the algorithm
accesses the system. Look for the call to `backend.run()`. Next, you
will replace this call with the respective primitive call, as shown in
the following examples.

This guide is for algorithm developers who need to refactor algorithms to use primitives instead of `backend.run()`. See examples here:

    -   [Update code that performs circuit sampling](qiskit-runtime-examples#sampler-algorithm)
    -   [Update code that calculates expectation values](qiskit-runtime-examples#estimator-algorithm)

The following topics are use cases with code migration examples:

-   [Update parameter values while running](#parm-circ)
-   [Algorithm tuning options (shots, transpilation, error mitigation)](../../run/advanced-runtime-options)

## FAQs

Users might have the following questions when planning to migrate their
code to Qiskit Runtime:

<details>
<summary>How do the Qiskit Runtime primitives differ from backend.run?</summary>

Qiskit Runtime is designed to streamline algorithm and application construction by removing the need for users to understand technical hardware and low-level software details. Advanced processing techniques for error suppression and mitigation are automatically applied, giving users high-fidelity results without the burden of having to code these routines themselves. The inclusion of different execution modes within Qiskit Runtime allows users to run iterative algorithm circuits back to back (sessions), or batch collections of circuits without having to re-queue each job (batch mode). This results in more efficient quantum processor utilization and reduces the total amount of time users spend running complex computations. 

</details>

<details>
<summary>Which channel should I use?</summary>

After deciding to use Qiskit Runtime primitives, the user must determine
whether to access Qiskit Runtime through IBM Cloud or IBM Quantum
Platform. Some information that might help you decide includes:

- The available plans:
   - Qiskit Runtime is available in both the Open (free access) or Premium (contract-based paid access) plan on IBM Quantum Platform. See [IBM Quantum access plans](https://www.ibm.com/quantum/access-plans) for details.
   - Qiskit Runtime is accessible through the Lite (free access) or Standard (pay-as-you-go access) plan in IBM Cloud. See [Qiskit Runtime plans](https://cloud.ibm.com/docs/quantum-computing?topic=quantum-computing-plans) on IBM Cloud for details.

</details>

<details>
<summary>How do I set up my channel?</summary>

After deciding which channel to use to interact with Qiskit Runtime, you
can get set up on either platform by following the steps in [Install and set up.](../../start/install)

</details>

<details>
<summary>Which primitive should I use?</summary>

When choosing which primitive to use, you first need to understand
whether the algorithm uses a **quasi-probability distribution** sampled
from a quantum state (a list of quasi-probabilities), or an
**expectation value** of a certain observable with respect to a
quantum state (a real number).

A probability distribution is often of interest in optimization problems
that return a classical bit string, encoding a certain solution to a
problem at hand. In these cases, you might be interested in finding a
bit string that corresponds to a ket value with the largest probability
of being measured from a quantum state, for example.

An expectation value of an observable could be the target quantity in
scenarios where knowing a quantum state is not relevant. This often
occurs in optimization problems or chemistry applications. For example,
when trying to discover the extremal energy of a system.

</details>

## Next steps

<Admonition type="tip" title="Recommendations">
    - Start by [migrating your setup.](qiskit-runtime-setup)
    - Review some [migration examples.](qiskit-runtime-examples)
    - [Get started with Estimator.](../../run/primitives-get-started#start-estimator)
    - [Get started with Sampler.](../../run/primitives-get-started#start-sampler)
    - Explore [sessions.](../../run/sessions)
    - [Run a primitive in a session.](../../run/run-jobs-in-session)
    - Experiment with the [Submit pre-transpiled circuits tutorial.](https://learning.quantum.ibm.com/tutorial/submitting-user-transpiled-circuits-using-primitives)

</Admonition>