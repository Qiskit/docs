---
title: Migrate to local simulators
description: Migrate from using the IBM Quantum cloud simulators (such as ibmq_qasm_simulator) to using local simulators

---

<span id="local-simulators"></span>
# Migrate to local simulators

In quantum computing, the choice between using simulators and quantum hardware is crucial for making progress in the field. While simulators are useful for testing and debugging, in this era of quantum utility, quantum development and industry advancement requires actual hardware. As part of the move to quantum utility, IBM Quantum&trade; will retire its cloud simulators on 15 May 2024. This guide explains in more detail why this is happening, and how to change from cloud to local simulators. 

## Why are the cloud simulators being retired?

The cloud simulators are being retired for several reasons:

### Simulators have limitations

Simulators can be useful, but they are too limited to use for research or experimentation:

- Simulators are valuable for understanding small-scale quantum systems, but their usefulness maxes out at around 50 qubits, even with access to high-performance supercomputers. This ceiling comes from the exponential growth in computational resources required to simulate larger quantum systems (review [Massively parallel quantum computer simulator, eleven years later](https://arxiv.org/abs/1805.04708) for the full explanation).  Exploring quantum systems of 100 qubits and more requires hardware.

- While some simulators offer noise models, it is a very hard problem to capture the entire dynamics of a real QPU. Quantum hardware offers the potential for researchers to confront the challenges inherent in quantum systems, such as noise, errors, and decoherence in a realistic testing environment.

### Using quantum hardware builds unique skills

Interacting with quantum hardware grows skills and experience unattainable by only using simulators: 

- Direct interaction with quantum hardware builds skills because you must implement or use error mitigation techniques, such as error correction and suppression, for reliable computation.

- Hands-on experience with quantum hardware develops a deeper understanding of quantum phenomena and how to tailor algorithms to the characteristics of quantum processors.

- Engaging with quantum hardware results in practical insights into the challenges and opportunities of quantum computing, enhancing developers' ability to drive innovation in the field.

## Algorithms should be adapted for quantum hardware

Successful quantum algorithms must be adapted to exploit the capabilities of quantum hardware, optimizing performance and efficiency.

- Quantum hardware provides a more accurate representation of real-world quantum systems than simulators.

- Fine-tuning algorithms for quantum hardware involves adjusting ansatz, circuit implementations, parameters, and configuration to maximize performance.  This process is best achieved through direct experimentation with quantum hardware.
 

## When should simulators be used?

Quantum simulators should be used to help develop and test programs before fine-tuning them and sending them to quantum hardware. Local simulators can do this with good performance and efficiency. 

## Migrate to local simulators

Depending on your needs, there are several replacements for cloud simulators. 

### Qiskit Runtime
 
If you currently use cloud simulators in Qiskit Runtime, for example, by specifying `ibmq_qasm_simulator` as the backend, you can use "local testing mode" instead. 

To use local testing mode, specify one of the fake backends in ``qiskit_ibm_runtime.fake_provider`` or specify a Qiskit Aer backend when instantiating a primitive or a session.  For details, see the [fake_provider API reference.](/api/qiskit-ibm-runtime/qiskit_ibm_runtime.fake_provider)

Example:

```python
from qiskit_aer import AerSimulator
from qiskit.circuit.library import RealAmplitudes
from qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import Session, SamplerV2 as Sampler
from qiskit_ibm_runtime.fake_provider import FakeManilaV2

# Bell Circuit
qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all()

# Run the sampler job locally using FakeManilaV2
fake_manila = FakeManilaV2()
pm = generate_preset_pass_manager(backend=fake_manila, optimization_level=1)
isa_qc = pm.run(qc)
sampler = Sampler(backend=fake_manila)
result = sampler.run([(isa_qc)]).result()

# Run the sampler job locally using AerSimulator.
# Session syntax is supported but ignored because simulators don't support sessions.
aer_sim = AerSimulator()
pm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)
isa_qc = pm.run(qc)
service = QiskitRuntimeService()
with Session(service=service, backend=aer_sim) as session:
    sampler = Sampler(session=session)
    result = sampler.run([(isa_qc)]).result()
```        

### Qiskit Aer

If you currently use Qiskit (and not Qiskit Runtime), you can use the existing Qiskit Aer primitives.  See [exact and noisy simulation with Qiskit Aer primitives](../../verify/simulate-with-qiskit-aer) for details. 

<Admonition>
Qiskit Aer primitives do not support the V2 interface.  To use V2 primitives with Aer simulators, use local testing mode in Qiskit Runtime to specify `AerSimulator()`.
</Admonition>