---
title: Qiskit 1.0 feature migration guide
description: Adapt to feature changes with Qiskit 1.0
---

# Qiskit 1.0 feature changes

Qiskit&reg;  1.0 ...

This guide is organized by Qiskit module. Use the navigation bar on the
right-hand side to navigate to the module you are interested in.

<span id="qiskit.global"></span>
## Global instances and functions

<span id="Aer"></span>
### Aer

The `qiskit.Aer` object is no longer available in Qiskit 1.0. Instead, use the
same object from the `qiskit_aer` namespace, which is a drop-in replacement.
To install `qiskit_aer`, run:

```bash
pip install qiskit-aer
```

<span id="BasicAer"></span>
### BasicAer

The `qiskit.BasicAer` object is no longer available in Qiskit 1.0. See the
[`basicaer` migration section](#basicaer) for
more information on migration options.

<span id="execute"></span>
### execute

The `qiskit.execute` function is no longer available in Qiskit 1.0. This
function served as a high-level wrapper around the `transpile` and `run`
functionalities in Qiskit. Instead of `qiskit.execute`, use the
[`transpile`](/api/qiskit/compiler#transpile) function followed by
[`backend.run()`](/api/qiskit/qiskit.providers.BackendV2#run).

```python
# Legacy path
from qiskit import execute
job = execute(circuit, backend)

# New path
from qiskit import transpile
new_circuit = transpile(circuit, backend)
job = backend.run(new_circuit)
```

Alternatively, the [`Sampler`](/api/qiskit/qiskit.primitives.Sampler)
primitive is semantically equivalent to the deprecated `qiskit.execute`
function. The class
[`BackendSampler`](/api/qiskit/qiskit.primitives.BackendSampler) is a
generic wrapper for backends that do not support primitives:

```python
from qiskit.primitives import BackendSampler
sampler = BackendSampler(backend)
job = sampler.run(circuit)
```

<span id="qiskit.circuit"></span>
## qiskit.circuit

<span id="QuantumCircuit.qasm"></span>
### QuantumCircuit.qasm

The `QuantumCircuit.qasm` method has been removed. Instead, use
[`qasm2.dump`](/api/qiskit/qasm2#dump) or
[`qasm2.dumps`](/api/qiskit/qasm2#dumps).

For pygments-formatted output, look at the standalone
[`openqasm-pygments`](https://pypi.org/project/openqasm-pygments/) package,
as `qasm2.dump` and `qasm2.dumps` do not provide pygments colored output.

```python
from qiskit import QuantumCircuit
qc = QuantumCircuit(1)

# Deprecated
qasm_str = qc.qasm()

# Alternative
from qiskit.qasm2 import dumps
qasm_str = dumps(qc)

# Alternative: Write to file
from qiskit.qasm2 import dump
with open("my_file.qasm", "w") as f:
    dump(qc, f)
```

<span id="QuantumCircuit-gates"></span>
### QuantumCircuit gates

The following gate methods have been removed in favor of more established
methods that append the same gates:

| Deprecated                   | Alternative |
|------------------------------|----------------------|
| `QuantumCircuit.cnot`        | [`QuantumCircuit.cx`](/api/qiskit/qiskit.circuit.QuantumCircuit#cx)       |
| `QuantumCircuit.toffoli`     | [`QuantumCircuit.ccx`](/api/qiskit/qiskit.circuit.QuantumCircuit#ccx)     |
| `QuantumCircuit.fredkin`     | [`QuantumCircuit.cswap`](/api/qiskit/qiskit.circuit.QuantumCircuit#cswap) |
| `QuantumCircuit.mct`         | [`QuantumCircuit.mcx`](/api/qiskit/qiskit.circuit.QuantumCircuit#mcx)     |
| `QuantumCircuit.i`           | [`QuantumCircuit.id`](/api/qiskit/qiskit.circuit.QuantumCircuit#id)       |

The following circuit methods have been removed. Instead, these gates can be
applied to a circuit with `QuantumCircuit.append`.

| Deprecated                   | Alternative (append) |
|------------------------------|----------------------|
| `QuantumCircuit.diagonal`    | [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate)          |
| `QuantumCircuit.hamiltonian` | [`HamiltonianGate`](/api/qiskit/qiskit.circuit.library.HamiltonianGate)    |
| `QuantumCircuit.isometry`    | [`Isometry`](/api/qiskit/qiskit.circuit.library.Isometry)           |
| `QuantumCircuit.iso`         | [`Isometry`](/api/qiskit/qiskit.circuit.library.Isometry)           |
| `QuantumCircuit.uc`          | [`UCGate`](/api/qiskit/qiskit.circuit.library.UCGate)               |
| `QuantumCircuit.ucrx`        | [`UCRXGate`](/api/qiskit/qiskit.circuit.library.UCRXGate)           |
| `QuantumCircuit.ucry`        | [`UCRYGate`](/api/qiskit/qiskit.circuit.library.UCRYGate)           |
| `QuantumCircuit.ucrz`        | [`UCRZGate`](/api/qiskit/qiskit.circuit.library.UCRZGate)           |

For example, for a [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate):

```python
from qiskit.circuit import QuantumCircuit
from qiskit.circuit.library import DiagonalGate  # new location in the circuit library

circuit = QuantumCircuit(2)
circuit.h([0, 1])  # some initial state

gate = DiagonalGate([1, -1, -1, 1])
qubits = [0, 1]  # qubit indices on which to apply the gate
circuit.append(gate, qubits)  # apply the gate
```

<span id="qiskit.converters"></span>
## qiskit.converters

The `qiskit.converters.ast_to_dag` function is deprecated. It converted the
abstract syntax tree generated by the legacy OpenQASM 2 parser to a
`DAGCircuit`. As the legacy OpenQASM 2 parser has been removed (see
[qiskit.qasm](#qiskit.qasm)), this function no longer serves a purpose.
Instead, parse your OpenQASM 2 files into a `QuantumCircuit` using the
[`QuantumCircuit.from_qasm_file`](/api/qiskit/qiskit.circuit.QuantumCircuit#from_qasm_file)
or
[`QuantumCircuit.from_qasm_str`](/api/qiskit/qiskit.circuit.QuantumCircuit#from_qasm_str)
constructor methods (or the [`qiskit.qasm2`](/api/qiskit/qasm2) module),
then convert that `QuantumCircuit` into a
[`DAGCircuit`](/api/qiskit/qiskit.dagcircuit.DAGCircuit) with
[`circuit_to_dag`](/api/qiskit/converters#circuit_to_dag).

```python
# Deprecated
from qiskit.converters import ast_to_dag
from qiskit.qasm import Qasm

dag = ast_to_dag(Qasm(filename="myfile.qasm").parse())

# Alternative
import qiskit.qasm2
from qiskit.converters import circuit_to_dag

dag = circuit_to_dag(qiskit.qasm2.load("myfile.qasm"))
```

<span id="qiskit.extensions"></span>
## qiskit.extensions

The `qiskit.extensions` module is no longer available, most of its objects have been
integrated into the circuit library
([`qiskit.circuit.library`](/api/qiskit/circuit_library)). To migrate to the
new location, simply replace `qiskit.extensions` with `qiskit.circuit.library`
in the object import path. This is a drop-in replacement.

```python
# Deprecated
from qiskit.extensions import DiagonalGate

# Alternative
from qiskit.circuit.library import DiagonalGate
```

The classes moved to [`qiskit.circuit.library`](/api/qiskit/circuit_library) are:

* [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate)
* [`HamiltonianGate`](/api/qiskit/qiskit.circuit.library.HamiltonianGate)
* [`Initialize`](/api/qiskit/qiskit.circuit.library.Initialize)
* [`Isometry`](/api/qiskit/qiskit.circuit.library.Isometry)
* `qiskit.circuit.library.generalized_gates.mcg_up_diag.MCGupDiag`
* [`UCGate`](/api/qiskit/qiskit.circuit.library.UCGate)
* [`UCPauliRotGate`](/api/qiskit/qiskit.circuit.library.UCPauliRotGate)
* [`UCRXGate`](/api/qiskit/qiskit.circuit.library.UCRXGate)
* [`UCRYGate`](/api/qiskit/qiskit.circuit.library.UCRYGate)
* [`UCRZGate`](/api/qiskit/qiskit.circuit.library.UCRZGate)
* [`UnitaryGate`](/api/qiskit/qiskit.circuit.library.UnitaryGate)

The following classes have been removed from the codebase, as their
functionality was either redundant or linked to the `extensions` module:

Deprecated                       |   Alternative
---------------------------------|--------------------------------------------
[`SingleQubitUnitary`](/api/qiskit/0.46/qiskit.extensions.SingleQubitUnitary)    |  [`qiskit.circuit.library.UnitaryGate`](/api/qiskit/qiskit.circuit.library.UnitaryGate)
[`Snapshot`](/api/qiskit/0.46/qiskit.extensions.Snapshot)             |  use qiskit-aer's save instructions
[`ExtensionError`](/api/qiskit/0.46/qiskit.extensions.ExtensionError) | a relevant error class

<span id="qiskit.primitives"></span>
## qiskit.primitives

The most notable change in the [`qiskit.primitives`](/api/qiskit/primitives) module is the
introduction of the new **primitives V2 interface**. This section will show how to migrate your
workflow from primitives V1 to primitives V2, as well as the few changes that have taken place
in the inputs accepted by the V1 interface.

<Admonition type="note">
From the 1.0 release onwards, we will refer to the pre-1.0 primitives interface as "primitives V1".
</Admonition>

Jump to subsection:

* [Migrate from V1 to V2](#migrate-to-v2)
* [Updates in V1 interface](#v1-changes)

<span id="migrate-to-v2"></span>
### Migrate from V1 to V2

The formal distinction between the primitives V1 and V2 APIs are the base classes from which
primitives implementations inherit. To transition to the new base classes you can maintain
the original import path from `qiskit.primitives`:

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`BaseEstimator`](/api/qiskit/qiskit.primitives.BaseEstimator)         |  [`BaseEstimatorV2`](/api/qiskit/qiskit.primitives.BaseEstimatorV2)
[`BaseSampler`](/api/qiskit/qiskit.primitives.BaseSampler)             |  [`BaseSamplerV2`](/api/qiskit/qiskit.primitives.BaseSamplerV2)

As for the qiskit core implementations of the V2 primitives (those importable from `qiskit.primitives`),
the names have been modified to clarify their purpose as implementations that can be run locally
with a statevector simulator backend. The new names **do not include the -V2 suffix**.

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`qiskit.primitives.Estimator`](/api/qiskit/qiskit.primitives.Estimator)         |  [`qiskit.primitives.StatevectorEstimator`](/api/qiskit/qiskit.primitives.StatevectorEstimator)
[`qiskit.primitives.Sampler`](/api/qiskit/qiskit.primitives.Sampler)             |  [`qiskit.primitives.StatevectorSampler`](/api/qiskit/qiskit.primitives.StatevectorSampler)


At a conceptual level, there are some notable differences to keep in mind when migrating from V1 to V2.
These differences are dictated by the base class, but are shown in the examples below using the statevector
implementations found in `qiskit.primitives`:

<Admonition type="note">
For the examples below, assume the following imports and primitive intializations:

```python
from qiskit.primitives import Sampler, StatevectorSampler, Estimator, StatevectorEstimator

estimator_v1 = Estimator()
sampler_v1 = Sampler()
estimator_v2 = StatevectorEstimator()
sampler_v2 = StatevectorSampler()

# define circuits, observables and param. values
```
</Admonition>

1. `Sampler and Estimator`: The new V2 primitives are designed to accept **vectorized inputs**,
  where single circuits can be grouped with array-valued specifications.
  That is, one circuit can be executed
  for arrays of `n` parameter sets and/or `n` observables (in the case of the estimator). Each group
  is called a **primitive unified bloc (pub)**, and can be represented
  as a tuple: `(1 x circuit, [n x observables], [n x parameters])`. The V1 interface didn't allow for
  the same flexibility, as there number of input circuits had to match the number of observables and
  parameter sets, as shown in the following examples:

<Tabs>
  <TabItem value="e-1-4" label="Estimator, 1 circuit, 4 obs." default>
      ```python
      # executing 1 circuit with 4 observables using Estimator V1
      job = estimator_v1.run([circuit] * 4, [obs1, obs2, obs3, obs4])
      evs = job.result().values

      # executing 1 circuit with 4 observables using Estimator V2
      job = estimator_v2.run((circuit, [obs1, obs2, obs3, obs4]))
      evs = job.result()[0].data.evs
      ```
  </TabItem>
  <TabItem value="s-1-3" label="Sampler, 1 circuit, 3 param. sets" default>
      ```python
      # executing 1 circuit with 3 parameter sets using Sampler V1
      job = sampler_v1.run([circuit] * 3, [vals1, vals2, vals3])
      evs = job.result().quasi_dists

      # executing 1 circuit with 3 parameter sets using Sampler V2
      job = sampler_v2.run((circuit, [vals1, vals2, vals3]))
      evs = job.result()[0].data
      ```
  </TabItem>
  <TabItem value="e-1-4-2" label="Estimator, 1 circuit, 4 obs., 3 param. sets" default>
      ```python
      # executing 1 circuit with 4 observables and 2 parameter sets using Estimator V1
      job = estimator_v1.run([circuit] * 8, [obs1, obs2, obs3, obs4] * 2, [vals1, vals2] * 4)
      evs = job.result().values

      # executing 1 circuit with 4 observables and 2 parameter sets using Estimator V2
      job = estimator_v2.run((circuit, [obs1, obs2, obs3, obs4], [vals1, vals2]))
      evs = job.result()[0].data.evs
      ```
  </TabItem>
</Tabs>

  V2 primitives accept multiple pubs as inputs, and each pub gets its own result. This
  allows for executing different circuits with different parameter/observable combinations,
  something not always possible in the V1 interface:

<Tabs>
  <TabItem value="s-2-1" label="Sampler, 2 circuits, 1 param. set" default>
      ```python
      # executing 2 circuits with 1 observable using Sampler V1
      job = sampler_v1.run([circuit1, circuit2], [obs1] * 2)
      evs = job.result().quasi_probs

      # executing 2 circuits with 1 observable using Sampler V2
      job = sampler_v2.run((circuit1, obs1), (circuit2, obs1))
      evs1 = job.result()[0].data # result for pub 1 (circuit 1)
      evs2 = job.result()[1].data # result for pub 2 (circuit 2)
      ```
  </TabItem>
  <TabItem value="e-2-2" label="Estimator, 2 circuits, 2 different obs." default>
      ```python
      # executing 2 circuits with different observables
      # is not possible using Estimator V1

      # executing 2 circuits with 2 different observables using Estimator V2
      job = estimator_v2.run((circuit1, obs1), (circuit2, obs2))
      evs1 = job.result()[0].data.evs # result for pub 1 (circuit 1)
      evs2 = job.result()[1].data.evs # result for pub 2 (circuit 2)
      ```
  </TabItem>
</Tabs>

2. `Sampler`: The V2 sampler now returns measurement outcome samples in the form of
  **bitstrings** or **counts**, instead of the quasi-probability distributions from the
  V1 interface.
  The bitstrings show the measurement outcomes preserving the shot order in which they
  were measured. The V2 sampler result objects organize data in terms of their
  input circuits' classical register names, for compatibility with dynamic circuits.

    ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```
    ```text
            ┌───┐      ░ ┌─┐
       q_0: ┤ H ├──■───░─┤M├───
            └───┘┌─┴─┐ ░ └╥┘┌─┐
       q_1: ─────┤ X ├─░──╫─┤M├
                 └───┘ ░  ║ └╥┘
    meas: 2/══════════════╩══╩═
                          0  1
    ```
    <Admonition type="warning">
    You can notice in the circuit above that the name of the classical register defaults to `"meas"`.
    This name will be used later to access the measurement bitstrings.
    </Admonition>

    ```python
    # Run using V1 sampler
    result = sampler_v1.run(circuit).result()
    quasi_dist = result.quasi_dists[0]
    print(f'The quasi-probability distribution is: {quasi_dist}')
    ```
    ```text
    The quasi-probability distribution is: {0: 0.5, 3: 0.5}
    ```
    ```python
    # Run using V2 sampler
    result = sampler_v2.run([circuit]).result()
    # Access result data for pub 0
    data_pub = result[0].data
    # Access bitstring for the classical register "meas"
    bitstring = data_pub.meas.get_bitstring()
    print(f'The bitstring shape is: {bitstring.shape}')
    # Get counts for the classical register "meas"
    counts = data_pub.meas.get_counts()
    print(f'The counts are: {counts}')
    ```
    ```text
    The bitstring shape is: (1024, 1)
    The counts are: {'00': 523, '11': 501}
    ```

3. `Sampler and Estimator`: The sampling overhead, commonly exposed by V1 implementations
  through the `shots` run option, is now an argument of the `run()` method of the primitives
  that can be specified at the **pub** level.
  Differently to the V1 API, the base classes now expose the arguments in different formats:

    * `BaseSamplerV2.run` exposes a `shots` argument (similarly to the old workflow):
        ```python
        # Sample two circuits at 128 shots each.
        sampler_v2.run([circuit1, circuit2], shots=128)
        # Sample two circuits at different amounts of shots. The "None"s are necessary
        # as placeholders
        # for the lack of parameter values in this example.
        sampler_v2.run([(circuit1, None, 123), (circuit2, None, 456)])
        ```

    * `EstimatorV2.run` introduces a `precision` argument that specifies the error bars
    that the primitive implementation should target for expectation values estimates:
        ```python
        # Estimate expectation values for two pubs, both with 0.05 precision.
        estimator_v2.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)
        ```

<span id="v1-changes"></span>
### Updates in the V1 interface

* Implicit conversion from a dense `BaseOperator` to a `SparsePauliOp` in `Estimator` observable
  arguments is no longer allowed. You should explicitly convert to a `SparsePauliOp`
  using `SparsePauliOp.from_operator(operator)` instead.

* Using a `PauliList` in `Estimator` observable arguments is no longer allowed.
  Instead you should explicitly convert the argument using `SparsePauliOp(pauli_list)` first.

<span id="qiskit.providers"></span>
## qiskit.providers

<span id="basicaer"></span>
### basicaer

Most of the functionality in the
[`qiskit.providers.basicaer`](/api/qiskit/0.46/providers_basicaer) module has
been replaced with the new
[`qiskit.providers.basic_provider`](/api/qiskit/providers_basic_provider) module,
except for the
[`UnitarySimulatorPy`](/api/qiskit/0.46/qiskit.providers.basicaer.UnitarySimulatorPy)
and
[`StatevectorSimulatorPy`](/api/qiskit/0.46/qiskit.providers.basicaer.StatevectorSimulatorPy)
classes, whose functionality was already contained in the
[`quantum_info`](/api/qiskit/qiskit.quantum_info) module.

The migration to the new paths should be straightforward, you can replace most
classes in [`qiskit.providers.basicaer`](/api/qiskit/0.46/providers_basicaer)
with their
[`qiskit.providers.basic_provider`](/api/qiskit/providers_basic_provider)
counterpart (drop-in replacement). Note that the following classes have not
only changed path, but also changed names:

Deprecated                       | Alternative
---------------------------------|--------------------------------------------
[`qiskit.providers.basicaer`](/api/qiskit/0.46/providers_basicaer)                            |  [`qiskit.providers.basic_provider`](/api/qiskit/providers_basic_provider)
[`BasicAerProvider`](/api/qiskit/0.46/qiskit.providers.basicaer.BasicAerProvider)             |  [`BasicProvider`](/api/qiskit/qiskit.providers.basic_provider.BasicProvider)
[`BasicAerJob`](/api/qiskit/0.46/qiskit.providers.basicaer.BasicAerJob)                       |  [`BasicProviderJob`](/api/qiskit/qiskit.providers.basic_provider.BasicProviderJob)
[`QasmSimulatorPy`](/api/qiskit/0.46/qiskit.providers.basicaer.QasmSimulatorPy)               |  [`BasicSimulator`](/api/qiskit/qiskit.providers.basic_provider.BasicSimulator)

<Admonition type="warning">
    Keep an eye out for global instances when migrating to the new module. There is no replacement for
    the `BasicAer` global instance that could be directly imported as `qiskit.BasicAer`. This means that
    it will **not** be valid to do `from qiskit import BasicProvider`.
    Instead, the provider class must be imported from its submodule and instantiated by the user:

    ```python
    # Deprecated
    from qiskit import BasicAer
    backend = BasicAer.get_backend('backend_name')

    # Alternative
    from qiskit.providers.basic_provider import BasicProvider
    backend = BasicProvider().get_backend('backend_name')
    ```
</Admonition>

As for the unitary and statevector simulators, they can be replaced with different
[`quantum_info`](/api/qiskit/qiskit.quantum_info) classes. This is not a drop-in replacement,
but the changes are minimal, see the migration examples below:

Deprecated                       |   Alternative
---------------------------------|--------------------------------------------
[`UnitarySimulatorPy`](/api/qiskit/0.46/qiskit.providers.basicaer.UnitarySimulatorPy)         |  [`quantum_info.Operator`](/api/qiskit/qiskit.quantum_info.Operator)
[`StatevectorSimulatorPy`](/api/qiskit/0.46/qiskit.providers.basicaer.StatevectorSimulatorPy) |  [`quantum_info.Statevector`](/api/qiskit/qiskit.quantum_info.Statevector)


The following examples show the migration paths of the three simulators in [`basicaer`](/api/qiskit/0.46/providers_basicaer).


<Tabs>
  <TabItem value="statevec" label="Statevector sim." default>
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Deprecated
    from qiskit import BasicAer
    backend = BasicAer.get_backend("statevector_simulator")
    statevector = backend.run(qc).result().get_statevector()

    # Alternative
    qc.remove_final_measurements() # no measurements allowed
    from qiskit.quantum_info import Statevector
    statevector = Statevector(qc)
    ```
  </TabItem>
  <TabItem value="unitary" label="Unitary sim.">
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Deprecated
    from qiskit import BasicAer
    backend = BasicAer.get_backend("unitary_simulator")
    result = backend.run(qc).result()

    # Alternative
    qc.remove_final_measurements() # no measurements allowed
    from qiskit.quantum_info import Operator
    result = Operator(qc).data
    ```
  </TabItem>
  <TabItem value="qasm" label="QASM sim.">
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Deprecated
    from qiskit import BasicAer
    backend = BasicAer.get_backend("qasm_simulator")
    result = backend.run(qc).result()

    # Alternative
    from qiskit.providers.basic_provider import BasicProvider
    backend = BasicProvider().get_backend("basic_simulator")
    result = backend.run(qc).result()
    # or, directly
    from qiskit.providers.basic_provider import BasicSimulator
    backend = BasicSimulator()
    result = backend.run(qc).result()
    ```
  </TabItem>
</Tabs>

<span id="fake-backends-runtime"></span>
### fake_provider

Most of the user-facing components of
[`qiskit.providers.fake_provider`](/api/qiskit/0.46/providers_fake_provider) have
been migrated to the `qiskit-ibm-runtime` Python package. This includes the
fake provider classes, all of the device-specific fake backends (such as
`FakeVigo`, `FakeNairobiV2`, `FakeSherbrooke` and so on), and the fake backend
base classes. The following table shows the affected classes.

<Tabs>
  <TabItem value="backends" label="Fake Backends" default>
      * Any class in [`qiskit.providers.fake_provider.backends`](/api/qiskit/0.46/qiskit.providers.fake_provider.backends)
      * [`fake_provider.fake_backend.FakeBackend`](/api/qiskit/0.46/qiskit.providers.fake_provider.fake_backend.FakeBackend)
      * [`fake_provider.fake_backend.FakeBackendV2`](/api/qiskit/0.46/qiskit.providers.fake_provider.fake_backend.FakeBackendV2)
  </TabItem>
  <TabItem value="providers" label="Fake Providers">
      * [`fake_provider.FakeProvider`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeProvider)
      * [`fake_provider.FakeProviderForBackendV2`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeProviderForBackendV2)
      * [`fake_provider.FakeProviderFactory`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeProviderFactory)
  </TabItem>
</Tabs>

To migrate to the new path:

1. Install a version of `qiskit-ibm-runtime` higher than `0.17.1`:

   ```bash
   pip install 'qiskit-ibm-runtime>=0.17.1'
   ```

2. Replace instances of `qiskit.providers.fake_provider` in your code with
   `qiskit_ibm_runtime.fake_provider`. For example:

    ```python
    # Deprecated
    from qiskit.providers.fake_provider import FakeProvider
    backend1 = FakeProvider().get_backend("fake_ourense")

    from qiskit.providers.fake_provider import FakeSherbrooke
    backend2 = FakeSherbrooke()

    # Alternative
    from qiskit_ibm_runtime.fake_provider import FakeProvider
    backend1 = FakeProvider().get_backend("fake_ourense")

    from qiskit_ibm_runtime.fake_provider import FakeSherbrooke
    backend2 = FakeSherbrooke()
    ```

The fake backend base classes have also been migrated, but show some differences in the import path:

Deprecated                       |   Alternative
---------------------------------|--------------------------------------------
[`qiskit.providers.fake_provider.FakeQasmBackend`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeQasmBackend)             |  [`qiskit_ibm_runtime.fake_provider.fake_qasm_backend.FakeQasmBackend`](/api/qiskit_ibm_runtime/qiskit_ibm_runtime.fake_provider.fake_qasm_backend.FakeQasmBackend)
[`qiskit.providers.fake_provider.FakePulseBackend`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakePulseBackend)             |  [`qiskit_ibm_runtime.fake_provider.fake_pulse_backend.FakePulseBackend`](/api/qiskit_ibm_runtime/qiskit_ibm_runtime.fake_provider.fake_pulse_backend.FakePulseBackend)


<Admonition type="note">
    If you depend on fake backends for unit testing a downstream libray and have conflicts with the
    `qiskit-ibm-runtime` dependency, you can also find new qiskit-native generic fake backend alternatives.
    These include the following `BackendV1` classes (drop-in replacements):

    * [`qiskit.providers.fake_provider.Fake5QV1`](/api/qiskit/qiskit.providers.fake_provider.Fake5QV1)
    * [`qiskit.providers.fake_provider.Fake20QV1`](/api/qiskit/qiskit.providers.fake_provider.Fake20QV1)
    * [`qiskit.providers.fake_provider.Fake7QPulseV1`](/api/qiskit/qiskit.providers.fake_provider.Fake7QPulseV1)
    * [`qiskit.providers.fake_provider.Fake27QPulseQV1`](/api/qiskit/qiskit.providers.fake_provider.Fake27QPulseQV1)
    * [`qiskit.providers.fake_provider.Fake127QPulseQV1`](/api/qiskit/qiskit.providers.fake_provider.Fake127QPulseQV1)

    As well as a configurable class that returns `BackendV2` instances:

    * [`qiskit.providers.fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
</Admonition>


<span id="fake_provider-special-testing-backends"></span>
### fake_provider (special testing backends)

The fake backend classes for special testing purposes in
[`qiskit.providers.fake_provider`](/api/qiskit/0.46/providers_fake_provider) have
**not** been migrated to `qiskit_ibm_runtime.fake_provider`. The recommended
migration path consists on using the new
[`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
class to configure a backend with similar properties or building a custom
target.

Deprecated                       |   Alternative
---------------------------------|--------------------------------------------
[`fake_provider.FakeBackendV2`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeBackendV2) | [`fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackend5QV2`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeBackend5QV2) | [`fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackendV2LegacyQubitProps`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeBackendV2LegacyQubitProps) | [`fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackendSimple`](/api/qiskit/0.46/qiskit.providers.fake_provider.FakeBackendSimple) | [`fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.ConfigurableFakeBackend`](/api/qiskit/0.46/qiskit.providers.fake_provider.ConfigurableFakeBackend) | [`fake_provider.GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)

Migration example to the new
[`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2)
class:

```python
# Legacy path
from qiskit.providers.fake_provider import FakeBackend5QV2
backend = FakeBackend5QV2()

# New path
from qiskit.providers.fake_provider import GenericBackendV2
backend = GenericBackendV2(num_qubits=5)
# note that this class will generate 5q backend with generic
# properties that serves the same purpose as FakeBackend5QV2
# but will not be identical.
```

<span id="other-migration-tips"></span>
### Other migration tips

* Importing from `qiskit.providers.aer` is no longer possible. Instead, import
  from `qiskit_aer`, which is a drop-in replacement. To install `qiskit_aer`,
  run:

    ```bash
    pip install qiskit-aer
    ```

* Support for running pulse jobs on backends from
  [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider) has
  been removed in Qiskit 1.0.  This is due to Qiskit Aer removing its
  simulation functionality for such jobs.  For low-level Hamiltonian-simulation
  workloads, consider using a specialized library such as [Qiskit
  Dynamics](https://qiskit.org/ecosystem/dynamics).

<span id="qiskit.pulse"></span>
## qiskit.pulse

<span id="ParametricPulse"></span>
### ParametricPulse

The `qiskit.pulse.library.parametric_pulses.ParametricPulse` base class and
pulse libray have been superseded by `qiskit.pulse.SymbolicPulse` and the
corresponding pulse library. `SymbolicPulse` provides better performance,
flexibility and QPY support:

Deprecated                       |   Alternative
---------------------------------|--------------------------------------------
[`pulse.library.parametric_pulses.ParametricPulse`](/api/qiskit/0.46/qiskit.pulse) | [`qiskit.pulse.SymbolicPulse`](/api/qiskit/qiskit.pulse.SymbolicPulse)
[`pulse.library.parametric_pulses.Constant`](/api/qiskit/0.46/qiskit.pulse) |  ?
[`pulse.library.parametric_pulses.Drag`](/api/qiskit/0.46/qiskit.pulse) |  ?
[`pulse.library.parametric_pulses.Gaussian`](/api/qiskit/0.46/qiskit.pulse) |  ?
[`qiskit.pulse.library.parametric_pulses.GaussianSquare`](/api/qiskit/0.46/qiskit.pulse) |  ?

<span id="injecting-circuit-gate-operations"></span>
### Injecting circuit gate operations

Injecting circuit gate operations into the pulse builder context through
`qiskit.pulse.builder.call` is no longer possible. This removal affects input
arguments of type `QuantumCircuit` as well as the following functions:

* `qiskit.pulse.builder.call_gate`
* `qiskit.pulse.builder.cx`
* `qiskit.pulse.builder.u1`
* `qiskit.pulse.builder.u2`
* `qiskit.pulse.builder.u3`
* `qiskit.pulse.builder.x`

If you still wish to inject backend calibrated schedules, use the following
pattern instead of calling gate commands.

```python
from qiskit.providers.fake_provider import GenericBackendV2
from qiskit import pulse

backend = GenericBackendV2(num_qubits=5)
sched = backend.target['x'][(qubit,)].calibration

with pulse.build() as only_pulse_scheds:
    pulse.call(sched)
```

Similarly, a `QuantumCircuit` can be injected in the builder context by
manually transpiling and scheduling the object.

```python
from math import pi
from qiskit.compiler import schedule, transpile
qc = QuatumCircuit(2)
qc.rz(pi/2, 0)
qc.sx(0)
qc.rz(pi/2, 0)
qc.cx(0, 1)
qc_t = transpile(qc, backend)
sched = schedule(qc_t, backend)
with pulse.build() as only_pulse_scheds:
    pulse.call(sched)
```

In any case, we now recommend writing a minimum pulse program with the builder
and attach it to `QuantumCircuit` through the `QuantumCircuit.add_calibration`
method as a microcode of a gate instruction, rather than writing the entire
program with the pulse model.

<span id="builder.build"></span>
### builder.build

The following arguments in `qiskit.pulse.builder.build` have been removed:

* `default_transpiler_settings`
* `default_circuit_scheduler_settings`

Together with the functions:

* `qiskit.pulse.builder.active_transpiler_settings`
* `qiskit.pulse.builder.active_circuit_scheduler_settings`
* `qiskit.pulse.builder.transpiler_settings`
* `qiskit.pulse.builder.circuit_scheduler_settings`

The alternative is ?


<span id="library"></span>
### library

The discrete pulse library has been removed from the codebase. This includes:

* `qiskit.pulse.library.constant`
* `qiskit.pulse.library.zero`
* `qiskit.pulse.library.square`
* `qiskit.pulse.library.sawtooth`
* `qiskit.pulse.library.triangle`
* `qiskit.pulse.library.cos`
* `qiskit.pulse.library.sin`
* `qiskit.pulse.library.gaussian`
* `qiskit.pulse.library.gaussian_deriv`
* `qiskit.pulse.library.sech`
* `qiskit.pulse.library.sech_deriv`
* `qiskit.pulse.library.gaussian_square`
* `qiskit.pulse.library.drag`

Instead, use the corresponding
[`qiskit.pulse.SymbolicPulse`](/api/qiskit/qiskit.pulse.library.SymbolicPulse),
with
[`SymbolicPulse.get_waveform()`](/api/qiskit/qiskit.pulse.library.SymbolicPulse).
For example, instead of `pulse.gaussian(100,0.5,10)` use
`pulse.Gaussian(100,0.5,10).get_waveform()`. Note that the phase of both
[`Sawtooth`](/api/qiskit/qiskit.pulse.library.Sawtooth_class.rst) and
[`Square`](/api/qiskit/qiskit.pulse.library.Square_fun.rst) is defined such that
a phase of `2\\pi` shifts by a full cycle, contrary to the discrete
counterpart. Also note that complex amplitude support is deprecated in the
symbolic pulse library - use `float`, `amp` and  `angle` instead.

<span id="ScalableSymbolicPulse"></span>
### ScalableSymbolicPulse

Loading library `qiskit.pulse.ScalableSymbolicPulse` objects with complex `amp`
parameter from qpy files of version 5 or lower (Qiskit Terra < 0.23.0) is no
longer possible. No migration action is required, as complex `amp` will be
automatically converted to `float` (`amp`, `angle`).

The change applies to the pulses:
* [`qiskit.pulse.Constant`](/api/qiskit/qiskit.pulse.library.Constant_class.rst)
* [`qiskit.pulse.Drag`](/api/qiskit/qiskit.pulse.library.Drag_class.rst)
* [`qiskit.pulse.Gaussian`](/api/qiskit/qiskit.pulse.library.Gaussian_class.rst)
* [`qiskit.pulse.GaussianSquare`](/api/qiskit/qiskit.pulse.library.GaussianSquare)


<span id="qiskit.qasm"></span>
## qiskit.qasm

The legacy OpenQASM 2 parser module previously present in `qiskit.qasm` has
been superseded by the [`qiskit.qasm2`](/api/qiskit/qasm2) module which
provides a faster and more correct parser for OpenQASM 2. The high level
`QuantumCircuit` methods
[`from_qasm_file()`](/api/qiskit/qiskit.circuit.QuantumCircuit#from_qasm_file)
and
[`from_qasm_str()`](/api/qiskit/qiskit.circuit.QuantumCircuit#from_qasm_str)
remain the same, but will use the new parser internally. However, the public
interface for the `qasm2` module is not the same. While the `qiskit.qasm`
module provided an interface to an abstract syntax tree returned by the `ply`
parser library, `qiskit.qasm2` does not expose the AST or any lower level
implementation details about the parser. It instead takes OpenQASM 2 input and
outputs a `QuantumCircuit` object.

For example, if you were previously running something like:

```python
import qiskit.qasm
from qiskit.converters import ast_to_dag, dag_to_circuit

ast = qiskit.qasm.Qasm(filename="myfile.qasm").parse()
dag = ast_to_dag(ast)
qasm_circ = dag_to_circuit(dag)
```

this would be replaced with:

```python
import qiskit.qasm2

qasm_circ = qiskit.qasm2.load("myfile.qasm")
```

<span id="qiskit.quantum_info"></span>
## qiskit.quantum_info

The `qiskit.quantum_info.synthesis` module has been migrated to different
locations in the codebase, mostly `qiskit.synthesis`. For more information, see
[qiskit.synthesis](#qiskit.synthesis).

<span id="qiskit.synthesis"></span>
## qiskit.synthesis

The `qiskit.quantum_info.synthesis` module has been migrated to different locations in the codebase,
mostly `qiskit.synthesis`:

Deprecated | Alternative
-----------|------------
`OneQubitEulerDecomposer` | `qiskit.synthesis.one_qubit.OneQubitEulerDecomposer`
`TwoQubitBasisDecomposer` | `qiskit.synthesis.two_qubits.TwoQubitBasisDecomposer`
`XXDecomposer` | `qiskit.synthesis.two_qubits.XXDecomposer`
`two_qubit_cnot_decompose` | `qiskit.synthesis.two_qubits.two_qubit_cnot_decompose`
`Quaternion` | [`qiskit.quantum_info`](/api/qiskit/quantum_info)

This move has not affected the usual import path of `Quaternion`, but accessing
it through `qiskit.quantum_info.synthesis` is no longer possible.

Finally, `cnot_rxx_decompose` has been removed from the codebase --> why?

<span id="qiskit.test"></span>
## qiskit.test

The `qiskit.test` module is no longer a public module.  This was never intended to be public,
nor used outside of Qiskit's own test suite.  All functionality was specific to Qiskit and no
alternative is provided; if you needed similar functionality, you should include it in your own
test harnesses.

<span id="qiskit.tools"></span>
## qiskit.tools

The `qiskit.tools` module was removed in Qiskit 1.0.0. Most of this functionality was
either replaced by similar functionality in other packages or removed with no alternative.
The primary exception was the `qiskit.tools.parallel_map()` function has been relocated to
the [`qiskit.utils`](/api/qiskit/utils) module. It can be used
from this new location instead. For example:

If you were previously running:

```python
# Deprecated
from qiskit.tools import parallel_map

parallel_map(func, input)

# Alternative
from qiskit.utils import parallel_map

parallel_map(func, input)
```

<span id="jupyter"></span>
### jupyter

The `qiskit.tools.jupyter` submodule has been removed because the functionality
in this module is tied to the legacy `qiskit-ibmq-provider` package which is no
longer supported. It also only supported `BackendV1` and not the newer
[`BackendV2`](/api/qiskit/qiskit.providers.BackendV2) interface. For
similar functionality, see
[`qiskit-ibm-provider.ibm_jupyter`](/api/qiskit-ibm-provider/ibm_jupyter).

<span id="monitor"></span>
### monitor

The `qiskit.tools.monitor` submodule is deprecated because it was tied to the
legacy `qiskit-ibmq-provider` package which is no longer supported and also
only supported `BackendV1` interface and not the newer
[`BackendV2`](/api/qiskit/qiskit.providers.BackendV2) interface. There is
no alternative provided for this functionality.

<span id="visualization"></span>
### visualization

The `qiskit.tools.visualization` submodule has been removed. This module was a
legacy redirect from the original location of Qiskit's visualization module and
was moved to [`qiskit.visualization`](/api/qiskit/visualization) in Qiskit
0.8.0. If you're still using this path you can just update your imports from
`qiskit.tools.visualization` to
[`qiskit.visualization`](/api/qiskit/visualization).

```python
# Deprecated
from qiskit.tools.visualization import plot_histogram

plot_histogram(counts)

# Alternative
from qiskit.visualization import plot_histogram

plot_histogram(counts)
```

<span id="events"></span>
### events

The `qiskit.tools.events` module and the `progressbar()` utility
it exposed has been deprecated and will be removed in the Qiskit 1.0.0
release. This module's functionality was not widely used and better covered
by dedicated packages such as [tqdm](https://github.com/tqdm/tqdm).

<span id="qiskit.transpiler"></span>
## qiskit.transpiler

<span id="synthesis"></span>
### synthesis

The items in `qiskit.transpiler.synthesis` module have been migrated to new locations:

Deprecated | Alternative
-----------|------------
`qiskit.transpiler.synthesis.aqc` | [`qiskit.synthesis.unitary.aqc`](/api/qiskit/synthesis_aqc)(except for `AQCSynthesisPlugin`)
`qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin` | [`qiskit.transpiler.passes.synthesis.AQCSynthesisPlugin`](/api/qiskit/qiskit.transpiler.passes.AQCSynthesisPlugin)
`qiskit.transpiler.synthesis.graysynth` | [`qiskit.synthesis.synth_cnot_phase_aam`](/api/qiskit/synthesis)
`qiskit.transpiler.synthesis.cnot_synth` | [`qiskit.synthesis.synth_cnot_count_full_pmh`](/api/qiskit/synthesis)

<span id="passes"></span>
### passes

The `NoiseAdaptiveLayout` transpiler pass has been superseded by
[`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout) and
[`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout)
which will set a layout based on the reported noise characteristics of a
backend. Both the pass and the corresponding `"noise_adaptive"` layout stage
plugin have been removed from Qiskit.

The `CrosstalkAdaptiveSchedule` transpiler pass has been removed from the
codebase. This pass was not usable any longer because its internal operation
was dependent on custom properties being set in the `BackendProperties` payload
of a `BackendV1` instance. As no backends are setting these fields the pass has
been deprecated.

<span id="qiskit.utils"></span>
## qiskit.utils

The following tools in `qiskit.utils` have been removed:
  * `qiskit.utils.arithmetic`
  * `qiskit.utils.circuit_utils`
  * `qiskit.utils.entangler_map`
  * `qiskit.utils.name_unnamed_args`

These functions were used exclusively in the deprecated `qiskit.algorithms` and
`qiskit.opflow` modules, and have replacement.

<span id="qiskit.visualization"></span>
## qiskit.visualization

The `qiskit.visualization.qcstyle` module has been removed, instead you should
use [`qiskit.visualization.circuit.qcstyle`](/api/qiskit/qiskit.visualization.circuit.qcstyle.DefaultStyle)
as direct replacement.

