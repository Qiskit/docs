---
title: Qiskit 1.0 feature migration guide
description: Adapt to feature changes with Qiskit 1.0
---

# Qiskit 1.0 feature changes

Qiskit 1.0 ...

This guide is organized by qiskit module, you can use the navigation bar on the right-hand
side to jump to the module you are interested in.

<span id="qiskit.global"></span>
## Changes to global instances and functions

* The `qiskit.Aer` object is no longer available in Qiskit 1.0.  You should instead
  use the same object from the `qiskit_aer` namespace, which is a drop-in replacement.
  To install `qiskit_aer`, run:

  ```bash
  pip install qiskit-aer
  ```
* The `qiskit.BasicAer` object is no longer available in Qiskit 1.0. See the
  [`basicaer migration section`](#migrate-from-basicaer-to-basic_provider) for more
  information on migration options.

* The `qiskit.execute` function is no longer available in Qiskit 1.0.
  This function served as a high-level wrapper around the transpile and run functionalities
  in Qiskit. Instead of `qiskit.execute`, you can explicitly use the `transpile` function
  (with appropriate transpile options) followed by `backend.run()`
  (with appropriate run options).

  Migration example:

  ```python
  # Legacy path
  from qiskit import execute
  job = execute(circuit, backend)

  # New path
  from qiskit import transpile
  new_circuit = transpile(circuit, backend)
  job = backend.run(new_circuit)
  ```

  Alternatively, the `Sampler` primitive is semantically equivalent to the
  deprecated `qiskit.execute` function. The class `BackendSampler`
  is a generic wrapper for backends that do not support primitives:

  ```python
  from qiskit.primitives import BackendSampler
  sampler = BackendSampler(backend)
  job = sampler.run(circuit)
  ```

<span id="qiskit.circuit"></span>
## Changes to `qiskit.circuit`

* The :meth:`.QuantumCircuit.qasm` method used to generate a OpenQASM 2
  representation of the :class:`.QuantumCircuit` object has been deprecated
  and will be removed in the Qiskit 1.0.0 release. The
  :func:`.qasm2.dump` or :func:`.qasm2.dumps` functions which provide similar
  functionality should be used instead. If you were using the :meth:`.QuantumCircuit.qasm`
  method to generate pygments formatted output you should instead look at the standalone
  ``openqasm-pygments`` package to provide this functionality (as :func:`.qasm2.dump`
  and :func:`.qasm2.dumps` do not provide pygments colored output).


<span id="qiskit.converters"></span>
## Changes to `qiskit.converters`

* The ``qiskit.converters.ast_to_dag`` function has been deprecated and
  will be removed in the Qiskit 1.0.0 release. It previously was used to
  convert the abstract syntax tree generated by the legacy OpenQASM 2 parser
  (in the :mod:`qiskit.qasm` module which has been deprecated) and convert
  that directly to a :class:`.DAGCircuit`. As the legacy OpenQASM 2 parser
  has been deprecated this function will no longer serves a purpose after the
  legacy parser is removed. If you were previously using this, you can
  instead parse your OpenQASM 2 files into a :class:`.QuantumCircuit` using
  the :meth:`.QuantumCircuit.from_qasm_file` or
  :meth:`.QuantumCircuit.from_qasm_str` constructor methods and then
  converting that :class:`.QuantumCircuit` into a :class:`.DAGCircuit`
  with :func:`.circuit_to_dag`.

<span id="qiskit.extensions"></span>
## Changes to `qiskit.extensions`

* The :mod:`qiskit.extensions` module is no longer available. 
  Most objects have been moved to :mod:`qiskit.circuit.library`, including:
  * :class:`~.library.DiagonalGate`,
  * :class:`~.library.HamiltonianGateGate`,
  * :class:`~.library.Initialize`,
  * :class:`~.library.Isometry`,
  * :class:`~.library.generalized_gates.mcg_up_diag.MCGupDiag`,
  * :class:`~.library.UCGate`,
  * :class:`~.library.UCPauliRotGate`,
  * :class:`~.library.UCRXGate`,
  * :class:`~.library.UCRYGate`,
  * :class:`~.library.UCRZGate`,
  * :class:`~.library.UnitaryGate`.
  The following circuit methods have also been removed:
  * ``QuantumCircuit.diagonal``,
  * ``QuantumCircuit.hamiltonian``,
  * ``QuantumCircuit.isometry`` and ``QuantumCircuit.iso``,
  * ``QuantumCircuit.uc``,
  * ``QuantumCircuit.ucrx``,
  * ``QuantumCircuit.ucry``,
  * ``QuantumCircuit.ucrz``.

Instead, these gates can be applied to a circuit by using :meth:`.QuantumCircuit.append`.
For example, for a :class`.DiagonalGate`, we have::

    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import DiagonalGate  # new location in the circuit library

    circuit = QuantumCircuit(2)
    circuit.h([0, 1])  # some initial state

    gate = DiagonalGate([1, -1, -1, 1])
    qubits = [0, 1]  # qubit indices on which to apply the gate
    circuit.append(gate, qubits)  # apply the gate


<span id="qiskit.primitives"></span>
## Changes to `qiskit.primitives`

The most notable change in the [`qiskit.primitives`](../qiskit/primitives) module is the
introduction of the new **primitives V2 interface**. This section will show how to migrate your
workflow from primitives V1 to primitives V2, as well as the few changes that have taken place
in the inputs accepted by the V1 interface.

<Admonition type="note">
From the 1.0 release onwards, we will refer to the pre-1.0 primitives interface as "primitives V1".
</Admonition>

Jump to subsection:

* [Migrate from V1 to V2](#migrate-to-v2)
* [Updates in V1 interface](#v1-changes)

<span id="migrate-to-v2"></span>
### Migrate from V1 to V2

The formal distinction between the primitives V1 and V2 APIs are the base classes from which
primitives implementations inherit. To transition to the new base classes you can maintain
the original import path from `qiskit.primitives`:

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`BaseEstimator`](../qiskit/qiskit.primitives.BaseEstimator)         |  [`BaseEstimatorV2`](../qiskit/qiskit.primitives.BaseEstimatorV2)
[`BaseSampler`](../qiskit/qiskit.primitives.BaseSampler)             |  [`BaseSamplerV2`](../qiskit/qiskit.primitives.BaseSamplerV2)

As for the qiskit core implementations of the V2 primitives (those importable from `qiskit.primitives`),
the names have been modified to clarify their purpose as implementations that can be run locally
with a statevector simulator backend. The new names **do not include the -V2 suffix**.

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`qiskit.primitives.Estimator`](../qiskit/qiskit.primitives.Estimator)         |  [`qiskit.primitives.StatevectorEstimator`](../qiskit/qiskit.primitives.StatevectorEstimator)
[`qiskit.primitives.Sampler`](../qiskit/qiskit.primitives.Sampler)             |  [`qiskit.primitives.StatevectorSampler`](../qiskit/qiskit.primitives.StatevectorSampler)


At a conceptual level, there are some notable differences to keep in mind when migrating from V1 to V2.
These differences are dictated by the base class, but are shown in the examples below using the statevector
implementations found in `qiskit.primitives`:

<Admonition type="note">
For the examples below, assume the following imports and primitive intializations:

```python
from qiskit.primitives import Sampler, StatevectorSampler, Estimator, StatevectorEstimator

estimator_v1 = Estimator()
sampler_v1 = Sampler()
estimator_v2 = StatevectorEstimator()
sampler_v2 = StatevectorSampler()

# define circuits, observables and param. values
```
</Admonition>

1. `Sampler and Estimator`: The new V2 primitives are designed to accept **vectorized inputs**,
  where single circuits can be grouped with array-valued specifications.
  That is, one circuit can be executed
  for arrays of `n` parameter sets and/or `n` observables (in the case of the estimator). Each group
  is called a **primitive unified bloc (pub)**, and can be represented
  as a tuple: `(1 x circuit, [n x observables], [n x parameters])`. The V1 interface didn't allow for
  the same flexibility, as there number of input circuits had to match the number of observables and
  parameter sets, as shown in the following examples:

<Tabs>
  <TabItem value="e-1-4" label="Estimator, 1 circuit, 4 obs." default>
      ```python
      # executing 1 circuit with 4 observables using Estimator V1
      job = estimator_v1.run([circuit] * 4, [obs1, obs2, obs3, obs4])
      evs = job.result().values

      # executing 1 circuit with 4 observables using Estimator V2
      job = estimator_v2.run((circuit, [obs1, obs2, obs3, obs4]))
      evs = job.result()[0].data.evs
      ```
  </TabItem>
  <TabItem value="s-1-3" label="Sampler, 1 circuit, 3 param. sets" default>
      ```python
      # executing 1 circuit with 3 parameter sets using Sampler V1
      job = sampler_v1.run([circuit] * 3, [vals1, vals2, vals3])
      evs = job.result().quasi_dists

      # executing 1 circuit with 3 parameter sets using Sampler V2
      job = sampler_v2.run((circuit, [vals1, vals2, vals3]))
      evs = job.result()[0].data
      ```
  </TabItem>
  <TabItem value="e-1-4-2" label="Estimator, 1 circuit, 4 obs., 3 param. sets" default>
      ```python
      # executing 1 circuit with 4 observables and 2 parameter sets using Estimator V1
      job = estimator_v1.run([circuit] * 8, [obs1, obs2, obs3, obs4] * 2, [vals1, vals2] * 4)
      evs = job.result().values

      # executing 1 circuit with 4 observables and 2 parameter sets using Estimator V2
      job = estimator_v2.run((circuit, [obs1, obs2, obs3, obs4], [vals1, vals2]))
      evs = job.result()[0].data.evs
      ```
  </TabItem>
</Tabs>

  V2 primitives accept multiple pubs as inputs, and each pub gets its own result. This
  allows for executing different circuits with different parameter/observable combinations,
  something not always possible in the V1 interface:

<Tabs>
  <TabItem value="s-2-1" label="Sampler, 2 circuits, 1 param. set" default>
      ```python
      # executing 2 circuits with 1 observable using Sampler V1
      job = sampler_v1.run([circuit1, circuit2], [obs1] * 2)
      evs = job.result().quasi_probs

      # executing 2 circuits with 1 observable using Sampler V2
      job = sampler_v2.run((circuit1, obs1), (circuit2, obs1))
      evs1 = job.result()[0].data # result for pub 1 (circuit 1)
      evs2 = job.result()[1].data # result for pub 2 (circuit 2)
      ```
  </TabItem>
  <TabItem value="e-2-2" label="Estimator, 2 circuits, 2 different obs." default>
      ```python
      # executing 2 circuits with different observables
      # is not possible using Estimator V1

      # executing 2 circuits with 2 different observables using Estimator V2
      job = estimator_v2.run((circuit1, obs1), (circuit2, obs2))
      evs1 = job.result()[0].data.evs # result for pub 1 (circuit 1)
      evs2 = job.result()[1].data.evs # result for pub 2 (circuit 2)
      ```
  </TabItem>
</Tabs>

2. `Sampler`: The V2 sampler now returns measurement outcome samples in the form of
  **bitstrings** or **counts**, instead of the quasi-probability distributions from the
  V1 interface.
  The bitstrings show the measurement outcomes preserving the shot order in which they
  were measured. The V2 sampler result objects organize data in terms of their
  input circuits' classical register names, for compatibility with dynamic circuits.

    ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```
    ```text
            ┌───┐      ░ ┌─┐
       q_0: ┤ H ├──■───░─┤M├───
            └───┘┌─┴─┐ ░ └╥┘┌─┐
       q_1: ─────┤ X ├─░──╫─┤M├
                 └───┘ ░  ║ └╥┘
    meas: 2/══════════════╩══╩═
                          0  1
    ```
    <Admonition type="warning">
    You can notice in the circuit above that the name of the classical register defaults to `"meas"`.
    This name will be used later to access the measurement bitstrings.
    </Admonition>

    ```python
    # Run using V1 sampler
    result = sampler_v1.run(circuit).result()
    quasi_dist = result.quasi_dists[0]
    print(f'The quasi-probability distribution is: {quasi_dist}')
    ```
    ```text
    The quasi-probability distribution is: {0: 0.5, 3: 0.5}
    ```
    ```python
    # Run using V2 sampler
    result = sampler_v2.run([circuit]).result()
    # Access result data for pub 0
    data_pub = result[0].data
    # Access bitstring for the classical register "meas"
    bitstring = data_pub.meas.array
    print(f'The bitstring shape is: {bitstring.shape}')
    # Get counts for the classical register "meas"
    counts = data_pub.meas.get_counts()
    print(f'The counts are: {counts}')
    ```
    ```text
    The bitstring shape is: (1024, 1)
    The counts are: {'00': 523, '11': 501}
    ```

3. `Sampler and Estimator`: The sampling overhead, commonly exposed by V1 implementations
  through the `shots` run option, is now an argument of the `run()` method of the primitives
  that can be specified at the **pub** level.
  Differently to the V1 API, the base classes now expose the arguments in different formats:

    * `BaseSamplerV2.run` exposes a `shots` argument (similarly to the old workflow):
        ```python
        # Sample two circuits at 128 shots each.
        sampler_v2.run([circuit1, circuit2], shots=128)
        # Sample two circuits at different amounts of shots. The "None"s are necessary
        # as placeholders
        # for the lack of parameter values in this example.
        sampler_v2.run([(circuit1, None, 123), (circuit2, None, 456)])
        ```

    * `EstimatorV2.run` introduces a `precision` argument that specifies the error bars
    that the primitive implementation should target for expectation values estimates:
        ```python
        # Estimate expectation values for two pubs, both with 0.05 precision.
        estimator_v2.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)
        ```

<span id="v1-changes"></span>
### Updates in the V1 interface

* Implicit conversion from a dense `BaseOperator` to a `SparsePauliOp` in `Estimator` observable
  arguments is no longer allowed. You should explicitly convert to a `SparsePauliOp`
  using `SparsePauliOp.from_operator(operator)` instead.

* Using a `PauliList` in `Estimator` observable arguments is no longer allowed.
  Instead you should explicitly convert the argument using `SparsePauliOp(pauli_list)` first.

<span id="qiskit.providers"></span>
## Changes to `qiskit.providers`

Jump to subsection:

* [Migrate from `basicaer` to `basic_provider`](#basicaer)
* [Migrate from `qiskit.providers.fake_provider` to `qiskit_ibm_runtime.fake_provider`](#fake-backends-runtime)
* [Migrate special testing fake backends in `qiskit.providers.fake_provider`](#fake-backends-testing)
* [Other migration tips for `qiskit.providers`](#provider-misc)

<span id="basicaer"></span>
### Migrate from `basicaer` to `basic_provider`

Most of the functionality in the [`qiskit.providers.basicaer`](../qiskit/0.46/providers_basicaer) module has
been replaced with the new [`qiskit.providers.basic_provider`](../qiskit/providers_basic_provider) module,
except for the [`UnitarySimulatorPy`](../qiskit/0.46/qiskit.providers.basicaer.UnitarySimulatorPy)  and
[`StatevectorSimulatorPy`](../qiskit/0.46/qiskit.providers.basicaer.StatevectorSimulatorPy) classes, whose
functionality was already contained in the [`quantum_info`](../qiskit/qiskit.quantum_info) module.

The migration to the new paths should be straightforward, you can replace most classes in
[`qiskit.providers.basicaer`](../qiskit/0.46/providers_basicaer) with their
[`qiskit.providers.basic_provider`](../qiskit/providers_basic_provider) counterpart (drop-in replacement).
Note that the classes have not only changed path, but also changed **names**:

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`qiskit.providers.basicaer`](../qiskit/0.46/providers_basicaer)                            |  [`qiskit.providers.basic_provider`](../qiskit/providers_basic_provider)
[`BasicAerProvider`](../qiskit/0.46/qiskit.providers.basicaer.BasicAerProvider)             |  [`BasicProvider`](../qiskit/qiskit.providers.basic_provider.BasicProvider)
[`BasicAerJob`](../qiskit/0.46/qiskit.providers.basicaer.BasicAerJob)                       |  [`BasicProviderJob`](../qiskit/qiskit.providers.basic_provider.BasicProviderJob)
[`QasmSimulatorPy`](../qiskit/0.46/qiskit.providers.basicaer.QasmSimulatorPy)               |  [`BasicSimulator`](../qiskit/qiskit.providers.basic_provider.BasicSimulator)

<Admonition type="warning">
    Keep an eye out for global instances when migrating to the new module. There is no replacement for
    the `BasicAer` global instance that could be directly imported as `qiskit.BasicAer`. This means that
    it will **not** be valid to do `from qiskit import BasicProvider`.
    Instead, the provider class must be imported from its submodule and instantiated by the user:

    ```python
    # Former path
    from qiskit. import BasicAer
    backend = BasicAer.get_backend('backend_name')

    # New path
    from qiskit.providers.basic_provider import BasicProvider
    backend = BasicProvider().get_backend('backend_name')
    ```
</Admonition>

As for the unitary and statevector simulators, they can be replaced with different
[`quantum_info`](../qiskit/qiskit.quantum_info) classes. This is not a drop-in replacement,
but the changes are minimal, see the migration examples below:

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`UnitarySimulatorPy`](../qiskit/0.46/qiskit.providers.basicaer.UnitarySimulatorPy)         |  use [`quantum_info.Operator`](../qiskit/qiskit.quantum_info.Operator)
[`StatevectorSimulatorPy`](../qiskit/0.46/qiskit.providers.basicaer.StatevectorSimulatorPy) |  use [`quantum_info.Statevector`](../qiskit/qiskit.quantum_info.Statevector)


The following examples show the migration paths of the three simulators in [`basicaer`](../qiskit/0.46/providers_basicaer).


<Tabs>
  <TabItem value="statevec" label="Statevector sim." default>
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Former path
    from qiskit import BasicAer
    backend = BasicAer.get_backend("statevector_simulator")
    statevector = backend.run(qc).result().get_statevector()

    # New path
    qc.remove_final_measurements() # no measurements allowed
    from qiskit.quantum_info import Statevector
    statevector = Statevector(qc)
    ```
  </TabItem>
  <TabItem value="unitary" label="Unitary sim.">
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Former path
    from qiskit import BasicAer
    backend = BasicAer.get_backend("unitary_simulator")
    result = backend.run(qc).result()

    # New path
    qc.remove_final_measurements() # no measurements allowed
    from qiskit.quantum_info import Operator
    result = Operator(qc).data
    ```
  </TabItem>
  <TabItem value="qasm" label="QASM sim.">
    ```python
    from qiskit import QuantumCircuit
    qc = QuantumCircuit(3)
    qc.h(0)
    qc.h(1)
    qc.cx(1,2)
    qc.measure_all()

    # Former path
    from qiskit import BasicAer
    backend = BasicAer.get_backend("qasm_simulator")
    result = backend.run(qc).result()

    # New path
    from qiskit.providers.basic_provider import BasicProvider
    backend = BasicProvider().get_backend("basic_simulator")
    result = backend.run(qc).result()
    # or, directly
    from qiskit.providers.basic_provider import BasicSimulator
    backend = BasicSimulator()
    result = backend.run(qc).result()
    ```
  </TabItem>
</Tabs>

<span id="fake-backends-runtime"></span>
### Migrate from `qiskit.providers.fake_provider` to `qiskit_ibm_runtime.fake_provider`

Most of the user-facing components of [`qiskit.providers.fake_provider`](../qiskit/0.46/providers_fake_provider)
have been migrated to the `qiskit-ibm-runtime` Python package. This includes the fake provider classes, all of
the device-specific fake backends (`FakeVigo`, `FakeNairobiV2`, `FakeSherbrooke`...), and the fake backend base classes
(see full list [here](fake-backends-table)).

To migrate to the new path:

1. Install a compatible version of `qiskit-ibm-runtime`, that is, higher than `0.17.1`:

   ```bash
   pip install 'qiskit-ibm-runtime>=0.17.1'
   ```
2. Look for instances of `qiskit.providers.fake_provider` in your code and replace the path with
   `qiskit_ibm_runtime.fake_provider`. For example:

    ```python
    # Legacy path
    from qiskit.providers.fake_provider import FakeProvider
    backend1 = FakeProvider().get_backend("fake_ourense")

    from qiskit.providers.fake_provider import FakeSherbrooke
    backend2 = FakeSherbrooke()

    # New path
    from qiskit_ibm_runtime.fake_provider import FakeProvider
    backend1 = FakeProvider().get_backend("fake_ourense")

    from qiskit_ibm_runtime.fake_provider import FakeSherbrooke
    backend2 = FakeSherbrooke()
    ```

<span id="fake-backends-table"></span>
These migration instructions are valid for the following classes:

<Tabs>
  <TabItem value="backends" label="Fake Backends" default>
      * Any class in [`qiskit.providers.fake_provider.backends`](../qiskit/0.46/qiskit.providers.fake_provider.backends)
      * [`fake_provider.fake_backend.FakeBackend`](../qiskit/0.46/qiskit.providers.fake_provider.fake_backend.FakeBackend)
      * [`fake_provider.fake_backend.FakeBackendV2`](../qiskit/0.46/qiskit.providers.fake_provider.fake_backend.FakeBackendV2)
  </TabItem>
  <TabItem value="providers" label="Fake Providers">
      * [`fake_provider.FakeProvider`](../qiskit/0.46/qiskit.providers.fake_provider.FakeProvider)
      * [`fake_provider.FakeProviderForBackendV2`](../qiskit/0.46/qiskit.providers.fake_provider.FakeProviderForBackendV2)
      * [`fake_provider.FakeProviderFactory`](../qiskit/0.46/qiskit.providers.fake_provider.FakeProviderFactory)
  </TabItem>
</Tabs>

The fake backend base classes have also been migrated, but show some differences in the import path:

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`qiskit.providers.fake_provider.FakeQasmBackend`](../qiskit/0.46/qiskit.providers.fake_provider.FakeQasmBackend)             |  [`qiskit_ibm_runtime.fake_provider.fake_qasm_backend.FakeQasmBackend`](../qiskit_ibm_runtime/qiskit_ibm_runtime.fake_provider.fake_qasm_backend.FakeQasmBackend)
[`qiskit.providers.fake_provider.FakePulseBackend`](../qiskit/0.46/qiskit.providers.fake_provider.FakePulseBackend)             |  [`qiskit_ibm_runtime.fake_provider.fake_pulse_backend.FakePulseBackend`](../qiskit_ibm_runtime/qiskit_ibm_runtime.fake_provider.fake_pulse_backend.FakePulseBackend)


<Admonition type="note">
    If you depend on fake backends for unit testing a downstream libray and have conflicts with the
    `qiskit-ibm-runtime` dependency, you can also find new qiskit-native generic fake backend alternatives.
    These include the following `BackendV1` classes (drop-in replacements):

    * [`qiskit.providers.fake_provider.Fake5QV1`](../qiskit/qiskit.providers.fake_provider.Fake5QV1)
    * [`qiskit.providers.fake_provider.Fake20QV1`](../qiskit/qiskit.providers.fake_provider.Fake20QV1)
    * [`qiskit.providers.fake_provider.Fake7QPulseV1`](../qiskit/qiskit.providers.fake_provider.Fake7QPulseV1)
    * [`qiskit.providers.fake_provider.Fake27QPulseQV1`](../qiskit/qiskit.providers.fake_provider.Fake27QPulseQV1)
    * [`qiskit.providers.fake_provider.Fake127QPulseQV1`](../qiskit/qiskit.providers.fake_provider.Fake127QPulseQV1)

    As well as a configurable class that returns `BackendV2` instances:

    * [`qiskit.providers.fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)
</Admonition>


<span id="fake-backends-testing"></span>
### Migrate special testing fake backends in `qiskit.providers.fake_provider`

The fake backend classes for special testing purposes in
[`qiskit.providers.fake_provider`](../qiskit/0.46/providers_fake_provider)
have **not** been migrated to `qiskit_ibm_runtime.fake_provider`. The recommended migration path consists
on using the new [`GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2) class
to configure a backend with similar properties or building a custom target.

Migrate from                     |   Replace with
---------------------------------|--------------------------------------------
[`fake_provider.FakeBackendV2`](../qiskit/0.46/qiskit.providers.fake_provider.FakeBackendV2) |  use [`fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackend5QV2`](../qiskit/0.46/qiskit.providers.fake_provider.FakeBackend5QV2) |  use [`fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackendV2LegacyQubitProps`](../qiskit/0.46/qiskit.providers.fake_provider.FakeBackendV2LegacyQubitProps) |  use [`fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.FakeBackendSimple`](../qiskit/0.46/qiskit.providers.fake_provider.FakeBackendSimple) |  use [`fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)
[`fake_provider.ConfigurableFakeBackend`](../qiskit/0.46/qiskit.providers.fake_provider.ConfigurableFakeBackend) |  use [`fake_provider.GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2)

Migration example to the new [`GenericBackendV2`](../qiskit/qiskit.providers.fake_provider.GenericBackendV2) class:

```python
# Legacy path
from qiskit.providers.fake_provider import FakeBackend5QV2
backend = FakeBackend5QV2()

# New path
from qiskit.providers.fake_provider import GenericBackendV2
backend = GenericBackendV2(num_qubits=5)
# note that this class will generate 5q backend with generic
# properties that serves the same purpose as FakeBackend5QV2
# but will not be identical.
```

<span id="provider-misc"></span>
### Other migration tips for `qiskit.providers`

* Importing from `qiskit.providers.aer` is no longer possible.  You
  should instead import from `qiskit_aer`, which is a drop-in replacement.
  To install `qiskit_aer`, run:

    ```bash
    pip install qiskit-aer
    ```

* Support for running pulse jobs on backends from [`qiskit.providers.fake_provider`](../qiskit/providers_fake_provider)
  has been removed in Qiskit 1.0.  This is due to Qiskit Aer removing its simulation
  functionality for such jobs.  For low-level Hamiltonian-simulation workloads, consider using
  a specialised library such as [Qiskit Dynamics](https://qiskit.org/ecosystem/dynamics).

<span id="qiskit.pulse"></span>
## Changes to `qiskit.pulse`

* The :class:`~qiskit.pulse.library.parametric_pulses.ParametricPulse` base class and pulses are now
  deprecated, and will be removed in Qiskit 1.0. This includes:
  * :class:`~qiskit.pulse.library.parametric_pulses.ParametricPulse`
  * :class:`~qiskit.pulse.library.parametric_pulses.Constant`
  * :class:`~qiskit.pulse.library.parametric_pulses.Drag`
  * :class:`~qiskit.pulse.library.parametric_pulses.Gaussian`
  * :class:`~qiskit.pulse.library.parametric_pulses.GaussianSquare`
  The class has been superseded by :class:`~qiskit.pulse.SymbolicPulse` and the corresponding pulse library.
  :class:`~qiskit.pulse.SymbolicPulse` provides better performance, flexibility and QPY support.

* Injecting circuit gate operations into the pulse builder context is now deprecated. The deprecation
  affects the following functions:
  * :func:`~qiskit.pulse.builder.call_gate`,
  * :func:`~qiskit.pulse.builder.cx`,
  * :func:`~qiskit.pulse.builder.u1`,
  * :func:`~qiskit.pulse.builder.u2`,
  * :func:`~qiskit.pulse.builder.u3`,
  * :func:`~qiskit.pulse.builder.x`
  As well as input arguments of type :class:`.QuantumCircuit` type in :func:`~qiskit.pulse.builder.call`.
  If you still wish to inject backend calibrated schedules,
  you can use following pattern instead of calling gate commands.
  .. code-block:: python
    from qiskit.providers.fake_provider import GenericBackendV2
    from qiskit import pulse
    backend = GenericBackendV2(num_qubits=5)
    sched = backend.target['x'][(qubit,)].calibration
    with pulse.build() as only_pulse_scheds:
      pulse.call(sched)
  Similarly, :class:`.QuantumCircuit` can be injected in the builder context
  by manually transpiling and scheduling the object.
  .. code-block:: python
    from math import pi
    from qiskit.compiler import schedule, transpile
    qc = QuatumCircuit(2)
    qc.rz(pi/2, 0)
    qc.sx(0)
    qc.rz(pi/2, 0)
    qc.cx(0, 1)
    qc_t = transpile(qc, backend)
    sched = schedule(qc_t, backend)
    with pulse.build() as only_pulse_scheds:
      pulse.call(sched)
  In any case we now recommend to write a minimum pulse program
  with the builder and attach it to :class:`.QuantumCircuit` via the
  :meth:`.QuantumCircuit.add_calibration` method as a microcode of a
  gate instruction, rather than writing the entire program with the pulse model.
  The following arguments in :func:`~qiskit.pulse.builder.build` have also been deprecated:
  * :code:`default_transpiler_settings`
  * :code:`default_circuit_scheduler_settings`
  Together with the functions:
  * :func:`~qiskit.pulse.builder.active_transpiler_settings`
  * :func:`~qiskit.pulse.builder.active_circuit_scheduler_settings`
  * :func:`~qiskit.pulse.builder.transpiler_settings`
  * :func:`~qiskit.pulse.builder.circuit_scheduler_settings`

* The discrete pulse library is now deprecated and will be removed in a future release. This includes:
  * :func:`~qiskit.pulse.library.constant`
  * :func:`~qiskit.pulse.library.zero`
  * :func:`~qiskit.pulse.library.square`
  * :func:`~qiskit.pulse.library.sawtooth`
  * :func:`~qiskit.pulse.library.triangle`
  * :func:`~qiskit.pulse.library.cos`
  * :func:`~qiskit.pulse.library.sin`
  * :func:`~qiskit.pulse.library.gaussian`
  * :func:`~qiskit.pulse.library.gaussian_deriv`
  * :func:`~qiskit.pulse.library.sech`
  * :func:`~qiskit.pulse.library.sech_deriv`
  * :func:`~qiskit.pulse.library.gaussian_square`
  * :func:`~qiskit.pulse.library.drag`
  Instead, use the corresponding :class:`~qiskit.pulse.SymbolicPulse`, with :meth:`~.SymbolicPulse.get_waveform()`.
  For example, instead of ``pulse.gaussian(100,0.5,10)`` use ``pulse.Gaussian(100,0.5,10).get_waveform()``.
  Note that the phase of both ``Sawtooth`` and ``Square`` is defined such that a phase of :math:`2\\pi`
  shifts by a full cycle, contrary to the discrete counterpart. Also note that complex amplitude support is
  deprecated in the symbolic pulse library - use ``float``, ``amp`` and  ``angle`` instead.

* Loading library :class:`~.qiskit.pulse.ScalableSymbolicPulse` objects with
  complex ``amp`` parameter from
  qpy files of version 5 or lower (Qiskit Terra < 0.23.0) is now deprecated.
  Following the removal in Qiskit 1.0.0, complex ``amp`` will be automatically
  converted to float (``amp``, ``angle``). The change applies to the pulses:
  * :class:`~.qiskit.pulse.Constant`
  * :class:`~.qiskit.pulse.Drag`
  * :class:`~.qiskit.pulse.Gaussian`
  * :class:`~.qiskit.pulse.GaussianSquare`

<span id="qiskit.qasm2"></span>
## Changes to `qiskit.qasm2`

* The legacy OpenQASM 2 parser module previously present in :mod:`qiskit.qasm` has been
  deprecated. It will be removed in the Qiskit 1.0.0 release. The legacy
  OpenQASM 2 parser has been superseded by the :mod:`qiskit.qasm2` module
  which provides a faster more correct parser for OpenQASM 2.

<span id="qiskit.quantum_info"></span>
## Changes to `qiskit.quantum_info`

* The :mod:`qiskit.quantum_info.synthesis` module is deprecated and
  will be removed in Qiskit 1.0.0. The following objects have been moved to
  :mod:`qiskit.synthesis`:
  * :class:`~.OneQubitEulerDecomposer` has been moved to :mod:`qiskit.synthesis.one_qubit`
  * :class:`~.TwoQubitBasisDecomposer` has been moved to :mod:`qiskit.synthesis.two_qubits`
  * :class:`~.XXDecomposer` has been moved to :mod:`qiskit.synthesis.two_qubits`
  * :func:`~.two_qubit_cnot_decompose` has been moved to :mod:`qiskit.synthesis.two_qubits`
  The class :class:`.Quaternion` has been migrated from :mod:`qiskit.quantum_info.synthesis` to
  :mod:`qiskit.quantum_info`. This move has not affected the usual import path of the class,
  but accessing it via the :mod:`qiskit.quantum_info.synthesis` is now deprecated.
  This function is deprecated and will be removed in Qiskit 1.0.0:
  * :func:`~.cnot_rxx_decompose`

<span id="qiskit.synthesis"></span>
## Changes to `qiskit.synthesis`

<span id="qiskit.test"></span>
## Changes to `qiskit.test`

The module ``qiskit.test`` is deprecated. This module contains tooling and helpers for internal
  Qiskit testing, and most of its functionality had been moved or is not used in Qiskit anymore.
  In practice, the module was never meant to be used externally. If any of the code in the module
  is absolutely necessary beyond Qiskit, consider copying that code out into your own test infrastructure.

<span id="qiskit.tools"></span>
## Changes to `qiskit.tools`

The ``qiskit.tools`` module has been deprecated and will be removed in
  Qiskit 1.0.0. Except as noted in the release notes above for specific
  submodules (``qiskit.tools.jupyter``, ``qiskit.tools.monitor``, ``qiskit.tools.events`` and
  ``qiskit.tools.visualization``) the functionality in this module have
  been migrated to :mod:`qiskit.utils`. If you're using any functionality
  in this module you can update your imports from ``qiskit.tools`` to
  :mod:`qiskit.utils`.

* The ``qiskit.tools.jupyter`` module has been deprecated and will be removed
  in Qiskit 1.0.0. This module is deprecated because the functionality in
  this module is tied to the legacy ``qiskit-ibmq-provider`` package which is
  no longer supported and also only supported :class:`.BackendV1`. If you're
  using this functionality currently, similar jupyter tools exist in the
  `qiskit-ibm-provider <https://github.com/Qiskit/qiskit-ibm-provider>`__
  package which can be used instead. The documentation for this module can
  be found here:
  https://docs.quantum.ibm.com/api/qiskit-ibm-provider/ibm_jupyter

*  The ``qiskit.tools.monitor`` module has been deprecated and will be removed
  in Qiskit 1.0.0. This module is deprecated because the functionality in
  this module is tied to the legacy ``qiskit-ibmq-provider`` package which is
  no longer supported and also only supported :class:`.BackendV1`.

*   The ``qiskit.tools.visualization`` module has been deprecated and will be
  removed in Qiskit 1.0.0. This module was a legacy redirect from the original
  location of Qiskit's visualization module and was moved to
  :mod:`qiskit.visualization` in Qiskit 0.8.0. If you're still using this
  path you can just update your imports from ``qiskit.tools.visualization``
  to :mod:`qiskit.visualization`.

*   The ``qiskit.tools.events`` module and the :func:`.progressbar` utility
  it exposed has been deprecated and will be removed in the Qiskit 1.0.0
  release. This module's functionality was not widely used and better covered
  by dedicated packages such as `tqdm <https://github.com/tqdm/tqdm>`__.

<span id="qiskit.transpiler"></span>
## Changes to `qiskit.transpiler`

* The :mod:`qiskit.transpiler.synthesis` module is deprecated and
  will be removed in Qiskit 1.0. The following objects have been moved:
  * :mod:`qiskit.transpiler.synthesis.aqc` has been moved to :mod:`qiskit.synthesis.unitary.aqc`
  (except of :class:`qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin`).
  * :class:`qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin` has been moved to
  :class:`qiskit.transpiler.passes.synthesis.AQCSynthesisPlugin`.
  * :func:`qiskit.transpiler.synthesis.graysynth` has been moved to
  :func:`qiskit.synthesis.synth_cnot_phase_aam`.
  * :func:`qiskit.transpiler.synthesis.cnot_synth` has been moved to
  :func:`qiskit.synthesis.synth_cnot_count_full_pmh`.

*  The :class:`.NoiseAdaptiveLayout` transpiler pass and the corresponding
  ``"noise_adaptive"`` layout stage plugin have been deprecated and will
  be removed in the 1.0.0 release. This pass has been largely superseded by
  :class:`.VF2Layout` and :class:`.VF2PostLayout` which will set a layout
  based on the reported noise characteristics of a backend.

*  The :class:`.CrosstalkAdaptiveSchedule` transpiler pass has been deprecated
  and will be removed in the 1.0.0 release. This pass was not usable any
  longer because its internal operation was dependent on custom properties
  being set in the :class:`.BackendProperties` payload of a
  :class:`.BackendV1` instance. As no backends are setting these fields
  the pass has been deprecated.

<span id="qiskit.utils"></span>
## Changes to `qiskit.utils`

* The following tools in :mod:`qiskit.utils` have been deprecated:
  * Utils in ``qiskit.utils.arithmetic``
  * Utils in ``qiskit.utils.circuit_utils``
  * Utils in ``qiskit.utils.entangler_map``
  * Utils in ``qiskit.utils.name_unnamed_args``
  These functions were used exclusively in the context of ``qiskit.algorithms`` and
  ``qiskit.opflow``, and will be removed following the removals of
  ``qiskit.algorithms`` and  ``qiskit.opflow`` in Qiskit 1.0.

<span id="qiskit.visualization"></span>
## Changes to `qiskit.visualization`

*   The :mod:`qiskit.visualization.qcstyle` module is now deprecated and will be removed
  in the Qiskit 1.0.0 release. Instead you should use
  :mod:`qiskit.visualization.circuit.qcstyle` as direct replacement.

