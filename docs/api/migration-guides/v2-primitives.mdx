---
title: Migrate to using the V2 primitives
description: Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (EstimatorV2 and SamplerV2)

---

<span id="v2-primitives"></span>
# Migrate to using the V2 primitives

This guide describes what changed in the V2 primitives and why, describes each new primitive in detail, and gives examples to help you migrate code from using the legacy primitives to using the V2 primitives.  The examples in the guide all use the Qiskit Runtime primitives, but in general, the same changes apply to the other primitive implementations.  The functions unique to Qiskit Runtime such as error mitigation remain unique to Qiskit Runtime. 

## Overview

Version 2 is first the major interface change since the introduction of Qiskit Runtime primitives. Based on user feedback, this version introduces the following major new functions:

* A new interface that lets you specify a single circuit and multiple observables (if using Estimator) and parameter value sets for that circuit. Previously, you had to specify the  same circuit multiple times to match the size of the data to be combined.
* SamplerV2 no longer supports resilience levels (error mitigation).  Instead, it was simplified to focus on its core task of sampling the output register from running quantum circuits. As a result, it **no longer returns quasi-probabilities**. It returns the samples, whose type is defined by the program, without weights. The result class, however, has methods to return weighted samples, such as counts. 
* EstimatorV2 does not support resilience level 3.  This is because resilience level 3 in V1 Estimator uses Probabilistic Error Cancellation (PEC), which is proven to give unbiased results at the cost of exponential processing time. To make this trade-off more obvious, resilience level 3 support was removed from EstimatorV2. You can, however, still use PEC as the error mitigation method by using the `pec_mitigation` option.
* Both V2 primitives let you turn on or off individual error mitigation / suppression methods.

<Admonition type="note" title="Important:">
To ensure faster and more efficient results, as of 1 March 2024, circuits and observables need to be transformed to only use instructions supported by the system (referred to as *instruction set architecture (ISA)* circuits and observables) before being submitted to the Qiskit Runtime primitives.  See the [transpilation documentation](../transpile) for instructions to transform circuits.  Due to this change, the primitives will no longer perform layout or routing operations.  Consequently, transpilation options referring to those tasks will no longer have any effect. Users can still request that the primitives do no optimization of input circuits by specifying `optimization_level=0`.
</Admonition>

## Major changes

### Import

For backward compatibility, you must explicity import the V2 primitives. Specifying `import` *`prmitive`*`V2 as` *`primitive`* is not required, but makes it easier to transition code to V2. 

<Admonition type="note">
After the V1 primitives are deprecated, `import` *`prmitive`* will import the V2 version of the specified primitive.  
</Admonition>

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator
```
  </TabItem>
</Tabs>


### Input and output

#### Input

Both `SamplerV2` and `EstimatorV2` take one or more *primitive unified blocs* (PUBs) as the input. Each PUB is a tuple that contains **one** circuit and the data broadcasted to that circuit, which can be multiple observables and parameters.  Each PUB returns a result.

* SamplerV2 PUB format: (`<circuit>`, `<parameter values>`, `<shots>`)
* EstimatorV2 PUB format: (`<circuit>`, `<observables>`, `<parameter values>`, `<precision>`)
    Numpy [broadcasting rules](https://numpy.org/doc/stable/user/basics.broadcasting.html) are used when combining observables and parameter values.

#### Output

The output is now in the `PubResult` format.

* EstimatorV2 continues to return expectation values.
* SamplerV2 now returns per-shot measurements in the form of **bitstrings** or
   **counts**, instead of the quasi-probability distributions from the V1
   interface. The bitstrings show the measurement outcomes, preserving the shot
   order in which they were measured. 
* The V2 Sampler result objects organize data in terms of their **input circuits' classical register names**, for
   compatibility with dynamic circuits.  By default, the classical register name is `meas`, as shown in the following example.  When defining your circuit, if you create one or more classical registers with non-default name, you would use that name to get those results. 

       ```python
    # Define quantum circuit with 2 qubits
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.measure_all()
    circuit.draw()
    ```
    ```text
            ┌───┐      ░ ┌─┐
       q_0: ┤ H ├──■───░─┤M├───
            └───┘┌─┴─┐ ░ └╥┘┌─┐
       q_1: ─────┤ X ├─░──╫─┤M├
                 └───┘ ░  ║ └╥┘
    meas: 2/══════════════╩══╩═
                          0  1
    ```


#### Estimator examples    

<Tabs>
  <TabItem value="Estimator14" label="1 circuit, 4 observables">
    ```python 
    # Estimator V1: Execute 1 circuit with 4 observables 
    job = estimator_v1.run([circuit] * 4, [obs1, obs2, obs3, obs4])
    evs = job.result().values

    # Estimator V2: Execute 1 circuit with 4 observables 
    job = estimator_v2.run([(circuit, [obs1, obs2, obs3, obs4])])
    evs = job.result()[0].data.evs
```
  </TabItem>

  <TabItem value="Estimator142" label="1 circuit, 4 observables, 2 parameter sets">
    ```python 
    # Estimator V1: Execute 1 circuit with 4 observables and 2 parameter sets
    job = estimator_v1.run([circuit] * 8, [obs1, obs2, obs3, obs4] * 2, [vals1, vals2] * 4)
    evs = job.result().values

    # Estimator V2: Execute 1 circuit with 4 observables and 2 parameter sets
    job = estimator_v2.run([(circuit, [[obs1, obs2, obs3, obs4]], [[vals1], [vals2]])])
    evs = job.result()[0].data.evs
```
  </TabItem>

  <TabItem value="Estimator22" label="2 circuits, 2 observables">
    ```python 
    # Estimator V1: Cannot execute 2 circuits with different observables

    # Estimator V2: Execute 2 circuits with 2 different observables.  There are
    # two PUBs because each PUB can have only one circuit.
    job = estimator_v2.run([(circuit1, obs1), (circuit2, obs2)])
    evs1 = job.result()[0].data.evs  # result for pub 1 (circuit 1)
    evs2 = job.result()[1].data.evs  # result for pub 2 (circuit 2)
```
  </TabItem>
</Tabs>

#### Sampler examples    

<Tabs>
  <TabItem value="Sampler13" label="1 circuit, 3 parameter sets">
    ```python 
      # Sampler V1: Execute 1 circuit with 3 parameter sets 
      job = sampler_v1.run([circuit] * 3, [vals1, vals2, vals3])
      dists = job.result().quasi_dists

      # Sampler V2: Executing 1 circuit with 3 parameter sets
      job = sampler_v2.run([(circuit, [vals1, vals2, vals3])])
      counts = job.result()[0].data.meas.get_counts()
```
  </TabItem>

  <TabItem value="Sampler21" label="2 circuits, 1 parameter set">
    ```python 
    # Sampler V1: Execute 2 circuits with 1 parameter set
      job = sampler_v1.run([circuit1, circuit2], [vals1] * 2)
      dists = job.result().quasi_dists

      # Sampler V2: Execute 2 circuits with 1 parameter set
      job = sampler_v2.run([(circuit1, vals1), (circuit2, vals1)])
      counts1 = job.result()[0].data.meas.get_counts()  # result for pub 1 (circuit 1)
      counts2 = job.result()[1].data.meas.get_counts()  # result for pub 2 (circuit 2)
```
  </TabItem>
</Tabs>

### Options

`SamplerV2` and `EstimatorV2` now have separate options classes. You can see the available options and update option values during or after primitive initialization.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
from dataclasses import asdict
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# Setting options during primitive initialization
estimator = Estimator(backend, options={"resilience_level": 2})

# Setting options after primitive initialization
# This uses auto complete.
estimator.options.optimization_level = 1
estimator.options.execution.shots = 4000
# This does bulk update.
estimator.options.update(shots=4000, optimization_level=1)

# Print the dictionary format.
# Server defaults are used for unset options.
print(asdict(estimator.options))
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# Setting options during primitive initialization
options = Options()
# This uses auto complete.
options.resilience_level = 2 
estimator = Estimator(backend=backend, options=options)

# Setting options after primitive initialization.
# This does bulk update.
estimator.set_options(shots=4000, optimization_level=1)
```
  </TabItem>
</Tabs>

### Advanced options

Additional advanced options are available in V2 primitives. {/*See the API reference for the most up-to-date information on available options.*/}

For examples, see the [Error mitigation](#error-mit) and [Transpilation](#transpilation) sections. 

**Advanced options:**

{/*Need to verify which options actually make it into Sampler.  Possibly some of the last 5 will.*/}

| Category   | Option                   | Description                                                                                                                                                                                                                             | Default        | Notes          |
|------------|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|----------------|
|            | optimization_level       | How much optimization to perform on the circuits.                                                                                                                                                                                       | 1              |                |
|            | resilience_level         | How much resilience to build against errors.                                                                                                                                                                                            | 1              | Estimator only |
|            | dynamical_decoupling     | The dynamical decoupling sequence to use.                                                                                                                                                                                               | None           |                |
|            | seed_estimator           | Seed used to control sampling.                                                                                                                                                                                                          | None           | Estimator only |
| resilience | measure_noise_mitigation | Whether to enable measurement error mitigation method.                                                                                                                                                                                  | True           | Estimator only |
| resilience | zne_noise_factors        | An list of real valued noise factors that determine by what amount the circuits' noise is amplified.                                                                                                                                    |                | Estimator only |
| resilience | zne_extrapolator         | An extrapolation strategy. One or more of ``multi_exponential``,  ``single_exponential``, ``double_exponential``, ``linear``.                                                                                                           |                | Estimator only |
| resilience | zne_stderr_threshold     | A standard error threshold for accepting the ZNE result of Pauli basis expectation values when using ZNE mitigation.                                                                                                                    |                | Estimator only |
| resilience | pec_mitigation           | Whether to turn on the PEC error mitigation method.                                                                                                                                                                                     | False          | Estimator only |
| resilience | pec_max_overhead         | Specify a maximum sampling overhead for the PEC sampling noise model. If None the full learned model will be sampled from.                                                                                                              |                | Estimator only |
| execution  | shots                    | Number of repetitions of each circuit, for sampling.                                                                                                                                                                                    |                |                |
| execution  | init_qubits              | Whether to reset the qubits to the ground state for each shot.                                                                                                                                                                          | True           |                |
| execution  | samples                  | The number of samples of each measurement circuit to run. This is used when twirling or resilience levels 1, 2 is enabled. If None it will  be calculated automatically based on the ``shots`` and ``shots_per_sample`` (if specified). |                | Estimator only |
| execution  | shots_per_sample         | The number of shots per sample of each measurement  circuit to run. This is used when twirling or resilience levels 1, 2, 3.  If None it will be calculated automatically based on the ``shots`` and ``samples`` (if specified).        |                | Estimator only |
| execution  | interleave_samples       | If True interleave samples from different measurement circuits when running.                                                                                                                                                            | False          | Estimator only |
| twirling   | gates                    | Whether to apply 2-qubit gate twirling.                                                                                                                                                                                                 | False          | Estimator only |
| twirling   | measure                  | Whether to apply measurement twirling.                                                                                                                                                                                                  | True           | Estimator only |
| twirling   | strategy                 | Specify the strategy of twirling qubits in identified layers of  2-qubit twirled gates.                                                                                                                                                 | “active-accum" | Estimator only |


<span id="error-mit"></span>
### Error mitigation

* SamplerV2 does not support `resilience_level`. However, you can apply gate / measurement twirling to your circuits using the `dynamical_decoupling` and `twirling` methods.
* EstimatorV2 supports `resilience_level` 0-2, as described in the following table. You can also explicitly turn on / off individual error mitigation / suppression methods, including gate and measurement twirling, measurement error mitigation, and ZNE.

    | Level 1                   | Level 2                   |
    |---------------------------|---------------------------|
    | Measurement twirling      | Measurement twirling      |
    | Readout error mitigation  | Readout error mitigation  |
    |                           | Gate twirling             |
    |                           | ZNE                       |

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

estimator = Estimator(backend)
options = estimator.options
# Turn on gate twirling.
options.twirling.gates = True
# Turn on measurement error mitigation.
options.resilience.measure_noise_mitigation = True

print(f">>> gate twirling is turned on: {estimator.options.twirling.gates}")
print(f">>> measurement error mitigation is turned on: {estimator.options.resilience.measure_noise_mitigation}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator, Options

estimator = Estimator(backend, options=options)

options = Options()

options.resilience_level = 2
```
  </TabItem>
</Tabs>

{/* Delete these? Or waiting for updated code? */}

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
from qiskit_ibm_runtime import SamplerV2 as Sampler, Options

# Estimator and Sampler now have different options
options = sampler.options

# Twirling options
options.twirling.gates = True
options.twirling.measure = True

# ZNE options
options.resilience.zne_mitigation = True
options.resilience.zne_extrapolator = "exponential"
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
from qiskit_ibm_runtime import Sampler, Options

sampler = Sampler(backend, options=options)

options = Options()

options.resilience_level = 2

```
  </TabItem>
</Tabs>

<span id="transpilation"></span>
### Transpilation

V2 primitives support only ISA circuits. Because the primitives do not perform layout, routing, and translation operations, the corresponding transpilation options from V1 are not supported.  You can, however, still use `optimization_level` to indicate how much optimization the primitives should apply to the ISA circuits. The valid values are 0 and 1. 

Dynamical decoupling is no longer added for `optimization_level=1`. You can, however, enable it by using the `dynamical_decoupling` option.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit_ibm_runtime import EstimatorV2 as Estimator

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

estimator = Estimator(backend)
# Set optimization level to 0.
estimator.options.optimization_level = 0
# Turn on dynamical decoupling with sequence XpXm.
estimator.options.dynamical_decoupling = "XpXm"

print(f">>> optimization level to use: {estimator.options.optimization_level}")
print(f">>> dynamical decoupling sequence to use: {estimator.options.dynamical_decoupling}")
  ```  
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp
 
service = QiskitRuntimeService()
backend = service.backend("ibmq_qasm_simulator")
options = Options(optimization_level=1)
 
estimator = Estimator (options=options, backend=backend)
``` 
  </TabItem>
</Tabs>


## Estimator full examples

### Run a single experiment

Use Estimator to determine the expectation value of a single circuit-observable pair.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from QiskitRuntimeService import EstimatorV2 as Estimator, QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.get_backend("ibm_brisbane")
estimator = Estimator(backend)

n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * n_qubits)

job = estimator.run([(circuit, observable)])
result = job.result()
 
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
  ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * n_qubits)
 
estimator = Estimator(backend)
job = estimator.run(circuit, observable)
result = job.result()
 
print(f" > Observable: {observable.paulis}")
print(f" > Expectation value: {result.values}")
print(f" > Metadata: {result.metadata}")
```    
  </TabItem>
</Tabs>

### Run multiple experiments in a single job

Use Estimator to determine the expectation values of multiple circuit-observable pairs.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
  ```  
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
observables = [
    SparsePauliOp("X" * n_qubits),
    SparsePauliOp("Y" * n_qubits),
    SparsePauliOp("Z" * n_qubits),
]
 
estimator = Estimator(backend)
job = estimator.run(circuits, observables)
result = job.result()
 
print(f" > Expectation values: {result.values}")  
  ```  
  </TabItem>
</Tabs>

### Run parameterized circuits

{/* This one has been updated from the most recent version of the boxnote. */}

Use Estimator to run multiple experiments in a single job, leveraging parameter values to increase circuit reusability. In the following example, notice that steps 1 and 2 are the same for V1 and V2. 

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
import numpy as np

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService

# Step 1: Map classical inputs to a quantum problem

theta = Parameter("θ")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)

number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
individual_phases = [[ph] for ph in phases]

ZZ = SparsePauliOp.from_list([("ZZ", 1)])
ZX = SparsePauliOp.from_list([("ZX", 1)])
XZ = SparsePauliOp.from_list([("XZ", 1)])
XX = SparsePauliOp.from_list([("XX", 1)])
ops = [ZZ, ZX, XZ, XX]

# Step 2: Optimize problem for quantum execution.

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
chsh_isa_circuit = pm.run(chsh_circuit)
isa_observables = [operator.apply_layout(chsh_isa_circuit.layout) for operator in ops]

from qiskit_ibm_runtime import EstimatorV2 as Estimator

# Step 3: Execute using Qiskit Primitives.

# Reshape observable array for broadcasting
reshaped_ops = np.fromiter(isa_observables, dtype=object)
reshaped_ops = reshaped_ops.reshape((4, 1))

estimator = Estimator(backend, options={"shots": int(1e4)})
job = estimator.run([(chsh_isa_circuit, reshaped_ops, individual_phases)])
# Get results for the first (and only) PUB
pub_result = job.result()[0]
print(f">>> Expectation values: {pub_result.data.evs}")
print(f">>> Standard errors: {pub_result.data.stds}")
print(f">>> Metadta: {pub_result.metadata}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
  ```python
import numpy as np

from qiskit.circuit import QuantumCircuit, Parameter
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService

# Step 1: Map classical inputs to a quantum problem

theta = Parameter("θ")

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)

number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
individual_phases = [[ph] for ph in phases]

ZZ = SparsePauliOp.from_list([("ZZ", 1)])
ZX = SparsePauliOp.from_list([("ZX", 1)])
XZ = SparsePauliOp.from_list([("XZ", 1)])
XX = SparsePauliOp.from_list([("XX", 1)])
ops = [ZZ, ZX, XZ, XX]

# Step 2: Optimize problem for quantum execution.

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
chsh_isa_circuit = pm.run(chsh_circuit)
isa_observables = [operator.apply_layout(chsh_isa_circuit.layout) for operator in ops]

from qiskit_ibm_runtime import Estimator

# Step 3: Execute using Qiskit Primitives.
num_ops = len(isa_observables)

batch_circuits = [chsh_isa_circuit] * number_of_phases * num_ops
batch_ops = [op for op in isa_observables for _ in individual_phases]
batch_phases = individual_phases * num_ops

estimator = Estimator(backend, options={"shots": int(1e4)})
job = estimator.run(batch_circuits, batch_ops, batch_phases)
expvals = job.result().values
```    
  </TabItem>
</Tabs>

### Use sessions and advanced options

Explore sessions and advanced options to optimize circuit performance on quantum systems.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Session, EstimatorV2 as Estimator, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
observable = SparsePauliOp("X" * n_qubits)
another_observable = SparsePauliOp("Y" * n_qubits)
 
options = Options()
options.resilience_level = 2
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run([(circuit, observable)])
    another_job = estimator.run([(another_circuit, another_observable)])
    result = job.result()
    another_result = another_job.result()
 
# first job
print(f" > Expectation values job 1: {result[0].data.evs}")
 
# second job
print(f" > Expectation values job 2: {another_result[0].data.evs}")  
  ```  
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Session, Estimator, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
observable = SparsePauliOp("X" * n_qubits)
another_observable = SparsePauliOp("Y" * n_qubits)
 
options = Options()
options.optimization_level = 2
options.resilience_level = 2
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run(circuit, observable)
    another_job = estimator.run(another_circuit, another_observable)
    result = job.result()
    another_result = another_job.result()
 
# first job
print(f" > Expectation values job 1: {result.values}")
 
# second job
print(f" > Expectation values job 2: {another_result.values}")
```  
  </TabItem>
</Tabs>

## Sampler full examples

### Run a single experiment

Use Sampler to determine the counts or quasi-probability distribution of a single circuit.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)

job = sampler.run([(circuit)])
result = job.result()
 
print(f" > Counts: {result[0].data.meas.get_counts()}")
```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)
job = sampler.run(circuit)
result = job.result()
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
print(f" > Metadata: {result.metadata}")   
 ```   
  </TabItem>
</Tabs>

### Run multiple experiments in a single job

Use Sampler to determine the counts or quasi-probability distributions of multiple circuits in one job.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
for circuit in circuits:
    circuit.measure_all()
 
sampler = Sampler(backend) 
job = sampler.run([(circuits)])
result = job.result() 

print(f" > Counts: {result[0].data.meas.get_counts()}") 
  ```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler 
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
for circuit in circuits:
    circuit.measure_all()
 
sampler = Sampler(backend) 
job = sampler.run(circuits) 
result = job.result() 
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
```  
  </TabItem>
</Tabs>

### Run parameterized circuits

Run several experiments in a single job, leveraging parameter values to increase circuit reusability.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
from qiskit_ibm_runtime import SamplerV2 as Sampler

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.measure_all()

number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
phases = phases.reshape(21, 1)

sampler = Sampler(backend, options={"shots": 100})
result = sampler.run((chsh_circuit, phases)).result()
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
  ```python
import numpy as np
from qiskit.circuit.library import RealAmplitudes
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
circuit = RealAmplitudes(num_qubits=127, reps=2)
circuit.measure_all()
# Define three sets of parameters for the circuit
rng = np.random.default_rng(1234)
parameter_values = [
    rng.uniform(-np.pi, np.pi, size=circuit.num_parameters) for _ in range(3)
]
 
sampler = Sampler(backend) 
job = sampler.run([circuit] * 3, parameter_values) 
result = job.result() 
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
```    
  </TabItem>
</Tabs>

### Use sessions and advanced options

Explore sessions and advanced options to optimize circuit performance on quantum systems.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler, Session, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
circuit.measure_all()
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
another_circuit.measure_all()
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session: 
    sampler = Sampler(session=session) 
    job = sampler.run([(circuit)]) 
    another_job = sampler.run([(another_circuit)]) 
    result = job.result()
    another_result = another_job.result() 
 
# first job 
print(f" > Counts for job 1: {result[0].data.meas.get_counts()}")
 
# second job 
print(f" > Counts for job 2: {another_result[0].data.meas.get_counts()}")
  ```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
circuit.measure_all()
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
another_circuit.measure_all()
 
options = Options() 
options.optimization_level = 2 
options.resilience_level = 0 
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session: 
    sampler = Sampler(session=session, options=options) 
    job = sampler.run(circuit) 
    another_job = sampler.run(another_circuit) 
    result = job.result()
    another_result = another_job.result() 
 
# first job 
print(f" > Quasi-probability distribution job 1: {result.quasi_dists}") 
 
# second job 
print(f" > Quasi-probability distribution job 2: {another_result.quasi_dists}")
```  
  </TabItem>
</Tabs>