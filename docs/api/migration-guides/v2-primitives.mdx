---
title: Migrate to using the V2 primitives
description: Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (EstimatorV2 and SamplerV2)

---

<span id="v2-primitives"></span>
# Migrate to using the V2 primitives

This guide describes what changed in the V2 primitives and why, describes each new primitive in detail, and gives examples to help you migrate code from using the legacy primitives to using the V2 primitives.  The examples in the guide all use the Qiskit Runtime primitives, but in general, the same changes apply to the other primitive implementations.  The functions unique to Qiskit Runtime such as error mitigation remain unique to Qiskit Runtime. 

## Overview

Version 2 is first the major interface change since the introduction of Qiskit Runtime primitives. Based on user feedback, this version introduces the following major new functions:

* A new interface that lets you specify a single circuit and multiple observables (if using Estimator) and parameter value sets for that circuit. Previously, you had to specify the  same circuit multiple times to match the size of the data to be combined.
* SamplerV2 no longer supports resilience levels (error mitigation).  Instead, it was simplified to focus on its core task of sampling the output register from running quantum circuits. As a result, it **no longer returns quasi-probabilities**. It returns the samples, whose type is defined by the program, without weights. The result class, however, has methods to return weighted samples, such as counts. 
* EstimatorV2 does not support resilience level 3.  This is because resilience level 3 in V1 Estimator uses Probabilistic Error Cancellation (PEC), which is proven to give unbiased results at the cost of exponential processing time. To make this trade-off more obvious, resilience level 3 support was removed from EstimatorV2. You can, however, still use PEC as the error mitigation method by using the `pec_mitigation` option.
* Both V2 primitives let you turn on or off individual error mitigation / suppression methods.

<Admonition type="note" title="Important:">
To ensure faster and more efficient results, as of 1 March 2024, circuits and observables need to be transformed to only use instructions supported by the system (referred to as *instruction set architecture (ISA)* circuits and observables) before being submitted to the Qiskit Runtime primitives.  See the [transpilation documentation](../transpile) for instructions to transform circuits.  Due to this change, the primitives will no longer perform layout or routing operations.  Consequently, transpilation options referring to those tasks will no longer have any effect. Users can still request that the primitives do no optimization of input circuits by specifying `optimization_level=0`.
</Admonition>

## Major changes

### Import

For backward compatibility, you must explicity import the V2 primitives. Specifying `import` *`prmitive`*`V2 as` *`primitive`* is not required, but makes it easier to transition code to V2. 

<Admonition type="note">
After the V1 primitives are deprecated, `import` *`prmitive`* will import the V2 version of the specified primitive.  
</Admonition>

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator
```
  </TabItem>
</Tabs>


### Input

Both `SamplerV2` and `EstimatorV2` take one or more *primitive unified blocs* (PUBs) as the input. Each PUB is a tuple that contains a single circuit and the data broadcasted to that circuit.

* SamplerV2 PUB format: (`<circuit>`, `<parameter values>`, `<shots>`)
* EstimatorV2 PUB format: (`<circuit>`, `<observables>`, `<parameter values>`, `<precision>`)
    Numpy [broadcasting rules](https://numpy.org/doc/stable/user/basics.broadcasting.html) are used when combining observables and parameter values.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * 127)
 
job = estimatorv2.run([(circuit, observable)])
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * 127)

job = estimator.run(circuit, observable)
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
samplerv2 = Samplerv2(backend)
job = samplerv2.run(circuit)
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)
job = sampler.run([(circuit)])
```
  </TabItem>
</Tabs>


### Output

The output is now in the `PubResult` format.

* EstimatorV2 continues to return expectation values.
* SamplerV2 now returns per-shot measurements as a bitstring.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
result = job.result()
 
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
result = job.result()

print(f" > Observable: {observable.paulis}")
print(f" > Expectation value: {result.values}")
print(f" > Metadata: {result.metadata}")
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
result = job.result()

print(f">>> Counts: {result[0].data.get_counts()}")
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
result = job.result()
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
print(f" > Metadata: {result.metadata}")
```
  </TabItem>
</Tabs>

### Error mitigation

* SamplerV2 does not support `resilience_level`. However, you can apply gate / measurement twirling to your circuits using the `dynamical_decoupling` and `twirling`
* EstimatorV2 supports `resilience_level` 0-2, as described in the following table. You can also explicitly turn on / off individual error mitigation / suppression methods, including gate and measurement twirling, measurement error mitigation, and ZNE.

    | Level 1                   | Level 2                   |
    |---------------------------|---------------------------|
    | Measurement twirling      | Measurement twirling      |
    | Readout error mitigation  | Readout error mitigation  |
    |                           | Gate twirling             |
    |                           | ZNE                       |

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator, Options

estimator = Estimator(backend, options=options)

# Estimator and Sampler now have different options
options = estimator.options

options.resilience_level = 2
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator, Options

estimator = Estimator(backend, options=options)

options = Options()

options.resilience_level = 2
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
from qiskit_ibm_runtime import SamplerV2 as Sampler, Options

# Estimator and Sampler now have different options
options = sampler.options

# Twirling options
options.twirling.gates = True
options.twirling.measure = True

# ZNE options
options.resilience.zne_mitigation = True
options.resilience.zne_extrapolator = "exponential"
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
from qiskit_ibm_runtime import Sampler, Options

sampler = Sampler(backend, options=options)

options = Options()

options.resilience_level = 2

```
  </TabItem>
</Tabs>

### Transpilation

V2 primitives do not support transpilation.  Therefore, no transpilation-related options are supported, including `optimization_level`, `dynamical_decoupling`,  `initial_layout`, `layout_method`, `routing_method`, and `approximation_degree`. Instead, the circuit and observable need to be transformed to only use instructions supported by the system (referred to as *instruction set architecture (ISA)* circuits) by using the transpiler before they are submitted to the primitive. 

## Estimator full examples

### Run a single experiment

Use Estimator to determine the expectation value of a single circuit-observable pair.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from QiskitRuntimeService import EstimatorV2 as Estimator, QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.get_backend("ibm_brisbane")
estimator = Estimator(backend)

n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * n_qubits)

job = estimator.run([(circuit, observable)])
result = job.result()
 
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
  ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * n_qubits)
 
estimator = Estimator(backend)
job = estimator.run(circuit, observable)
result = job.result()
 
print(f" > Observable: {observable.paulis}")
print(f" > Expectation value: {result.values}")
print(f" > Metadata: {result.metadata}")
```    
  </TabItem>
</Tabs>

### Run multiple experiments in a single job

Use Estimator to determine the expectation values of multiple circuit-observable pairs.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
  ```  
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
observables = [
    SparsePauliOp("X" * n_qubits),
    SparsePauliOp("Y" * n_qubits),
    SparsePauliOp("Z" * n_qubits),
]
 
estimator = Estimator(backend)
job = estimator.run(circuits, observables)
result = job.result()
 
print(f" > Expectation values: {result.values}")  
  ```  
  </TabItem>
</Tabs>

### Run parameterized circuits

Use Estimator to run multiple experiments in a single job, leveraging parameter values to increase circuit reusability.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator

estimator = Estimator(backend, options={"shots": int(1e4)})

from qiskit_ibm_runtime.qiskit.primitives import ObservablesArray

# Reshape observables to (4, 1)
obs_array = ObservablesArray(ops)
obs_array = obs_array.reshape((num_ops, 1))

result = (
    estimatorv2.run(
        pubs=(chsh_circuit_no_meas, obs_array, individual_phases)
    )
    .result()
)
print(f">>> Number of PubResult: {len(result)}")
print(f">>> Shape of the frist pub result data: {result[0].data['evs'].shape}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
  ```python
# General
import numpy as np

# Qiskit imports
from qiskit import QuantumCircuit
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp

# Runtime imports
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator

# Create a parameterized CHSH circuit

theta = Parameter("θ")

chsh_circuit_no_meas = QuantumCircuit(2)
chsh_circuit_no_meas.h(0)
chsh_circuit_no_meas.cx(0, 1)
chsh_circuit_no_meas.ry(theta, 0)

# Create a list of phase values to be assigned later

number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
# Phases need to be expressed as list of lists in order to work
individual_phases = [[ph] for ph in phases]

# Create observables

ZZ = SparsePauliOp.from_list([("ZZ", 1)])
ZX = SparsePauliOp.from_list([("ZX", 1)])
XZ = SparsePauliOp.from_list([("XZ", 1)])
XX = SparsePauliOp.from_list([("XX", 1)])

ops = [ZZ, ZX, XZ, XX]
num_ops = len(ops)

# Repeat the inputs so they all have the same length

batch_circuits = [chsh_circuit_no_meas] * number_of_phases * num_ops
batch_ops = [op for op in ops for _ in individual_phases]
batch_phases = individual_phases * num_ops

print(f"All 3 arrays have the same length of {len(batch_circuits)}: {len(batch_circuits) == len(batch_ops) == len(batch_phases)}")

service = QiskitRuntimeService()
backend = service.get_backend("ibmq_qasm_simulator")
estimator = Estimator(backend, options={"shots": int(1e4)})

batch_expvals = (
    estimator.run(
        batch_circuits, batch_ops, batch_phases
    )
    .result()
    .values
)
print(len(batch_expvals))
```    
  </TabItem>
</Tabs>

### Use sessions and advanced options

Explore sessions and advanced options to optimize circuit performance on quantum systems.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Session, EstimatorV2 as Estimator, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
observable = SparsePauliOp("X" * n_qubits)
another_observable = SparsePauliOp("Y" * n_qubits)
 
options = Options()
options.resilience_level = 2
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run([(circuit, observable)])
    another_job = estimator.run([(another_circuit, another_observable)])
    result = job.result()
    another_result = another_job.result()
 
# first job
print(f" > Expectation values job 1: {result[0].data.evs}")
 
# second job
print(f" > Expectation values job 2: {another_result[0].data.evs}")  
  ```  
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import SparsePauliOp, random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Session, Estimator, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
observable = SparsePauliOp("X" * n_qubits)
another_observable = SparsePauliOp("Y" * n_qubits)
 
options = Options()
options.optimization_level = 2
options.resilience_level = 2
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session:
    estimator = Estimator(session=session, options=options)
    job = estimator.run(circuit, observable)
    another_job = estimator.run(another_circuit, another_observable)
    result = job.result()
    another_result = another_job.result()
 
# first job
print(f" > Expectation values job 1: {result.values}")
 
# second job
print(f" > Expectation values job 2: {another_result.values}")
```  
  </TabItem>
</Tabs>

## Sampler full examples

### Run a single experiment

Use Sampler to determine the counts or quasi-probability distribution of a single circuit.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)

job = sampler.run([(circuit)])
result = job.result()
 
print(f" > Counts: {result[0].data.meas.get_counts()}")
```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
mat = np.real(random_hermitian(n_qubits, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)
job = sampler.run(circuit)
result = job.result()
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
print(f" > Metadata: {result.metadata}")   
 ```   
  </TabItem>
</Tabs>

### Run multiple experiments in a single job

Use Sampler to determine the counts or quasi-probability distributions of multiple circuits in one job.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
for circuit in circuits:
    circuit.measure_all()
 
sampler = Sampler(backend) 
job = sampler.run([(circuits)])
result = job.result() 

print(f" > Counts: {result[0].data.meas.get_counts()}") 
  ```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler 
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
n_qubits = 127
 
rng = np.random.default_rng()
mats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]
circuits = [IQP(mat) for mat in mats]
for circuit in circuits:
    circuit.measure_all()
 
sampler = Sampler(backend) 
job = sampler.run(circuits) 
result = job.result() 
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
```  
  </TabItem>
</Tabs>

### Run parameterized circuits

Run several experiments in a single job, leveraging parameter values to increase circuit reusability.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
from qiskit_ibm_runtime import SamplerV2 as Sampler

chsh_circuit = QuantumCircuit(2)
chsh_circuit.h(0)
chsh_circuit.cx(0, 1)
chsh_circuit.ry(theta, 0)
chsh_circuit.measure_all()

number_of_phases = 21
phases = np.linspace(0, 2 * np.pi, number_of_phases)
phases = phases.reshape(21, 1)

sampler = Sampler(backend, options={"shots": 100})
result = sampler.run((chsh_circuit, phases)).result()
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
  ```python
import numpy as np
from qiskit.circuit.library import RealAmplitudes
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
circuit = RealAmplitudes(num_qubits=127, reps=2)
circuit.measure_all()
# Define three sets of parameters for the circuit
rng = np.random.default_rng(1234)
parameter_values = [
    rng.uniform(-np.pi, np.pi, size=circuit.num_parameters) for _ in range(3)
]
 
sampler = Sampler(backend) 
job = sampler.run([circuit] * 3, parameter_values) 
result = job.result() 
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
```    
  </TabItem>
</Tabs>

### Use sessions and advanced options

Explore sessions and advanced options to optimize circuit performance on quantum systems.

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler, Session, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
circuit.measure_all()
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
another_circuit.measure_all()
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session: 
    sampler = Sampler(session=session) 
    job = sampler.run([(circuit)]) 
    another_job = sampler.run([(another_circuit)]) 
    result = job.result()
    another_result = another_job.result() 
 
# first job 
print(f" > Counts for job 1: {result[0].data.meas.get_counts()}")
 
# second job 
print(f" > Counts for job 2: {another_result[0].data.meas.get_counts()}")
  ```  
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python
import numpy as np
from qiskit.circuit.library import IQP
from qiskit.quantum_info import random_hermitian
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session, Options
 
n_qubits = 127
 
rng = np.random.default_rng(1234)
mat = np.real(random_hermitian(n_qubits, seed=rng))
circuit = IQP(mat)
circuit.measure_all()
mat = np.real(random_hermitian(n_qubits, seed=rng))
another_circuit = IQP(mat)
another_circuit.measure_all()
 
options = Options() 
options.optimization_level = 2 
options.resilience_level = 0 
 
service = QiskitRuntimeService()
 
backend = service.get_backend("ibm_brisbane")
 
with Session(service=service, backend=backend) as session: 
    sampler = Sampler(session=session, options=options) 
    job = sampler.run(circuit) 
    another_job = sampler.run(another_circuit) 
    result = job.result()
    another_result = another_job.result() 
 
# first job 
print(f" > Quasi-probability distribution job 1: {result.quasi_dists}") 
 
# second job 
print(f" > Quasi-probability distribution job 2: {another_result.quasi_dists}")
```  
  </TabItem>
</Tabs>