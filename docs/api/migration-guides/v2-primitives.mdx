---
title: Migrate to using the V2 primitives
description: Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (EstimatorV2 and SamplerV2)

---

<span id="v2-primitives"></span>
# Migrate to using the V2 primitives

This guide describes what changed in the V2 primitives and why, describes each new primitive in detail, and gives examples to help you migrate code from using the legacy primitives to using the V2 primitives.  The examples in the guide all use the Qiskit Runtime primitives, but, in general, the same changes apply to the other primitive implementations.  The functions unique to Qiskit Runtime such as error mitigation remain unique to Qiskit Runtime. 

## Overview

Version 2 is first the major interface change since the introduction of Qiskit Runtime primitives. Based on user feedback, this version introduces the following major new functions:

* A new interface that lets you specify a single circuit and multiple observables (if using Estimator) and parameter value sets for that circuit. Previously, you had to specify the  same circuit multiple times to match the size of the data to be combined.
* SamplerV2 no longer supports resilience levels.  Instead, it was simplified to focus on its core task of sampling the output register from running quantum circuits. It returns the samples, whose type is defined by the program, without weights. The result class, however, has methods to return weighted samples, such as counts and quasi-probabilities. 
* EstimatorV2 does not support resilience level 3.  This is because resilience level 3 in V1 Estimator uses PEC, which is proven to give unbiased results at the cost of exponential processing time. To make this trade-off more obvious, resilience level 3 support was removed from EstimatorV2. You can, however, still use PEC as the error mitigation method by using the `pec_mitigation` option.
* Both V2 primitives let you turn on or off individual error mitigation / suppression methods.
* To reduce the total execution time, V2 primitives support only lightweight transpilation. You can use the [Qiskit transpiler](../../run/advanced-runtime-options#runtime-compilation) or the [AI-driven transpilation service](../../transpile/qiskit-transpiler-service) (premium users).

## Major changes

### Import

For backward compatibility, you must explicity import the V2 primitives. Specifying `import` *`prmitive`*`V2 as` *`primitive`* is not required, but makes it easier to transition code to V2. 

<Admonition type="note">
After the V1 primitives are deprecated, `import` *`prmitive`* will import the V2 version of the specified primitive.  
</Admonition>

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator
```
  </TabItem>
</Tabs>


### Input

Both `SamplerV2` and `EstimatorV2` take one or more *primitive unified blocs* (PUBs) as the input. Each PUB is a tuple that contains a single circuit and the data broadcasted to that circuit.

* SamplerV2 PUB format: (`<circuit>`, `<parameter values>`, `<shots>`)
* EstimatorV2 PUB format: (`<circuit>`, `<observables>`, `<parameter values>`, `<precision>`)
    Numpy [broadcasting rules](https://numpy.org/doc/stable/user/basics.broadcasting.html) are used when combining observables and parameter values.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * 127)
 
job = estimator.run([(circuit, observable)])
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
observable = SparsePauliOp("Z" * 127)

job = estimator.run(circuit, observable)
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)
job = sampler.run(circuit)
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
mat = np.real(random_hermitian(127, seed=1234))
circuit = IQP(mat)
circuit.measure_all()
 
sampler = Sampler(backend)
job = sampler.run([(circuit)])
```
  </TabItem>
</Tabs>


### Output

The output is now in the `PubResult` format.

* EstimatorV2 continues to return expectation values.
* SamplerV2 now returns per-shot measurements as a bitstring.

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
result = job.result()
 
print(f" > Expectation value: {result[0].data.evs}")
print(f" > Metadata: {result[0].metadata}")
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
result = job.result()

print(f" > Observable: {observable.paulis}")
print(f" > Expectation value: {result.values}")
print(f" > Metadata: {result.metadata}")
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
result = job.result()

print(f">>> Counts: {result[0].data.get_counts()}")
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
result = job.result()
 
print(f" > Quasi-probability distribution: {result.quasi_dists}")
print(f" > Metadata: {result.metadata}")
```
  </TabItem>
</Tabs>

### Error mitigation

* SamplerV2 no longer supports `resilience_level`. You can, however, apply dynamical decoupling and gate / measurement twirling to your circuits using the `dynamical_decoupling` and `twirling`
* EstimatorV2 now supports `resilience_level` 0-2, as described in the following table. You can also explicitly turn on / off individual error mitigation / suppression methods, including dynamical decoupling, gate and measurement twirling, measurement error mitigation, and ZNE.

    | Level 1                   | Level 2                   |
    |---------------------------|---------------------------|
    | Measurement twirling      | Measurement twirling      |
    | Readout error mitigation  | Readout error mitigation  |
    |                           | Gate twirling             |
    |                           | ZNE                       |

<Tabs>
  <TabItem value="EstimatorV2" label="EstimatorV2">
    ```python 
from qiskit_ibm_runtime import EstimatorV2 as Estimator, Options

estimator = Estimator(backend, options=options)

# Estimator and Sampler now have different options
options = estimator.options

options.resilience_level = 2
options.optimization_level = 1
```
  </TabItem>

  <TabItem value="EstimatorV1" label="Estimator (V1)">
    ```python 
from qiskit_ibm_runtime import Estimator, Options

estimator = Estimator(backend, options=options)

options = Options()

options.optimization_level = 1
options.resilience_level = 2
```
  </TabItem>
</Tabs>

<Tabs>
  <TabItem value="SamplerV2" label="SamplerV2">
    ```python 
from qiskit_ibm_runtime import SamplerV2 as Sampler, Options

# Estimator and Sampler now have different options
options = sampler.options

options.optimization_level = 1

# Twirling options
options.twirling.gates = True
options.twirling.measure = True

# DD sequence
options.dynamical_decoupling = "XX"

# ZNE options
options.resilience.zne_mitigation = True
options.resilience.zne_extrapolator = "exponential"
```
  </TabItem>

  <TabItem value="SamplerV1" label="Sampler (V1)">
    ```python 
from qiskit_ibm_runtime import Sampler, Options

sampler = Sampler(backend, options=options)

options = Options()

options.optimization_level = 1
options.resilience_level = 2

```
  </TabItem>
</Tabs>

### Transpilation

V2 primitives support only lightweight transpilation, which has the following implications:

* Both primitives support only `optimization_level` 0 and 1. 
* Dynamical decoupling is no longer added by default for `optimization_level` > 0. You can, however, enable it by using the `dynamical_decoupling` option.
* These transpilation options are no longer supported: `initial_layout`, `layout_method`, `routing_method`, and `approximation_degree`.

## Full examples

CAN WE REDO THE EXAMPLES FROM https://docs.quantum.ibm.com/run/primitives-examples ? 

Estimator examples
* Run a single experiment
* Run multiple experiments in a single job
* Run parameterized circuits
* Use sessions and advanced options

Sampler examples
* Run a single experiment
* Run multiple experiments in a single job
* Run parameterized circuits
* Use sessions and advanced options