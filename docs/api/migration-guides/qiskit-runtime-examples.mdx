---
title: End-to-end examples
description: Examples of migrating from using backend.run to using Qiskit Runtime primitives

---

# End-to-end examples

Follow these examples to design a Qiskit Runtime algorithm.

<span id="estimator-algorithm"></span>
## Use Estimator to design an algorithm

The Estimator primitive is used to design an algorithm that calculates
expectation values.

### Background

The role of the `Estimator` primitive is two-fold: it acts as an **entry point** to quantum devices or simulators, replacing the `Backend`
interface (commonly referred to as `backend.run()`). Additionally, it is
an **algorithmic abstraction** for expectation value calculations, so
you don't have to manually construct the final expectation circuit.
This results in a considerable reduction of the code complexity and a
more compact algorithm design.

**Backend.run() model:** In this model, you accessed real systems and remote simulators using the `qiskit-ibmq-provider` module (now migrated to `qiskit-ibm-provider`). To run **local** simulations, you could import a specific simulator from `qiskit-aer`. All of them followed the `backend.run()` interface.

<Tabs>
  <TabItem value="provider" label="qiskit-ibmq-provider">
``` python
from qiskit import IBMQ

# Select provider
provider = IBMQ.get_provider(hub="ibm-q", group="open", project="main")

# Get backend
backend = provider.get_backend("ibmq_qasm_simulator") # cloud simulator

# Run
result = backend.run(expectation_circuits)
```
  </TabItem>

  <TabItem value="aer" label="qiskit-aer">
``` python
from qiskit_aer import AerSimulator # former import: from qiskit import Aer

# Get local simulator backend
backend = AerSimulator()

# Run
result = backend.run(expectation_circuits)
```
  </TabItem>
</Tabs>

**Primitives model:** Access real systems and remote simulators through the `qiskit-ibm-runtime` **primitives** (`Sampler` and `Estimator`). Use **Local testing mode** to run local simulations on Qiskit Runtime fake backends or Aer simulators. The following examples assume you have defined circuits `isa_circuits` and observables `isa_observables`.

<Tabs>
  <TabItem value="hw" label="Run on quantum systems">
``` python
from qiskit_ibm_runtime import EstimatorV2 as Estimator, QiskitRuntimeService

# Define the service.  This allows you to access IBM Quantum systems.
service = QiskitRuntimeService()

# Get a backend
backend = service.least_busy(operational=True, simulator=False)

# Define Estimator  
estimator = Estimator(backend)

# Run an expectation value calculation
job = estimator.run([(isa_circuits, isa_observables)])
result = job.result()
```
  </TabItem>

  <TabItem value="local" label="Run in local testing mode">
``` python
from qiskit_ibm_runtime import EstimatorV2 as Estimator
from qiskit_ibm_runtime.fake_provider import FakeManilaV2

# Run the sampler job locally using FakeManilaV2
fake_manila = FakeManilaV2()

# You can use a fixed seed to get fixed results. 
options = {"simulator": {"seed_simulator": 42}}

# Define Estimator  
estimator = Estimator(backend=fake_manila, options=options)

# Run an expectation value calculation
job = estimator.run([(isa_circuits, isa_observables)])
result = job.result()
```
  </TabItem>
</Tabs>

<span id="estimator-example"></span>
### End-to-end example

If your code previously calculated expectation values using
`backend.run()`, you most likely used the `qiskit.opflow` module to
handle operators and state functions. To support this scenario, the
following migration example shows how to replace the (`qiskit.opflow` & `backend.run()`) workflow with an Estimator-based workflow.

#### 1. Problem definition

We want to compute the expectation value of a quantum state (circuit)
with respect to a certain operator. In this example, we are using the H2
molecule and an arbitrary circuit as the quantum state:

<Tabs>
  <TabItem value="PrimV2" label="Runtime Estimator">
For Qiskit Runtime, circuits and parameters must obey the Instruction Set Architecture (ISA) of a particular backend.

``` python
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp

# Step 1: Define operator
op = SparsePauliOp.from_list(
    [
        ("II", -1.052373245772859),
        ("IZ", 0.39793742484318045),
        ("ZI", -0.39793742484318045),
        ("ZZ", -0.01128010425623538),
        ("XX", 0.18093119978423156),
    ]
)

# Step 2: Define quantum state
state = QuantumCircuit(2)
state.x(0)
state.x(1)

# Define the backend
from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# Convert inputs to ISA
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_state = pm.run(state)
isa_observables = [operator.apply_layout(isa_state.layout) for operator in op]

```
  </TabItem>

  <TabItem value="PrimV1" label="backend.run">
``` python
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp

# Step 1: Define operator
op = SparsePauliOp.from_list(
    [
        ("II", -1.052373245772859),
        ("IZ", 0.39793742484318045),
        ("ZI", -0.39793742484318045),
        ("ZZ", -0.01128010425623538),
        ("XX", 0.18093119978423156),
    ]
)

# Step 2: Define quantum state
state = QuantumCircuit(2)
state.x(0)
state.x(1)
```
  </TabItem>
</Tabs>


<span id="legacy-opflow"></span>
##### 1.a. Legacy only: Convert problem to opflow

`qiskit.opflow` provided its own classes to represent both operators
and quantum states, so the problem defined above would be wrapped as:

``` python
from qiskit.opflow import CircuitStateFn, PauliSumOp

opflow_op = PauliSumOp(op)
opflow_state = CircuitStateFn(state)
```

This step is not necessary when using the primitives. For instructions to migrate from `qiskit.opflow`, see the [Opflow migration guide](./qiskit-opflow-module).

#### 2. Calculate expectation values

<Tabs>
  <TabItem value="updated" label="Runtime Estimator">
Estimator simplifies the user-side syntax, making it a more
convenient tool for algorithm design.

``` python
from qiskit_ibm_runtime import EstimatorV2 as Estimator

estimator = Estimator(backend, options={"default_shots": int(1e4)})
job = estimator.run([(isa_state, isa_observables)])

# Get results for the first (and only) PUB
pub_result = job.result()[0]
```

Note that the Estimator returns a list of values, as it can perform batched evaluations.

``` python
>>> print(f">>> Expectation values: {pub_result.data.evs}")
>>> Expectation values: [-1.05237325 -0.20984981  0.37345495 -0.00564005 -0.00141352]
```
  </TabItem>

  <TabItem value="legacy" label="backend.run()">
The legacy workflow required many steps to compute an expectation value:

<Admonition type="note">
    Replace `ibmq_qasm_simulator` with your device name to see the complete workflow for a real device.
</Admonition>

``` python
from qiskit.opflow import StateFn, PauliExpectation, CircuitSampler
from qiskit import IBMQ

# Define the state to sample
measurable_expression = StateFn(opflow_op, is_measurement=True).compose(opflow_state)

# Convert to expectation value calculation object
expectation = PauliExpectation().convert(measurable_expression)

# Define provider and backend
provider = IBMQ.get_provider(hub="ibm-q", group="open", project="main")
backend = provider.get_backend("ibmq_qasm_simulator")

# Inject backend into circuit sampler
sampler = CircuitSampler(backend).convert(expectation)

# Evaluate
expectation_value = sampler.eval().real
```

``` python
>>> print("expectation: ", expectation_value)
expectation:  -1.065734058826613
```
  </TabItem>
</Tabs>


#### 3. Local execution 

This section describes how to use Qiskit Runtime to test an
algorithm locally. These examples solve the problem defined above with a local simulation.

<Tabs>
  <TabItem value="updated" label="Qiskit Runtime Local testing mode">
To use local testing mode, specify one of the fake backends from ``qiskit_ibm_runtime.fake_provider`` or specify a Qiskit Aer backend when instantiating a primitive or a session. 

- **Fake backends**: The [fake backends](../qiskit-ibm-runtime/fake_provider)  in ``qiskit_ibm_runtime.fake_provider`` mimic the behaviors of IBM Quantum&trade; systems by using system snapshots. The system snapshots contain important information about the quantum system, such as the coupling map, basis gates, and qubit properties, which are useful for testing the transpiler and performing noisy simulations of the system. The noise model from the snapshot is automatically applied during simulation. 
- **Aer simulator**: Simulators from [Qiskit Aer](../../verify/simulate-with-qiskit-aer) provide higher-performance simulation that can handle larger circuits and [custom noise models](../../verify/building_noise_models). It also supports Clifford simulation mode, which can efficiently simulate Clifford circuits with a large number of qubits.

The only part of the previous example that we need to change is the backend definition.  The rest of the code is identical.  However, some options and execution modes are ignored when using local testing mode and will generate warnings if included.  

``` python
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp

# Step 1: Define operator
op = SparsePauliOp.from_list(
    [
        ("II", -1.052373245772859),
        ("IZ", 0.39793742484318045),
        ("ZI", -0.39793742484318045),
        ("ZZ", -0.01128010425623538),
        ("XX", 0.18093119978423156),
    ]
)

# Step 2: Define quantum state
state = QuantumCircuit(2)
state.x(0)
state.x(1)

# Define a local backend
from qiskit_ibm_runtime.fake_provider import FakeManilaV2
backend = FakeManilaV2()

# You could use an Aer simulator instead by using the following code:
# from qiskit_aer import AerSimulator
# backend = AerSimulator()

# We don't need these lines when running in local testing mode:
# from qiskit_ibm_runtime import QiskitRuntimeService
# service = QiskitRuntimeService()


# Convert inputs to ISA
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_state = pm.run(state)
isa_observables = [operator.apply_layout(isa_state.layout) for operator in op]
```
  </TabItem>

  <TabItem value="PrimV1" label="backend.run">
``` python
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp

# Step 1: Define operator
op = SparsePauliOp.from_list(
    [
        ("II", -1.052373245772859),
        ("IZ", 0.39793742484318045),
        ("ZI", -0.39793742484318045),
        ("ZZ", -0.01128010425623538),
        ("XX", 0.18093119978423156),
    ]
)

# Step 2: Define quantum state
state = QuantumCircuit(2)
state.x(0)
state.x(1)
```

For information about running noisy simulations with the Runtime primitives, see [Noisy simulators in Qiskit Runtime](../../verify/using-ibm-quantum-simulators)  and [Local testing mode](../../verify/local-testing-mode).

  </TabItem>
  <TabItem value="legacy-aer" label="Qiskit Aer simulator">
``` python
from qiskit.opflow import StateFn, PauliExpectation, CircuitSampler
from qiskit_aer import AerSimulator

# Define the state to sample
measurable_expression = StateFn(opflow_op, is_measurement=True).compose(opflow_state)

# Convert to expectation value calculation object
expectation = PauliExpectation().convert(measurable_expression)

# Define statevector simulator
simulator = AerSimulator(method="statevector", shots=100)

# Inject backend into circuit sampler
circuit_sampler = CircuitSampler(simulator).convert(expectation)

# Evaluate
expectation_value = circuit_sampler.eval().real
```

``` python
>>> print("expectation: ", expectation_value)
expectation:  -1.0636533500290943
```  
  </TabItem>

  <TabItem value="legacy-primitive" label="Reference Estimator or Aer Estimator primitive">
The reference `Estimator` lets you perform either an exact or a
shot-based noisy simulation based on the `Statevector` class in the
`qiskit.quantum_info` module.

``` python
from qiskit.primitives import Estimator

estimator = Estimator()

expectation_value = estimator.run(state, op).result().values

# for shot-based simulation:
expectation_value = estimator.run(state, op, shots=100).result().values
```

``` python
>>> print("expectation: ", expectation_value)
expectation:  [-1.03134297]
```

You can still access the Aer Simulator through its dedicated
`Estimator`. This can be handy for performing simulations with noise
models. In this example, the simulation method has been updated to match
the Qiskit Aer simulator example result.

``` python
from qiskit_aer.primitives import Estimator # import change

estimator = Estimator(run_options= {"method": "statevector"})

expectation_value = estimator.run(state, op, shots=100).result().values
```

``` python
>>> print("expectation: ", expectation_value)
expectation:  [-1.06365335]
```
  </TabItem>
</Tabs>



<span id="sampler-algorithm"></span>
## Use Sampler to design an algorithm 

The Sampler primitive is used to design an algorithm that samples
circuits and extracts probability distributions.

### Background

The role of the `Sampler` primitive is two-fold: it acts as an **entry
point** to quantum devices or simulators, replacing `backend.run()`.
Additionally, it is an **algorithmic abstraction** to extract
probability distributions from measurement counts.

Both `Sampler` and `backend.run()` take in circuits as inputs. The main
difference is the format of the output: `backend.run()` outputs
**counts**, while `Sampler` processes those counts and outputs the **per-shot measurements** (in the form of bitstrings) associated with them.

**Backend.run() model:** In this model, you used the `qiskit-ibmq-provider` (now migrated to `qiskit-ibm-provider`) module to access real systems and remote simulators. To run **local** simulations, you could import a specific simulator from `qiskit-aer`. All of them followed the `backend.run()` interface.

    <details>
    <summary><a>Code example with `qiskit-ibmq-provider` and `backend.run()`</a></summary>

    ``` python
    from qiskit import IBMQ

    # Select provider
    provider = IBMQ.load_account()

    # Get backend
    backend = provider.get_backend("ibmq_qasm_simulator") # Use the cloud simulator

    # Run
    result = backend.run(circuits)
    ```
    </details>

    <details>
    <summary><a>Code example for `qiskit-aer` & `backend.run()` </a></summary>

    ``` python
    from qiskit_aer import AerSimulator # former import: from qiskit import Aer

    # Get local simulator backend
    backend = AerSimulator()

    # Run
    result = backend.run(circuits)
    ```
    </details>

    **Primitives model:** Access real systems and remote simulators through the `qiskit-ibm-runtime` Sampler and Estimator *primitives*. Use **local testing mode** to run local simulations by using Qiskit Runtime fake backends or Aer simulators.

    <details>
    <summary><a>Code example for Runtime Sampler</a></summary>

    ``` python
    from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

    # Define service
    service = QiskitRuntimeService()

    # Get backend
    backend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)

    # Define Sampler
    sampler = Sampler(backend=backend)

    # Run calculation
    job = sampler.run([(isa_circuit,)])
    result = job.result()
    ```
    </details>

<span id="sampler-example"></span>
## End-to-end example

The following example shows an end-to-end example of sampling a circuit by using `backend.run()` and `Sampler`.

### 1. Problem definition

We want to find the probability distribution
associated with a quantum state:

<Admonition type="attention">
    Important: When using the `Sampler` primitive, the circuit **must contain measurements**.
</Admonition>

<Tabs>
  <TabItem value="PrimV2" label="Runtime Sampler">
  For Qiskit Runtime, circuits must obey the ISA of a particular backend.
``` python
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
 
service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

# To use Fake backends with local testing mode, import it and use it as the backend instead

# from qiskit_ibm_runtime.fake_provider import FakeManilaV2
# backend = FakeManilaV2()

from qiskit import QuantumCircuit

circuit = QuantumCircuit(4)
circuit.h(range(2))
circuit.cx(0,1)
circuit.measure_all() # measurement!

# Convert to ISA circuits
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(circuit)

```
  </TabItem>

  <TabItem value="PrimV1" label="backend.run">
``` python
from qiskit import QuantumCircuit

circuit = QuantumCircuit(4)
circuit.h(range(2))
circuit.cx(0,1)
circuit.measure_all() # measurement!
```
  </TabItem>
</Tabs>

### 2. Get counts from the result

<Tabs>
  <TabItem value="runtime" label="Runtime Sampler">
    While the user-side syntax of the `Sampler` is very similar to
`backend.run()`, notice that the workflow is now simplified, as the
quasi-probability distribution is returned **directly** (no need to
perform post-processing), together with some key metadata.

``` python
sampler = Sampler(backend=backend)

job = sampler.run([(isa_circuit,)])
result = job.result()
# Get results for the first (and only) PUB
pub_result = result[0]

# Get counts from the classical register "meas". 
print(f" >> Meas output register counts: {pub_result.data.meas.get_counts()}")

>> Meas output register counts: {'0001': 210, '0010': 305, '0000': 282, '0011': 201, '0101': 2, '1010': 6, '0110': 5, '0100': 6, '1000': 3, '0111': 1, '1001': 2, '1011': 1} 
```  
  </TabItem>

  <TabItem value="legacy" label="backend.run()">
The required steps to reach our goal with `backend.run()` are:

1.  Run circuits
2.  Get counts from the result object

First, we run the circuit in a cloud simulator and output the result
object:

<Admonition type="note">
    Replace `ibmq_qasm_simulator` with your device name to see the complete workflow for a real device.
</Admonition>


``` python
from qiskit import IBMQ

# Define provider and backend
provider = IBMQ.load_account()
backend = provider.get_backend("ibmq_qasm_simulator")

# Run
result = backend.run(circuit, shots=1024).result()
```

``` python
>>> print("result: ", result)
result:  Result(backend_name='ibmq_qasm_simulator', backend_version='0.11.0',
qobj_id='65bb8a73-cced-40c1-995a-8961cc2badc4', job_id='63fc95612751d57b6639f777',
success=True, results=[ExperimentResult(shots=1024, success=True, meas_level=2,
data=ExperimentResultData(counts={'0x0': 255, '0x1': 258, '0x2': 243, '0x3': 268}),
header=QobjExperimentHeader(clbit_labels=[['meas', 0], ['meas', 1], ['meas', 2], ['meas', 3]],
creg_sizes=[['meas', 4]], global_phase=0.0, memory_slots=4, metadata={}, n_qubits=4,
name='circuit-930', qreg_sizes=[['q', 4]], qubit_labels=[['q', 0], ['q', 1], ['q', 2], ['q', 3]]),
status=DONE, metadata={'active_input_qubits': [0, 1, 2, 3], 'batched_shots_optimization': False,
'device': 'CPU', 'fusion': {'enabled': False}, 'input_qubit_map': [[3, 3], [2, 2], [1, 1], [0, 0]],
'measure_sampling': True, 'method': 'stabilizer', 'noise': 'ideal', 'num_clbits': 4, 'num_qubits': 4,
'parallel_shots': 1, 'parallel_state_update': 16, 'remapped_qubits': False,
'sample_measure_time': 0.001001096}, seed_simulator=2191402198, time_taken=0.002996865)],
date=2023-02-27 12:35:00.203255+01:00, status=COMPLETED, header=QobjHeader(backend_name='ibmq_qasm_simulator',
backend_version='0.1.547'), metadata={'max_gpu_memory_mb': 0, 'max_memory_mb': 386782, 'mpi_rank': 0,
'num_mpi_processes': 1, 'num_processes_per_experiments': 1, 'omp_enabled': True, 'parallel_experiments': 1,
'time_taken': 0.003215252, 'time_taken_execute': 0.00303248, 'time_taken_load_qobj': 0.000169435},
time_taken=0.003215252, client_version={'qiskit': '0.39.5'})
```

Now we get the probability distribution from the output:

``` python
counts = result.get_counts(circuit)

>>> print("counts: ", counts)
counts:  {'0000': 255, '0001': 258, '0010': 243, '0011': 268}
```

  </TabItem>
</Tabs>


## Next steps
The Runtime primitives offer a series of features and tuning
options, some of which do not have a legacy alternative to migrate from, but can
help improve your performance and results. For more information, refer
to the following:

<Admonition type="tip" title="Recommendations">
- [Common use cases](qiskit-runtime-use-case)
- [Migrate `backend.run` options to primitive options](qiskit-runtime-options)
- [Setting execution options topic](../../run/advanced-runtime-options)
- [Primitive execution options API reference](../qiskit-ibm-runtime/qiskit_ibm_runtime.options.Options)
- [How to run a session topic](../../run/run-jobs-in-session)
- [Qiskit Runtime local testing mode topic](../../verify/local-testing-mode)
</Admonition>

