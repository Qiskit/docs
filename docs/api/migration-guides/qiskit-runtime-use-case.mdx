---
title: Common use cases
description: Common use cases when migrating from backend.run to Qiskit Runtime primitives
---

# Common use cases
This topic describes how to migrate programs with the most commonly used types of circuits.  For a full example, see [End-to-end examples.](qiskit-runtime-examples)

## Basic circuits
The only changes when running basic circuits are how you run the job and retrieve results.  

<Tabs>
  <TabItem value="Updated" label="Runtime primitives">
```python
from qiskit_ibm_runtime import SamplerV2 as Sampler

job = sampler.run([(isa_circuit,)])
result = job.result()
# Get results for the first (and only) PUB
pub_result = result[0]

```
  </TabItem>

  <TabItem value="Legacy" label="backend.run">
``` python
from qiskit import IBMQ

# Define provider and backend
provider = IBMQ.load_account()

job = backend.run(circuit)
result = job.result()
```
  </TabItem>
</Tabs>

<span id="migrate-options"></span>
## Circuits with options

All options that were available with `backend.run` are available in the Qiskit Runtime primitives, but they are specified differently.  For more information, see [Migrate `backend.run` options to primitive options](qiskit-runtime-options) and [Advanced Qiskit Runtime options.](../../run/advanced-runtime-options)

<Tabs>
  <TabItem value="Updated" label="Runtime primitives">

```python
from qiskit_ibm_runtime import SamplerV2 as Sampler

sampler.options.default_shots = 1024
```

  </TabItem>

  <TabItem value="Legacy" label="backend.run">
```python
from qiskit import IBMQ

backend.run(circuit, shots=1024)
```
  </TabItem>
</Tabs>


## Dynamic circuits

To migrate programs that run dynamic circuits, change the run call.

<Tabs>
  <TabItem value="primitives" label="Runtime">
    ```python  
job = sampler.run([dynamic_circ])

pub_result = job.result()[0]
print(f">>> Hardware counts: {pub_result.data.meas.get_counts()}")
```
  </TabItem>

  <TabItem value="backend" label="backend.run">
    ```python  
job = backend.run(dynamic_circ, dynamic=True)
job.job_id()

hardware_counts = job.result().get_counts()
hardware_counts
```
  </TabItem>
</Tabs>

For more information about dynamic circuits, see the [Classical feedforward and control flow](../../build/classical-feedforward-and-control-flow) topic, or try the [Repeat until success](https://learning.quantum.ibm.com/tutorial/repeat-until-success) tutorial.

<span id="parm-circ"></span>
## Parameterized circuits

Parametrized circuits are a commonly used tool for quantum algorithm
design. Because `backend.run()` did not accept parametrized
circuits, the parameter binding step had to be integrated in the
algorithm workflow. The primitives can perform the parameter binding
step internally, which results in a simplification of the algorithm-side
logic.

The following example summarizes the new workflow for managing
parametrized circuits.

### Example

Define a parametrized circuit:

``` python
from qiskit.circuit import QuantumCircuit, ParameterVector

n = 3
thetas = ParameterVector('Î¸',n)

qc = QuantumCircuit(n, 1)
qc.h(0)

for i in range(n-1):
    qc.cx(i, i+1)

for i,t in enumerate(thetas):
    qc.rz(t, i)

for i in reversed(range(n-1)):
    qc.cx(i, i+1)

qc.h(0)
qc.measure(0, 0)

qc.draw()
```


Assign the following parameter values to the circuit:

``` python
import numpy as np
theta_values = [np.pi/2, np.pi/2, np.pi/2]
```

<Tabs>
  <TabItem value="updated" label="Runtime primitives">
Qiskit Runtime V2 primitives support only circuits that adhere to the Instruction Set Architecture (ISA) of a particular backend, so we must transform our circuits. 

```python
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

service = QiskitRuntimeService()
backend = service.least_busy(operational=True, simulator=False)

pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
isa_circuit = pm.run(qc)
```

The primitives take in parametrized circuits directly, together
with the parameter values, and the parameter assignment operation can be
performed more efficiently on the server side of the primitive.  The input is in the form of primitive unified blocs (PUBs).  Each PUB is a tuple that contains a circuit and the data broadcasted to it.  For further details, see [Introduction to primitives.](../../run/primitives#interface-changes)

This feature is particularly interesting when working with iterative
algorithms because the parametrized circuit remains unchanged between
calls while the parameter values change. The primitives can transpile
once and then cache the unbound circuit, using classical resources more
efficiently. Moreover, only the updated parameters are transferred to
the cloud, saving additional bandwidth.

<Admonition type="note">
As shown in the previous image, the classical register name is `c`.  Alternatively, you can find the classical register name by running `<circuit_name>.cregs`. For example: `qc.cregs`.
</Admonition>

``` python
from qiskit_ibm_runtime import SamplerV2 as Sampler

sampler = Sampler(backend)
job = sampler.run([(isa_circuit, theta_values)])
result = job.result()
# Get results for the first (and only) PUB
pub_result = result[0]
# Get counts from the classical register "c". 
print(f" >> Counts for the c output register: {pub_result.data.c.get_counts()}")
```
  </TabItem>

  <TabItem value="legacy" label="backend.run">
The parameter values had to be bound to their respective
circuit parameters prior to calling `backend.run()`.

``` python
from qiskit import Aer

bound_circuit = qc.bind_parameters(theta_values)
bound_circuit.draw()

backend = Aer.get_backend('aer_simulator')
job = backend.run(bound_circuit)
counts = job.result().get_counts()
print(counts)
```
  </TabItem>
</Tabs>
