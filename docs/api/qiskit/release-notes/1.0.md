---
title: Qiskit 1.0 release notes
description: New features and bug fixes
---
# Qiskit 1.0 release notes
  
## 1.0.0rc1

<span id="relnotes-1-0-0rc1-new-features" />

### New Features

*   Added a new argument, `annotated`, to the methods [`QuantumCircuit.control()`](/api/qiskit/qiskit.circuit.QuantumCircuit#control "qiskit.circuit.QuantumCircuit.control"), [`Gate.control()`](/api/qiskit/qiskit.circuit.Gate#control "qiskit.circuit.Gate.control") and `.control()` methods of [`Gate`](/api/qiskit/qiskit.circuit.Gate "qiskit.circuit.Gate") subclasses (such as [`UnitaryGate`](/api/qiskit/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate") or [`SwapGate`](/api/qiskit/qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate")) to optionally return an [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation"). The default value of `annotated` is `False` and corresponds to the pre-existing behavior of the method, for example:

    ```python
    SwapGate().control(1, annotated=False)
    ```

    returns a [`CSwapGate`](/api/qiskit/qiskit.circuit.library.CSwapGate "qiskit.circuit.library.CSwapGate") while:

    ```python
    SwapGate().control(2, annotated=False)
    ```

    returns a `ControlledGate`. When `annotated==True`, the methods return an object of type [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") instead, avoiding the eager construction of the controlled gate’s definition.

*   Added a new argument, `annotated`, to the methods [`QuantumCircuit.inverse()`](/api/qiskit/qiskit.circuit.QuantumCircuit#inverse "qiskit.circuit.QuantumCircuit.inverse"), [`circuit.Instruction.inverse()`](/api/qiskit/qiskit.circuit.Instruction#inverse "qiskit.circuit.Instruction.inverse") and `.inverse()` methods of [`Instruction`](/api/qiskit/qiskit.circuit.Instruction "qiskit.circuit.Instruction") subclasses (such as [`SwapGate`](/api/qiskit/qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate") or [`SGate`](/api/qiskit/qiskit.circuit.library.SGate "qiskit.circuit.library.SGate")) to optionally return an [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation"). The default value of `annotated` is `False` and corresponds to he pre-existing behavior of the method. Furthermore, for standard gates with an explicitly defined `inverse` method, the argument `annotated` has no effect, for example, both:

    ```python
    SwapGate().inverse(annotated=False)
    SwapGate().inverse(annotated=True)
    ```

    return a [`SwapGate`](/api/qiskit/qiskit.circuit.library.SwapGate "qiskit.circuit.library.SwapGate"), and both:

    ```python
    SGate().inverse(annotated=False)
    SGate().inverse(annotated=True)
    ```

    return an [`SdgGate`](/api/qiskit/qiskit.circuit.library.SdgGate "qiskit.circuit.library.SdgGate"). The difference manifests for custom instructions without an explicitly defined inverse. With `annotated=False`, the method returns a fresh instruction with the recursively inverted definition, just as before. While `annotated=True` returns an [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation") that represents the instruction modified with the [`InverseModifier`](/api/qiskit/qiskit.circuit.InverseModifier "qiskit.circuit.InverseModifier").

*   The `text` and `mpl` outputs for the [`QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") and [`circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") circuit drawer functions will now display detailed information for operations of [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation"). If the `AnnotatedOperation.modifiers` contains a [`ControlModifier`](/api/qiskit/qiskit.circuit.ControlModifier "qiskit.circuit.ControlModifier"), the operation will be displayed the same way as controlled gates. If the [`InverseModifier`](/api/qiskit/qiskit.circuit.InverseModifier "qiskit.circuit.InverseModifier") or [`PowerModifier`](/api/qiskit/qiskit.circuit.PowerModifier "qiskit.circuit.PowerModifier") is used, these will be indicated with the base operation name. For example:

    ```python
    from qiskit.circuit import (
        AnnotatedOperation,
        ControlModifier,
        PowerModifier,
        InverseModifier,
        QuantumCircuit
    )
    from qiskit.circuit.library import SGate

    annotated_op = AnnotatedOperation(SGate(), [PowerModifier(3.4), ControlModifier(3), InverseModifier()])
    qc = QuantumCircuit(4)
    qc.append(annotated_op, range(4))
    qc.draw("mpl")
    ```

    ![\_images/release\_notes-1.png](/images/api/qiskit/release_notes-1.png)

*   Added a commutation library to the [`CommutationChecker`](/api/qiskit/qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker"). This library stores all the commutation relations of unparameterizable standard gates into a dictionary that allows for efficient lookup at runtime. This speeds up the execution of the [`CommutationChecker`](/api/qiskit/qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") class and, by extension, the [`CommutationAnalysis`](/api/qiskit/qiskit.transpiler.passes.CommutationAnalysis "qiskit.transpiler.passes.CommutationAnalysis") transpiler pass, as instead of computing whether two unparameterizable standard gates commute it just has to look it up from the library.

    Additionally, the [`CommutationChecker`](/api/qiskit/qiskit.circuit.CommutationChecker "qiskit.circuit.CommutationChecker") was refactored and now has an upper limit set on the number of cached commutation relations that are not in the commutation library. This addressed: [#8020](https://github.com/Qiskit/qiskit-terra/issues/8020) and [#7101](https://github.com/Qiskit/qiskit-terra/issues/7101)

*   Added a new class, [`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2"), to the [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module. This class is configurable, and builds a [`BackendV2`](/api/qiskit/qiskit.providers.BackendV2 "qiskit.providers.BackendV2") backend instance that can be run locally (in the spirit of fake backends). Users can configure the number of qubits, basis gates, coupling map, ability to run dynamic circuits (control flow instructions), instruction calibrations and dtm of the backend without having to deal with manual target construction. Qubit and gate properties (duration, errror) are generated by randomly sampling from default ranges. The seed for this random generation can be fixed to ensure the reproducibility of the backend output. It’s important to note that this backend only supports gates in the standard library. If you need a more flexible backend, there is always the option to directly instantiate a [`Target`](/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") object to use for transpilation.

    Example usage 1:

    ```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.fake_provider import GenericBackendV2

    # Create a simple circuit
    circuit = QuantumCircuit(3)
    circuit.h(0)
    circuit.cx(0,1)
    circuit.cx(0,2)
    circuit.measure_all()
    circuit.draw('mpl')

    # Define backend with 3 qubits
    backend = GenericBackendV2(num_qubits=3)

    # Transpile and run
    transpiled_circuit = transpile(circuit, backend)
    result = backend.run(transpiled_circuit).result()
    ```

    Example usage 2:

    ```python
    from qiskit import QuantumCircuit, ClassicalRegister, transpile
    from qiskit.providers.fake_provider import GenericBackendV2

    # Create a circuit with classical control
    creg = ClassicalRegister(19)
    qc = QuantumCircuit(25)
    qc.add_register(creg)
    qc.h(0)
    for i in range(18):
        qc.cx(0, i + 1)
    for i in range(18):
        qc.measure(i, creg[i])
    qc.ecr(20, 21).c_if(creg, 0)

    # Define backend with custom basis gates and control flow instructions
    backend = GenericBackendV2(num_qubits=25, basis_gates = ["ecr","id","rz","sx","x"], control_flow=True)

    #Transpile
    transpiled_qc = transpile(qc, backend)
    ```

    <Admonition title="Note" type="note">
      The noise properties generated by these class do not mimic any concrete quantum device, and should not be used to measure any concrete behaviors. They are “reasonable defaults” that can be used to test backend-interfacing functionality not tied specific noise values of real quantum systems. For a more accurate simulation of existing devices, you can manually build a noise model from the real backend using the functionality offered in `qiskit-aer`.
    </Admonition>

*   The [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module now includes a series of generic fake backends following the [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") interface. They have been introduced as an alternative to the snapshot-based fake backends exposed in the deprecated `FakeProvider` (`FakeVigo`, `FakeTokyo`, etc). The list of new fake backends includes:

    > *   Backends without pulse capabilities:
    >
    >     *   [`Fake5QV1`](/api/qiskit/qiskit.providers.fake_provider.Fake5QV1 "qiskit.providers.fake_provider.Fake5QV1")
    >     *   [`Fake20QV1`](/api/qiskit/qiskit.providers.fake_provider.Fake20QV1 "qiskit.providers.fake_provider.Fake20QV1")
    > *   Backends with pulse capabilities:
    >
    >     *   [`Fake7QPulseV1`](/api/qiskit/qiskit.providers.fake_provider.Fake7QPulseV1 "qiskit.providers.fake_provider.Fake7QPulseV1")
    >     *   [`Fake27QPulseV1`](/api/qiskit/qiskit.providers.fake_provider.Fake27QPulseV1 "qiskit.providers.fake_provider.Fake27QPulseV1")
    >     *   [`Fake127QPulseV1`](/api/qiskit/qiskit.providers.fake_provider.Fake127QPulseV1 "qiskit.providers.fake_provider.Fake127QPulseV1")

    They can be imported following the pattern: `from qiskit.providers.fake_provider import Fake5QV1`. More details on the backend properties can be found on each backend’s API documentation.

*   Added a new exception class: [`InvalidLayoutError`](/api/qiskit/transpiler#qiskit.transpiler.InvalidLayoutError "qiskit.transpiler.InvalidLayoutError"). This is a [`TranspilerError`](/api/qiskit/transpiler#qiskit.transpiler.TranspilerError "qiskit.transpiler.TranspilerError") subclass which is raised when a user provided layout is invalid (mismatched size, duplicate qubits, etc).

*   Added a new keyword argument, `num_processes`, to [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and the `PassManager.run()` method. This allows for overriding both `QISKIT_NUM_PROCS` and the `num_processes` field in user configuration files on a per-transpile basis. For example:

    ```python
    from qiskit import transpile, QuantumCircuit

    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()

    transpile([qc]*10, basis_gates=['u', 'cz'], num_processes=2)
    ```

    will run the transpile over the 10 input circuits using only 2 processes and will override the system default, environment variable, or user configuration file for that [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") call.

*   Added a new transpiler pass, [`OptimizeAnnotated`](/api/qiskit/qiskit.transpiler.passes.OptimizeAnnotated "qiskit.transpiler.passes.OptimizeAnnotated"), that optimizes annotated operations on a quantum circuit.

    Consider the following example:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.annotated_operation import (
        AnnotatedOperation,
        InverseModifier,
        ControlModifier,
    )
    from qiskit.circuit.library import CXGate, SwapGate
    from qiskit.transpiler.passes import OptimizeAnnotated

    # Create a quantum circuit with multiple annotated gates
    gate1 = AnnotatedOperation(
        SwapGate(),
        [InverseModifier(), ControlModifier(2), InverseModifier(), ControlModifier(1)],
    )
    gate2 = AnnotatedOperation(
        SwapGate(),
        [InverseModifier(), InverseModifier()]
    )
    gate3 = AnnotatedOperation(
        AnnotatedOperation(CXGate(), ControlModifier(2)),
        ControlModifier(1)
    )
    qc = QuantumCircuit(6)
    qc.append(gate1, [3, 2, 4, 0, 5])
    qc.append(gate2, [1, 5])
    qc.append(gate3, [5, 4, 3, 2, 1])

    # Optimize the circuit using OptimizeAnnotated transpiler pass
    qc_optimized = OptimizeAnnotated()(qc)

    # This is how the optimized circuit should look like
    gate1_expected = AnnotatedOperation(SwapGate(), ControlModifier(3))
    gate2_expected = SwapGate()
    gate3_expected = AnnotatedOperation(CXGate(), ControlModifier(3))
    qc_expected = QuantumCircuit(6)
    qc_expected.append(gate1_expected, [3, 2, 4, 0, 5])
    qc_expected.append(gate2_expected, [1, 5])
    qc_expected.append(gate3_expected, [5, 4, 3, 2, 1])

    assert qc_optimized == qc_expected
    ```

    In the case of `gate1`, the modifiers of the annotated swap gate are brought into the canonical form: the two [`InverseModifier`](/api/qiskit/qiskit.circuit.InverseModifier "qiskit.circuit.InverseModifier")s cancel out, and the two [`ControlModifier`](/api/qiskit/qiskit.circuit.ControlModifier "qiskit.circuit.ControlModifier")s are combined. In the case of `gate2`, all the modifiers get removed and the annotated operation is replaced by its base operation. In the case of `gate3`, multiple layers of annotations are combined into one.

    The constructor of the [`OptimizeAnnotated`](/api/qiskit/qiskit.transpiler.passes.OptimizeAnnotated "qiskit.transpiler.passes.OptimizeAnnotated") pass accepts optional arguments `target`, `equivalence_library`, `basis_gates` and `recurse`. When `recurse` is `True` (the default value) and when either `target` or `basis_gates` are specified, the pass recursively descends into the gate’s `definition` circuits, with the exception of gates that are already supported by the target or that belong to the equivalence library. On the other hand, when neither `target` nor `basis_gates` are specified, or when `recurse` is set to `False`, the pass synthesizes only the “top-level” annotated operations, i.e. does not recursively descend into the `definition` circuits. This behavior is consistent with that of the [`HighLevelSynthesis`](/api/qiskit/qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis") transpiler pass, which needs to be called in order to “unroll” the annotated operations into 1-qubit and 2-qubits gates.

*   Added a new warning class, [`QPYLoadingDeprecatedFeatureWarning`](/api/qiskit/qpy#qiskit.qpy.QPYLoadingDeprecatedFeatureWarning "qiskit.qpy.QPYLoadingDeprecatedFeatureWarning"), to the QPY module. This class allows for deprecation warnings to surface even if the depreacted feature is in a variable point in the call stack, as is the case for many QPY loading functions that are called recursively.

*   Added a new flag, `version`, to the [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") function. This allows [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") to optionally take an integer value for the [QPY Format](/api/qiskit/qpy#qpy-format) version to emit. This is useful if you need to generate a QPY file that will be loaded by an older version of Qiskit. However, the supported versions to emit are limited, only versions between the latest QPY version (which is the default), and the compatibility QPY version which is [Version 10](/api/qiskit/qpy#qpy-version-10) (which was introduced in Qiskit 0.45.0) can be used. The compatibility version will remain fixed for the the entire 1.x.y major version release series. This does not change the backwards compatibility guarantees of the QPY format when calling [`qpy.load()`](/api/qiskit/qpy#qiskit.qpy.load "qiskit.qpy.load"), it just enables users to emit an older version of QPY to maintain compatibility and interoperability between the 0.x and 1.x release series.

*   Added a [`qiskit.synthesis.synth_circuit_from_stabilizers()`](/api/qiskit/synthesis#qiskit.synthesis.synth_circuit_from_stabilizers "qiskit.synthesis.synth_circuit_from_stabilizers") function that returns a circuit that outputs the state stabilized by a series of given stabilizers.

*   Added a [`qiskit.quantum_info.StabilizerState.from_stabilizer_list()`](/api/qiskit/qiskit.quantum_info.StabilizerState#from_stabilizer_list "qiskit.quantum_info.StabilizerState.from_stabilizer_list") method that generates a stabilizer state from a list of stabilizers:

    ```python
    from qiskit.quantum_info import StabilizerState

    stabilizer_list = ["ZXX", "-XYX", "+ZYY"]
    stab = StabilizerState.from_stabilizer_list(stabilizer_list)
    ```

*   Added a new [`HighLevelSynthesisPlugin`](/api/qiskit/qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin "qiskit.transpiler.passes.synthesis.plugin.HighLevelSynthesisPlugin") for [`PermutationGate`](/api/qiskit/qiskit.circuit.library.PermutationGate "qiskit.circuit.library.PermutationGate") objects based on Qiskit’s token swapper algorithm. To use this plugin, specify `token_swapper` when defining high-level-synthesis config.

    This synthesis plugin is able to run before or after the layout is set. When synthesis succeeds, the plugin outputs a quantum circuit consisting only of swap gates. When synthesis does not succeed, the plugin outputs `None`.

    The following code illustrates how the new plugin can be run:

    ```python
    from qiskit.circuit import QuantumCircuit
    from qiskit.circuit.library import PermutationGate
    from qiskit.transpiler import PassManager, CouplingMap
    from qiskit.transpiler.passes.synthesis.high_level_synthesis import HighLevelSynthesis, HLSConfig

    # This creates a circuit with a permutation gate.
    qc = QuantumCircuit(8)
    perm_gate = PermutationGate([0, 1, 4, 3, 2])
    qc.append(perm_gate, [3, 4, 5, 6, 7])

    # This defines the coupling map.
    coupling_map = CouplingMap.from_ring(8)

    # This high-level-synthesis config specifies that we want to use
    # the "token_swapper" plugin for synthesizing permutation gates,
    # with the option to use 10 trials.
    synthesis_config = HLSConfig(permutation=[("token_swapper", {"trials": 10})])

    # This creates the pass manager that runs high-level-synthesis on our circuit.
    # The option use_qubit_indices=True indicates that synthesis is run after the layout is set,
    # and hence should preserve the specified coupling map.
    pm = PassManager(
        HighLevelSynthesis(
            synthesis_config, coupling_map=coupling_map, target=None, use_qubit_indices=True
        )
    )

    qc_transpiled = pm.run(qc)
    ```

*   The AQC unitary synthesis plugin method now uses a faster objective function evaluation by default, which results in substantial improvement in synthesis time.

*   [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") now accepts string keys in the mapping form of input. These names are used to look up the corresponding [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") instance using [`get_parameter()`](/api/qiskit/qiskit.circuit.QuantumCircuit#get_parameter "qiskit.circuit.QuantumCircuit.get_parameter"). This lets you do:

    ```python
    from qiskit.circuit import QuantumCircuit, Parameter

    a = Parameter("a")
    qc = QuantumCircuit(1)
    qc.rx(a, 0)

    qc.assign_parameters({"a": 1}) == qc.assign_parameters({a: 1})
    ```

*   [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") has two new methods, [`get_parameter()`](/api/qiskit/qiskit.circuit.QuantumCircuit#get_parameter "qiskit.circuit.QuantumCircuit.get_parameter") and [`has_parameter()`](/api/qiskit/qiskit.circuit.QuantumCircuit#has_parameter "qiskit.circuit.QuantumCircuit.has_parameter"), which respectively retrieve a [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") instance used in the circuit by name, and return a boolean of whether a parameter with a matching name (or the exact instance given) are used in the circuit.

*   Added two new arguments, `matrix_based` and `max_qubits`, to the constructor of the [`CommutativeInverseCancellation`](/api/qiskit/qiskit.transpiler.passes.CommutativeInverseCancellation "qiskit.transpiler.passes.CommutativeInverseCancellation") transpiler pass. When `matrix_based` is `True`, the pass uses matrix representations to check whether two operations are the inverse of each other. This makes the checks more powerful, and in addition allows for cancelling pairs of operations that are inverse up to a phase, while updating the global phase of the circuit accordingly. This generally leads to more reductions at the expense of increased runtime. The argument `max_qubits` limits the number of qubits in matrix-based commutativity and inverse checks. For example:

    ```python
    import numpy as np
    from qiskit.circuit import QuantumCircuit
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import CommutativeInverseCancellation

    circuit = QuantumCircuit(1)
    circuit.rz(np.pi / 4, 0)
    circuit.p(-np.pi / 4, 0)

    passmanager = PassManager(CommutativeInverseCancellation(matrix_based=True))
    new_circuit = passmanager.run(circuit)
    ```

    The pass is able to cancel the `RZ` and `P` gates, while adjusting the circuit’s global phase to $\frac{15 \pi}{8}$.

*   Added a new [`BaseEstimatorV2`](/api/qiskit/qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") primitive base class based on [the RFC](https://github.com/Qiskit/RFCs/blob/master/0015-estimator-interface.md). This base class establishes the new `EstimatorV2` interface, which adds support for performing vectorized calls so that sweeps over parameter value sets and observables can be efficiently specified.

*   [`SparsePauliOp.from_operator()`](/api/qiskit/qiskit.quantum_info.SparsePauliOp#from_operator "qiskit.quantum_info.SparsePauliOp.from_operator") now uses an implementation of the “tensorized Pauli decomposition algorithm” presented in [Hatznko, Binkowski and Gupta (2023)](https://arxiv.org/abs/2310.13421). The method is now several orders of magnitude faster; for example, it is possible to decompose a random 10-qubit operator in around 250ms on a consumer Macbook Pro (Intel i7, 2020).

*   Added a new function, [`high_level_synthesis_plugin_names()`](/api/qiskit/qiskit.transpiler.passes.synthesis.plugin.high_level_synthesis_plugin_names "qiskit.transpiler.passes.synthesis.plugin.high_level_synthesis_plugin_names"), that can be used to get the list of installed high level synthesis plugins for a given operation name.

*   Added a new warning base class, [`QiskitWarning`](/api/qiskit/exceptions#qiskit.exceptions.QiskitWarning "qiskit.exceptions.QiskitWarning"). While Qiskit will continue to use built-in Python warnings (such as [`DeprecationWarning`](https://docs.python.org/3/library/exceptions.html#DeprecationWarning "(in Python v3.12)")) when those are most appropriate, for cases that are more specific to Qiskit, the warnings will be subclasses of [`QiskitWarning`](/api/qiskit/exceptions#qiskit.exceptions.QiskitWarning "qiskit.exceptions.QiskitWarning"). As a consequence of this addition, [`QPYLoadingDeprecatedFeatureWarning`](/api/qiskit/qpy#qiskit.qpy.QPYLoadingDeprecatedFeatureWarning "qiskit.qpy.QPYLoadingDeprecatedFeatureWarning") is now a subclass of [`QiskitWarning`](/api/qiskit/exceptions#qiskit.exceptions.QiskitWarning "qiskit.exceptions.QiskitWarning").

*   The optional-functionality testers ([`qiskit.utils.optionals`](/api/qiskit/utils#module-qiskit.utils.optionals "qiskit.utils.optionals")) will now distinguish an optional dependency that was completely not found (a normal situation) with one that was found, but triggered errors during its import. In the latter case, they will now issue an [`OptionalDependencyImportWarning`](/api/qiskit/exceptions#qiskit.exceptions.OptionalDependencyImportWarning "qiskit.exceptions.OptionalDependencyImportWarning") telling you what happened, since it might indicate a failed installation or an incompatible version.

*   A [`uuid`](/api/qiskit/qiskit.circuit.Parameter#uuid "qiskit.circuit.Parameter.uuid") property was added to the [`qiskit.circuit.Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") class. In advanced use cases, this property can be used for creating [`qiskit.circuit.Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") instances that compare equal to each other.

*   Added a new method, [`ParameterExpression.numeric()`](/api/qiskit/qiskit.circuit.ParameterExpression#numeric "qiskit.circuit.ParameterExpression.numeric"), which converts a fully bound parameter expression into the most restrictive built-in Python numeric type that accurately describes the result of the symbolic evaluation. For example, a symbolic integer will become an [`int`](https://docs.python.org/3/library/functions.html#int "(in Python v3.12)"), while a symbolic real number will become a [`float`](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)") and a complex number will become a [`complex`](https://docs.python.org/3/library/functions.html#complex "(in Python v3.12)"). This method includes several workarounds for peculiarities of the evaluation contexts of `symengine`, which can sometimes lead to spurious results when calling [`complex`](https://docs.python.org/3/library/functions.html#complex "(in Python v3.12)") or [`float`](https://docs.python.org/3/library/functions.html#float "(in Python v3.12)") on an expression directly.

*   The [`qiskit.qasm3`](/api/qiskit/qasm3#module-qiskit.qasm3 "qiskit.qasm3") package now contains a built-in, Rust-based parser for reading OpenQASM 3 programs into [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit")s, found at [`qiskit.qasm3.load_experimental()`](/api/qiskit/qasm3#qiskit.qasm3.load_experimental "qiskit.qasm3.load_experimental") and [`loads_experimental()`](/api/qiskit/qasm3#qiskit.qasm3.loads_experimental "qiskit.qasm3.loads_experimental"). These are typically several times faster than the existing, pure Python [`load()`](/api/qiskit/qasm3#qiskit.qasm3.load "qiskit.qasm3.load") and [`loads()`](/api/qiskit/qasm3#qiskit.qasm3.loads "qiskit.qasm3.loads") functions, which additionally require `qiskit-qasm3-import` to be installed.

    For example, we can create a 20,000-instruction entangling [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"):

    ```python
    import numpy as np
    import qiskit.qasm3
    from qiskit.circuit.library import RealAmplitudes

    qc = RealAmplitudes(100, reps=100, flatten=True)
    qc = qc.assign_parameters(np.random.rand(qc.num_parameters))
    oq3 = qiskit.qasm3.dumps(qc)
    ```

    The old [`qasm3.loads()`](/api/qiskit/qasm3#qiskit.qasm3.loads "qiskit.qasm3.loads") took about 7.3s to load the resulting OpenQASM 3 program, whereas [`qasm3.loads_experimental()`](/api/qiskit/qasm3#qiskit.qasm3.loads_experimental "qiskit.qasm3.loads_experimental") took under 300ms on a consumer Macbook Pro (i7, 2020)–a speedup of 25x!

    The supported feature set of the experimental parser is very limited in this preview version, but this will expand as both the Qiskit side and [the native Rust-based parser](https://github.com/Qiskit/openqasm3_parser) improve.

    One of our main goals with this new parser, alongside the huge speed improvements, is to provide top-quality error diagnostics. As with other parts of the parser, these are a work in progress, but you’ll start to see much higher quality error messages displayed when parsing invalid OpenQASM 3 programs with the experimental parser.

*   The OpenQASM 3 exporter (see [`dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump") and [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") functions in [`qiskit.qasm3`](/api/qiskit/qasm3#module-qiskit.qasm3 "qiskit.qasm3")) now supports the stabilised syntax of the `switch` statement in OpenQASM 3 by default. The pre-certification syntax of the `switch` statement is still available by using the [`ExperimentalFeatures.SWITCH_CASE_V1`](/api/qiskit/qasm3#qiskit.qasm3.ExperimentalFeatures.SWITCH_CASE_V1 "qiskit.qasm3.ExperimentalFeatures.SWITCH_CASE_V1") flag in the `experimental` argument of the exporter. There is no feature flag required for the stabilised syntax, but if you are interfacing with other tooling that is not yet updated, you may need to pass the experimental flag.

    The syntax of the stabilised form is slightly different with regards to terminating `break` statements (no longer required nor permitted), and multiple cases are now combined into a single `case` line, rather than using C-style fall-through. For more detail, see [the OpenQASM 3 documentation on the switch-case construct](https://openqasm.com/language/classical.html#the-switch-statement).

*   Add a new synthesis method [`synth_qft_line()`](/api/qiskit/synthesis#qiskit.synthesis.synth_qft_line "qiskit.synthesis.synth_qft_line") of a QFT circuit for linear nearest neighbor connectivity, which significantly reduces the number of SWAPs for large numbers of qubits compared to SABRE.

*   A new class, [`TwoQubitWeylDecomposition`](/api/qiskit/qiskit.synthesis.TwoQubitWeylDecomposition "qiskit.synthesis.TwoQubitWeylDecomposition"), has been added to [`qiskit.synthesis`](/api/qiskit/synthesis#module-qiskit.synthesis "qiskit.synthesis"). This class allows to apply the Weyl decomposition of two-qubit unitaries.

<span id="relnotes-1-0-0rc1-upgrade-notes" />

### Upgrade Notes

*   Changed default value of two arguments (`add_delay` and `filter_faulty`) in the `qiskit.providers.backend_compat.convert_to_target()` function. This conversion function now adds delay instructions and removes faulty instructions by default.

*   Qiskit 1.0 now requires version 0.14.0 of `rustworkx`.

*   The minimum supported Rust version for building Qiskit from source is now 1.70. This has been raised from the previous minimum supported Rust version of 1.64 in the Qiskit 0.45.x and 0.46.0 release series.

*   Removed the `Instruction.qasm` method, which was deprecated in Qiskit 0.45.0. Use [`qiskit.qasm2.dump()`](/api/qiskit/qasm2#qiskit.qasm2.dump "qiskit.qasm2.dump") with a complete [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") instead.

*   Removed the deprecated class `qiskit.pulse.instructions.Call`. No alternative pulse instruction is provided.

*   The following deprecated functions previously in [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") have been removed. These functions were marked as deprecated in the Qiskit 0.40.0 release, 2023-01.

    > *   `decompose_clifford`: you should use the [`qiskit.synthesis.synth_clifford_full()`](/api/qiskit/synthesis#qiskit.synthesis.synth_clifford_full "qiskit.synthesis.synth_clifford_full") function instead.
    > *   `decompose_cnotdihedral`: you should use the [`qiskit.synthesis.synth_cnotdihedral_full()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnotdihedral_full "qiskit.synthesis.synth_cnotdihedral_full") function instead.

*   The deprecated `qiskit.transpiler.synthesis` module has been removed. It was marked as deprecated in the 0.46.0 release. The following objects which previously existed in `qiskit.transpiler.synthesis` have been moved:

    *   The `qiskit.transpiler.synthesis.aqc` module has been moved to [`qiskit.synthesis.unitary.aqc`](/api/qiskit/synthesis_aqc#module-qiskit.synthesis.unitary.aqc "qiskit.synthesis.unitary.aqc"), with the exception of [`AQCSynthesisPlugin`](/api/qiskit/qiskit.transpiler.passes.AQCSynthesisPlugin "qiskit.transpiler.passes.AQCSynthesisPlugin")
    *   `qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin` has been moved to [`qiskit.transpiler.passes.AQCSynthesisPlugin`](/api/qiskit/qiskit.transpiler.passes.AQCSynthesisPlugin "qiskit.transpiler.passes.AQCSynthesisPlugin").
    *   `qiskit.transpiler.synthesis.graysynth()` has been moved and renamed to [`qiskit.synthesis.synth_cnot_phase_aam()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnot_phase_aam "qiskit.synthesis.synth_cnot_phase_aam").
    *   `qiskit.transpiler.synthesis.cnot_synth()` has been moved and renamed to [`qiskit.synthesis.synth_cnot_count_full_pmh()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnot_count_full_pmh "qiskit.synthesis.synth_cnot_count_full_pmh").

*   The method `qiskit.transpiler.target.Target.aquire_alignment`, deprecated in 0.24, has been removed. The method `qiskit.transpiler.target.Target.acquire_alignment` should be used instead.

*   Remove deprecated `__getitem__`/`__setitem__` magic methods of `Clifford`. The methods were deprecated since Qiskit 0.44, released on July 2023. Instead, index or iterate through the `Clifford.tableau` attribute.

*   Removed deprecated function `get_vf2_call_limit()` and its corresponding test. Instead, use `get_vf2_limits()`

*   The latest format version of QPY is now [Version 11](/api/qiskit/qpy#qpy-version-11) and this is what is emitted by default when running [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump").

*   Updated information of [`FakeOpenPulse2Q`](/api/qiskit/qiskit.providers.fake_provider.FakeOpenPulse2Q "qiskit.providers.fake_provider.FakeOpenPulse2Q") backend, including properties, defaults and previously missing instructions.

*   The properties `Bit.register` and `Bit.index` are removed. They were deprecated in Qiskit 0.25 (released in April, 2021). The qubits and bits now live only in the context of a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). The alternative to the properties is to use [`QuantumCircuit.find_bit()`](/api/qiskit/qiskit.circuit.QuantumCircuit#find_bit "qiskit.circuit.QuantumCircuit.find_bit") to find all the containing registers within a circuit and the index of the bit within the circuit.

*   The default style for the circuit visualization using Matplotlib has been changed to `"iqp"`, matching the IBM Quantum Platform.

*   The deprecated module `qiskit.visualization.qcstyle` has been removed in favor of `qiskit.visualization.circuit.qcstyle`.

*   The class [`EvolvedOperatorAnsatz`](/api/qiskit/qiskit.circuit.library.EvolvedOperatorAnsatz "qiskit.circuit.library.EvolvedOperatorAnsatz") has been migrated from [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library") to `qiskit.circuit.library.n_local` to match the location of its base class. This move has not affected the usual import path of the class: `from qiskit.circuit.library import EvolvedOperatorAnsatz`, but now it is also accessible doing `from qiskit.circuit.library.n_local import EvolvedOperatorAnsatz`.

*   The implicit use of `approximation_degree!=1.0` by default in the [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager") function has been disabled. The previous default could cause undue and unexpected approximations, especially in workloads involving Trotterization or similar runs of operations that are close, but decidedly not equal, to the identity.

    This change brings the inner pass-manager generation defaults in line with [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile"), which was always the intention. See [#8595](https://github.com/Qiskit/qiskit/pull/8595) for more detail.

*   The dependency on [psutil](https://pypi.org/project/psutil/) has been removed. The psutil library was previously only used for detecting the number of physical CPUs and total system memory, however this information provided does not add sufficient value to justify the additional dependencies and overhead so it has been removed. This does mean that the default number of processes used by [`parallel_map()`](/api/qiskit/utils#qiskit.utils.parallel_map "qiskit.utils.parallel_map") and functions that internally can use [`parallel_map()`](/api/qiskit/utils#qiskit.utils.parallel_map "qiskit.utils.parallel_map") such as [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") and [`PassManager.run()`](/api/qiskit/qiskit.transpiler.PassManager#run "qiskit.transpiler.PassManager.run") may use more or less parallel processes than in previous releases. If you’d like to adjust the number of processes used you can use the `QISKIT_NUM_PROCS` environment variable or `num_processes` field in a user configuration file (see the [local configuration guide](https://docs.quantum.ibm.com/start/configure-qiskit-local) for more details) if you need to adjust the number of processes that Qiskit potentially uses.

*   The `qiskit.providers.basicaer` module, exposed as `qiskit.BasicAer`, has been removed following it deprecation on the 0.46 release. Its functionality has been replaced by the [`qiskit.quantum_info`](/api/qiskit/quantum_info#module-qiskit.quantum_info "qiskit.quantum_info") module and the new [`qiskit.providers.basic_provider`](/api/qiskit/providers_basic_provider#module-qiskit.providers.basic_provider "qiskit.providers.basic_provider") module.

    The migration from using `qiskit.providers.basicaer` (`qiskit.BasicAer`) to [`qiskit.providers.basic_provider`](/api/qiskit/providers_basic_provider#module-qiskit.providers.basic_provider "qiskit.providers.basic_provider") can be performed as follows:

    | Migrate from                | Replace with                                                                                                              |
    | --------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
    | `qiskit.BasicAer`           | The new provider doesn’t have a global instance, imports should be from `qiskit.providers.basic_provider`                 |
    | `qiskit.providers.basicaer` | [`basic_provider`](/api/qiskit/providers_basic_provider#module-qiskit.providers.basic_provider "qiskit.providers.basic_provider")     |
    | `BasicAerProvider`          | [`BasicProvider`](/api/qiskit/qiskit.providers.basic_provider.BasicProvider "qiskit.providers.basic_provider.BasicProvider")          |
    | `BasicAerJob`               | [`BasicProviderJob`](/api/qiskit/qiskit.providers.basic_provider.BasicProviderJob "qiskit.providers.basic_provider.BasicProviderJob") |
    | `QasmSimulatorPy`           | [`BasicSimulator`](/api/qiskit/qiskit.providers.basic_provider.BasicSimulator "qiskit.providers.basic_provider.BasicSimulator")       |
    | `UnitarySimulatorPy`        | use [`Operator`](/api/qiskit/qiskit.quantum_info.Operator "qiskit.quantum_info.Operator")                                             |
    | `StatevectorSimulatorPy`    | use [`Statevector`](/api/qiskit/qiskit.quantum_info.Statevector "qiskit.quantum_info.Statevector")                                    |

    A notable difference is that the new provider is no longer exposed through a global instance (like `BasicAer`), so it will not be valid to do `from qiskit import BasicProvider`. Instead, the provider class must be imported from its submodule and instantiated manually:

    ```python
    from qiskit.providers.basic_provider import BasicProvider

    provider = BasicProvider()
    backend = provider.get_backend("sim_name")
    ```

    The following examples show the migration paths of the three simulators in `BasicAer`.

    1.  Statevector simulator:

        ```python
        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)
        qc.measure_all()

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("statevector_simulator")
        statevector = backend.run(qc).result().get_statevector()

        # New path
        qc.remove_final_measurements() # no measurements allowed
        from qiskit.quantum_info import Statevector
        statevector = Statevector(qc)
        ```

    2.  Unitary simulator:

        ```python
        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)
        qc.measure_all()

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("unitary_simulator")
        result = backend.run(qc).result()

        # New path
        qc.remove_final_measurements() # no measurements allowed
        from qiskit.quantum_info import Operator
        result = Operator(qc).data
        ```

    3.  Qasm simulator:

        ```python
        from qiskit import QuantumCircuit
        qc = QuantumCircuit(3)
        qc.h(0)
        qc.h(1)
        qc.cx(1,2)
        qc.measure_all()

        # Former path
        from qiskit import BasicAer
        backend = BasicAer.get_backend("qasm_simulator")
        result = backend.run(qc).result()

        # New path
        from qiskit.providers.basic_provider import BasicProvider
        backend = BasicProvider().get_backend("basic_simulator")
        result = backend.run(qc).result()
        # or, directly
        from qiskit.providers.basic_provider import BasicSimulator
        backend = BasicSimulator()
        result = backend.run(qc).result()
        ```

*   The object `qiskit.Aer` has been removed following its deprecation in Qiskit 0.46. You can instead use `qiskit_aer.Aer`, which is a drop-in replacement.

*   Importing from `qiskit.providers.aer` will no longer work, following its deprecation in Qiskit 0.46. You should instead import from `qiskit_aer`, which is a drop-in replacement.

*   Pulse jobs are no longer supported in fake backends, following the deprecation and removal of the underlying simulation functionality in Aer. For pulse-level simulation, outside the context of circuit objects, consider using a special-purpose library such as [Qiskit Dynamics](https://qiskit.org/ecosystem/dynamics/).

*   The method `QuantumCircuit.bind_parameters` has been removed, following its deprecation in Qiskit 0.45. You can use [`QuantumCircuit.assign_parameters()`](/api/qiskit/qiskit.circuit.QuantumCircuit#assign_parameters "qiskit.circuit.QuantumCircuit.assign_parameters") as a drop-in replacement with all its defaults, and it also exposes additional features over the old method.

*   Importing `Int1`, `Int2`, `BooleanFunction`, `classical_function()` from [`qiskit.circuit`](/api/qiskit/circuit#module-qiskit.circuit "qiskit.circuit") is now disabled. Instead, import the objects from the [`qiskit.circuit.classicalfunction`](/api/qiskit/classicalfunction#module-qiskit.circuit.classicalfunction "qiskit.circuit.classicalfunction") submodule, which requires the `tweedledum` package.

*   Removed the `ConfigurableFakeBackend` class deprecated in Qiskit 0.46.0. Instead, a suitable [`FakeBackend`](/api/qiskit/providers_fake_provider#qiskit.providers.fake_provider.FakeBackend "qiskit.providers.fake_provider.FakeBackend") can be used.

*   Removed deprecated methods in `InstructionToQobjConverter` and `QobjToInstructionConverter`. This includes

    *   `InstructionToQobjConverter.convert_acquire()`
    *   `InstructionToQobjConverter.convert_bundled_acquires()`
    *   `InstructionToQobjConverter.convert_set_frequency()`
    *   `InstructionToQobjConverter.convert_shift_frequency()`
    *   `InstructionToQobjConverter.convert_set_phase()`
    *   `InstructionToQobjConverter.convert_shift_phase()`
    *   `InstructionToQobjConverter.convert_delay()`
    *   `InstructionToQobjConverter.convert_play()`
    *   `InstructionToQobjConverter.convert_snapshot()`
    *   `QobjToInstructionConverter.convert_acquire()`
    *   `QobjToInstructionConverter.convert_set_phase()`
    *   `QobjToInstructionConverter.convert_shift_phase()`
    *   `QobjToInstructionConverter.convert_set_frequency()`
    *   `QobjToInstructionConverter.convert_shift_frequency()`
    *   `QobjToInstructionConverter.convert_delay()`
    *   `QobjToInstructionConverter.bind_pulse()`
    *   `QobjToInstructionConverter.convert_parametric()`
    *   `QobjToInstructionConverter.convert_snapshot()`

    These public methods are all replaced with protected ones which are implicitly called from the single entry point, i.e. call dunder method of the classes.

*   The module `ParametricPulse` is removed. All classes in it were deprecated since Qiskit 0.39 (with qiskit-terra 0.22), released in 2022-10. Instead, use [`SymbolicPulse`](/api/qiskit/qiskit.pulse.library.SymbolicPulse "qiskit.pulse.library.SymbolicPulse") and check its documentation for details.

*   Removed [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") features deprecated in the 0.45 release:

    > *   `header`, No alternative will be provided
    > *   `extension_lib`, No alternative will be provided

*   Removes the deprecated `Unroller` class in `qiskit.transpiler.passes.basis`. This class was deprecated in Qiskit Terra 0.45 and has been replaced by the combination usage of [`BasisTranslator`](/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") and [`UnrollCustomDefinitions`](/api/qiskit/qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions").

    Note that [`BasisTranslator`](/api/qiskit/qiskit.transpiler.passes.BasisTranslator "qiskit.transpiler.passes.BasisTranslator") and [`UnrollCustomDefinitions`](/api/qiskit/qiskit.transpiler.passes.UnrollCustomDefinitions "qiskit.transpiler.passes.UnrollCustomDefinitions") take different arguments than `Unroller`, as they requires a `EquivalenceLibrary` object to be passed in.

    Where previously `Unroller(basis_gates)` could be used, you can now use:

    ```python
    from qiskit.circuit.library.standard_gates.equivalence_library import (
        StandardEquivalenceLibrary as std_eqlib,
    )
    pm = PassManager([
        UnrollCustomDefinitions(std_eqlib, basis_gates)
        BasisTranslator(std_eqlib, basis_gates),
    ])
    translated = pm.run(circuit)
    ```

*   Qiskit’s `execute()` function is removed. This function served as a high-level wrapper around transpiling a circuit with some transpile options and running it on a backend with some run options. If you needed this functionality, consider staying in the 0.\* edition until transition is possible for you. To do the same thing, you can explicitly use the [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") function (with appropriate transpile options) followed by `backend.run()` (with appropriate run options).

    For example, instead of running:

    ```python
    from qiskit import execute
    job = execute(circuit, backend)
    ```

    you can run:

    ```python
    from qiskit import transpile
    new_circuit = transpile(circuit, backend)
    job = backend.run(new_circuit)
    ```

    Alternatively, the `Sampler` primitive is semantically equivalent to the deprecated `execute()` function. The class [`BackendSampler`](/api/qiskit/qiskit.primitives.BackendSampler "qiskit.primitives.BackendSampler") is a generic wrapper for backends that do not support primitives:

    ```python
    from qiskit.primitives import BackendSampler
    sampler = BackendSampler(backend)
    job = sampler.run(circuit)
    ```

*   Removed the `qiskit.extensions` module, which has been pending deprecation since the 0.45 release and has been fully deprecated in the 0.46 release. The following operations from this module are available in [`qiskit.circuit.library`](/api/qiskit/circuit_library#module-qiskit.circuit.library "qiskit.circuit.library"):

    > *   [`DiagonalGate`](/api/qiskit/qiskit.circuit.library.DiagonalGate "qiskit.circuit.library.DiagonalGate"),
    > *   `HamiltonianGateGate`,
    > *   [`Initialize`](/api/qiskit/qiskit.circuit.library.Initialize "qiskit.circuit.library.Initialize"),
    > *   [`Isometry`](/api/qiskit/qiskit.circuit.library.Isometry "qiskit.circuit.library.Isometry"),
    > *   `MCGupDiag`,
    > *   [`UCGate`](/api/qiskit/qiskit.circuit.library.UCGate "qiskit.circuit.library.UCGate"),
    > *   [`UCPauliRotGate`](/api/qiskit/qiskit.circuit.library.UCPauliRotGate "qiskit.circuit.library.UCPauliRotGate"),
    > *   [`UCRXGate`](/api/qiskit/qiskit.circuit.library.UCRXGate "qiskit.circuit.library.UCRXGate"),
    > *   [`UCRYGate`](/api/qiskit/qiskit.circuit.library.UCRYGate "qiskit.circuit.library.UCRYGate"),
    > *   [`UCRZGate`](/api/qiskit/qiskit.circuit.library.UCRZGate "qiskit.circuit.library.UCRZGate"),
    > *   [`UnitaryGate`](/api/qiskit/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate").

    The following objects have been removed:

    > *   `SingleQubitUnitary` (instead use [`library.UnitaryGate`](/api/qiskit/qiskit.circuit.library.UnitaryGate "qiskit.circuit.library.UnitaryGate")),
    > *   `Snapshot` (superseded by Aer’s save instructions),
    > *   `ExtensionError`,

    along with the following circuit methods:

    > *   `QuantumCircuit.snapshot`,
    > *   `QuantumCircuit.squ`,
    > *   `QuantumCircuit.diagonal`,
    > *   `QuantumCircuit.hamiltonian`,
    > *   `QuantumCircuit.isometry` and `QuantumCircuit.iso`,
    > *   `QuantumCircuit.uc`,
    > *   `QuantumCircuit.ucrx`,
    > *   `QuantumCircuit.ucry`,
    > *   `QuantumCircuit.ucrz`.

    These operations can still be performed by appending the appropriate instruction to a quantum circuit.

*   Removed deprecated, duplicated [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") methods. These include:

    > *   `QuantumCircuit.cnot`, instead use [`QuantumCircuit.cx()`](/api/qiskit/qiskit.circuit.QuantumCircuit#cx "qiskit.circuit.QuantumCircuit.cx"),
    > *   `QuantumCircuit.toffoli`, instead use [`QuantumCircuit.ccx()`](/api/qiskit/qiskit.circuit.QuantumCircuit#ccx "qiskit.circuit.QuantumCircuit.ccx"),
    > *   `QuantumCircuit.fredkin`, instead use [`QuantumCircuit.cswap()`](/api/qiskit/qiskit.circuit.QuantumCircuit#cswap "qiskit.circuit.QuantumCircuit.cswap"),
    > *   `QuantumCircuit.mct`, instead use [`QuantumCircuit.mcx()`](/api/qiskit/qiskit.circuit.QuantumCircuit#mcx "qiskit.circuit.QuantumCircuit.mcx"),
    > *   `QuantumCircuit.i`, instead use [`QuantumCircuit.id()`](/api/qiskit/qiskit.circuit.QuantumCircuit#id "qiskit.circuit.QuantumCircuit.id").

*   The deprecated [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module has been migrated to the `qiskit-ibm-runtime` Python package. For this reason, the following elements in the [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") have been removed following their deprecation in Qiskit 0.46:

    > *   `qiskit.providers.fake_provider.FakeProvider`
    > *   `qiskit.providers.fake_provider.FakeProviderForBackendV2`
    > *   `qiskit.providers.fake_provider.FakeProviderFactory`
    > *   `qiskit.providers.fake_provider.fake_backends.FakeBackendV2`
    > *   any fake backend contained in `qiskit.providers.fake_provider.backends` (accessible through the provider)
    > *   `qiskit.providers.fake_provider.FakeQasmSimulator`
    > *   `qiskit.providers.fake_provider.FakeJob`
    > *   `qiskit.providers.fake_provider.FakeQobj`

    To use the new fake provider module, you can run `pip install qiskit-ibm-runtime` and replace the qiskit import path (`qiskit.providers.fake_provider`) with the new import path (`qiskit_ibm_runtime.fake_provider`). Migration example:

    ```python
    # Legacy path
    from qiskit.providers.fake_provider import FakeProvider, FakeSherbrooke
    backend1 = FakeProvider().get_backend("fake_ourense")
    backend2 = FakeSherbrooke()

    # New path
    # run "pip install qiskit-ibm-runtime"
    from qiskit_ibm_runtime.fake_provider import FakeProvider, FakeSherbrooke
    backend1 = FakeProvider().get_backend("fake_ourense")
    backend2 = FakeSherbrooke()
    ```

    Additionally, the following fake backends designed for special testing purposes have been superseded by the new [`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") class, and are also removed following their deprecation in Qiskit 0.46:

    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2`
    > *   `` `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2LegacyQubitProps ``
    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackend5QV2`
    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendSimple`

    Migration example to the new [`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") class:

    ```python
    # Legacy path
    from qiskit.providers.fake_provider import FakeBackend5QV2
    backend = FakeBackend5QV2()

    # New path
    from qiskit.providers.fake_provider import GenericBackendV2
    backend = GenericBackendV2(num_qubits=5)
    # note that this class will generate 5q backend with generic
    # properties that serves the same purpose as FakeBackend5QV2
    # but will generate different results
    ```

*   The deprecated `qiskit.IBMQ` object hase been removed. This alias object was marked as deprecated in the 0.23.0 release. This alias object lazily redirected attribute access to `qiskit.providers.ibmq.IBMQ`. As the `qiskit-ibmq-provider` package has now been retired and superseded by `qiskit-ibm-provider` package which maintains its own namespace maintaining this alias is no longer relevant. If you were relying on the `qiskit.IBMQ` alias you should migrate your usage to the `qiskit-ibm-provider` package, see the [migration guide](https://qiskit.org/ecosystem/ibm-provider/tutorials/Migration_Guide_from_qiskit-ibmq-provider.html) for more details.

*   Removed the deprecated module `qiskit.tools.jupyter` which previously included Jupyter Magics and widgets for interactively visualizing some data from Qiskit. This module was deprecated in Qiskit 0.46.0. Most of this functionality was directly tied to the legacy `qiskit-ibmq-provider` package and was no longer valid so the module was removed. Similar functionality is available from the `qiskit_ibm_provider.jupyter` module in the [qiskit-ibm-provider](https://github.com/Qiskit/qiskit-ibm-provider) package.

*   Removed the deprecated module `qiskit.tools.monitor` which previously included tools for tracking [`JobV1`](/api/qiskit/qiskit.providers.JobV1 "qiskit.providers.JobV1") job instances, primarily from the legacy `qiskit-ibm-provider` package. This module was marked as deprecated in Qiskit 0.46.0. It is being removed because it was directly tied to the legacy `qiskit-ibm-provider` package.

*   Removed the deprecated import path `qiskit.test.mock` which previously was used to redirect imports for the mock backends to their newer location in the [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider"). This module was marked as deprecated in Qiskit 0.37.0. If you were using this module you should update your imports from `qiskit.test.mock` to [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") instead.

*   The deprecated `NoiseAdaptiveLayout` transpiler pass has been removed. It was marked as deprecated in Qiskit 0.46.0. This pass has been largely superseded by [`VF2Layout`](/api/qiskit/qiskit.transpiler.passes.VF2Layout "qiskit.transpiler.passes.VF2Layout") and [`VF2PostLayout`](/api/qiskit/qiskit.transpiler.passes.VF2PostLayout "qiskit.transpiler.passes.VF2PostLayout") which will set a layout based on the reported noise characteristics of a backend. Along with the pass, the `layout_method` plugin `"noise_adaptive"` has been removed.

*   The deprecated `CrosstalkAdaptiveSchedule` transpiler pass has been removed. It was marked as deprecated in Qiskit 0.46.0. This pass was not usable any longer because its internal operation was dependent on custom properties being set in the [`BackendProperties`](/api/qiskit/qiskit.providers.models.BackendProperties "qiskit.providers.models.BackendProperties") payload of a [`BackendV1`](/api/qiskit/qiskit.providers.BackendV1 "qiskit.providers.BackendV1") instance. As no backends are setting these fields the pass was removed. If you depend on the pass for a custom workflow you can use the version in Qiskit 0.46.x.

*   The `scoped_parameters` and `search_parameters` methods have been removed from the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") class. These methods returned [`Parameter`](/api/qiskit/qiskit.circuit.Parameter "qiskit.circuit.Parameter") objects that partially linked to the parameters in the [`ScheduleBlock`](/api/qiskit/qiskit.pulse.ScheduleBlock "qiskit.pulse.ScheduleBlock") instance but assigning values using these objects did not work correctly. Users should use [`ScheduleBlock.parameters`](/api/qiskit/qiskit.pulse.ScheduleBlock#parameters "qiskit.pulse.ScheduleBlock.parameters") instead and iterate through [`ScheduleBlock.references`](/api/qiskit/qiskit.pulse.ScheduleBlock#references "qiskit.pulse.ScheduleBlock.references") and compare to the [`Schedule.parameters`](/api/qiskit/qiskit.pulse.Schedule#parameters "qiskit.pulse.Schedule.parameters") attributes of the subreferences when needing to distinguish which subroutine a parameter is used in. See [#11654](https://github.com/Qiskit/qiskit/issues/11654) for more information.

*   The `qiskit.test` module is no longer a public module. This was never intended to be public, nor used outside of Qiskit’s own test suite. All functionality was specific to Qiskit and no alternative is provided; if you needed similar functionality, you should include it in your own test harnesses.

*   It is no longer allowed to pass a [`QasmQobj`](/api/qiskit/qiskit.qobj.QasmQobj "qiskit.qobj.QasmQobj") as the first input to The `run()`. This functionality was deprecated in Qiskit 0.46 and has now been removed.

    Example usage:

    ```python
    from qiskit import transpile, QuantumCircuit
    from qiskit.providers.basicaer import BasicAer

    backend = BasicAer.get_backend('unitary_simulator')
    circuit = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure_all()
    tqc = transpile(circuit, backend)
    result = backend.run(tqc).result()
    ```

*   The deprecated `qiskit.tools.visualization` module has removed. This module was deprecated in the Qiskit 0.46.0 release. This module was a legacy redirect from the original location of Qiskit’s visualization module and was moved to [`qiskit.visualization`](/api/qiskit/visualization#module-qiskit.visualization "qiskit.visualization") in Qiskit 0.8.0. If you’re still using this path you can just update your imports from `qiskit.tools.visualization` to [`qiskit.visualization`](/api/qiskit/visualization#module-qiskit.visualization "qiskit.visualization").

*   The deprecated `qiskit.tools.events` module and the corresponding `qiskit.tools.progressbar` utility it exposed has been removed. It was deprecated in the Qiskit 0.46.0 release. This module’s functionality was not widely used and better covered by dedicated packages such as [tqdm](https://github.com/tqdm/tqdm).

*   The `qiskit.tools` module has been removed. This module was deprecated in Qiskit 0.46.0. All the contents from this module have been removed except for the `qiskit.tools.parallel_map` function which now can be used from [`qiskit.utils.parallel_map()`](/api/qiskit/utils#qiskit.utils.parallel_map "qiskit.utils.parallel_map") instead.

*   Removed the `qiskit.transpiler.synthesis` module, which has been deprecated since the 0.46 release. The following objects have been moved:

    *   `qiskit.transpiler.synthesis.aqc` has been moved to [`qiskit.synthesis.unitary.aqc`](/api/qiskit/synthesis_aqc#module-qiskit.synthesis.unitary.aqc "qiskit.synthesis.unitary.aqc") (except of `qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin`).
    *   `qiskit.synthesis.unitary.aqc.AQCSynthesisPlugin` has been moved to `qiskit.transpiler.passes.synthesis.AQCSynthesisPlugin`.
    *   `qiskit.transpiler.synthesis.graysynth()` has been moved to [`qiskit.synthesis.synth_cnot_phase_aam()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnot_phase_aam "qiskit.synthesis.synth_cnot_phase_aam").
    *   `qiskit.transpiler.synthesis.cnot_synth()` has been moved to [`qiskit.synthesis.synth_cnot_count_full_pmh()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnot_count_full_pmh "qiskit.synthesis.synth_cnot_count_full_pmh").

*   The deprecated support for passing a [`QuasiDistribution`](/api/qiskit/qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"), [`ProbDistribution`](/api/qiskit/qiskit.result.ProbDistribution "qiskit.result.ProbDistribution"), or a distribution dictionary to the `data` argument of the [`plot_histogram()`](/api/qiskit/qiskit.visualization.plot_histogram "qiskit.visualization.plot_histogram") visualization has been removed. This functionality was marked as deprecated in the Qiskit 0.39.0 release (2022-10). Instead if you would like to plot a histogram from a [`QuasiDistribution`](/api/qiskit/qiskit.result.QuasiDistribution "qiskit.result.QuasiDistribution"), [`ProbDistribution`](/api/qiskit/qiskit.result.ProbDistribution "qiskit.result.ProbDistribution"), or a distribution dictionary you should use the [`plot_distribution()`](/api/qiskit/qiskit.visualization.plot_distribution "qiskit.visualization.plot_distribution") function instead.

*   Removed logic for injecting circuit gate operation into the pulse context. Removed logic for calling QuantumCircuit into pulse builder context.

    Removed `call_gate()`, `cx()`, `u1()`, `u2()`, `u3()`, `x()`, `active_transpiler_settings()`, `active_circuit_scheduler_settings()`, `transpiler_settings()`, `circuit_scheduler_settings()`

    `_compile_lazy_circuit_before()`, `transpiler_settings()`, `_compile_lazy_circuit()`, `_compile_circuit()`, `_new_circuit()`, `call_gate()`

    Removed arguments `default_transpiler_settings`, `default_circuit_scheduler_settings` in [`build()`](/api/qiskit/pulse#qiskit.pulse.builder.build "qiskit.pulse.builder.build")

    Removed support of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") type for argument `target` in [`call()`](/api/qiskit/pulse#qiskit.pulse.builder.call "qiskit.pulse.builder.call")

    Removed support of [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") type for argument `subroutine` in `call_subroutine()`

    ```python
    from qiskit import compiler
    from qiskit.providers.fake_provider import FakePerth
    backend=FakePerth()

    """Users are encouraged to use gate operation in realm of QuantumCircuits,
    not in qiskit-pulse.  pulse should exclusively be used to make and call
    schedules comprised of pulses like Drag, Gaussian, GaussianSquare etc"""

    #Example:
    with pulse.build() as sched:
      pulse.play(pulse.Gaussian(150, 0.40, 10)
      pulse.play(pulse.GaussianSquare(150, 0.1, 12)

    """This is not encouraged but you can call
    QuantumCircuit into a pulse builder context like this:"""
    qc = QuantumCircuit(2)
    qc.cx(0, 1)
    qc = compiler.transpile(qc, backend)
    sched = compiler.schedule(qc, backend)

    with pulse.build(backend) as qc_sched:
      pulse.call(sched)

    """This example shows how to get pulse gate instructions.
    For BackendV2"""
     sched = backend.target['x'][(qubit,)].calibration

    # For BackendV1
     sched = backend.defaults().instruction_schedule_map.get('x', (0,))
    ```

    Modified module doc of [`qiskit.pulse.builder`](/api/qiskit/pulse#module-qiskit.pulse.builder "qiskit.pulse.builder") related with example code with circuit elements.

    Modified related tests in `test/python/pulse/test_builder.py`, `test/python/pulse/test_block.py` `test/python/pulse/test_builder_v2.py` `test/python/transpiler/test_calibrationbuilder.py`

*   Removed the `qiskit.quantum_info.synthesis` module, which has been deprecated since the 0.46 release. The following objects have been moved to [`qiskit.synthesis`](/api/qiskit/synthesis#module-qiskit.synthesis "qiskit.synthesis"):

    *   [`OneQubitEulerDecomposer`](/api/qiskit/qiskit.synthesis.OneQubitEulerDecomposer "qiskit.synthesis.OneQubitEulerDecomposer") has been moved to `qiskit.synthesis.one_qubit`
    *   [`TwoQubitBasisDecomposer`](/api/qiskit/qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") has been moved to `qiskit.synthesis.two_qubits`
    *   [`XXDecomposer`](/api/qiskit/qiskit.synthesis.XXDecomposer "qiskit.synthesis.XXDecomposer") has been moved to `qiskit.synthesis.two_qubits`
    *   [`two_qubit_cnot_decompose()`](/api/qiskit/synthesis#qiskit.synthesis.two_qubit_cnot_decompose "qiskit.synthesis.two_qubit_cnot_decompose") has been moved to `qiskit.synthesis.two_qubits`

    This function was removed, since it has already been deprecated in the 0.46 release: \* `cnot_rxx_decompose`

    These functions were removed, since they have already been deprecated in a previous release: \* `decompose_clifford` (use [`qiskit.synthesis.synth_clifford_full()`](/api/qiskit/synthesis#qiskit.synthesis.synth_clifford_full "qiskit.synthesis.synth_clifford_full") instead) \* `decompose_cnotdihedral` (use [`qiskit.synthesis.synth_cnotdihedral_full()`](/api/qiskit/synthesis#qiskit.synthesis.synth_cnotdihedral_full "qiskit.synthesis.synth_cnotdihedral_full") instead)

*   Remove `qiskit.test`. This includes `qiskit.test.QiskitTestCase` (and `BasicQiskitTestCase`) which are now for interal unittesting use.

*   The `target` keyword alias when calling [`TwoQubitBasisDecomposer`](/api/qiskit/qiskit.synthesis.TwoQubitBasisDecomposer "qiskit.synthesis.TwoQubitBasisDecomposer") instances as functions has been removed following its deprecation in qiskit-terra 0.23.0. You should pass the argument positionally as the first argument, or use the new name `unitary`.

*   The `qasm()` methods of the classes [`QuantumRegister`](/api/qiskit/qiskit.circuit.QuantumRegister "qiskit.circuit.QuantumRegister") and [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister") have been removed. There is no replacement necessary; these were an internal detail of a legacy implementation of the OpenQASM 2 exporter. To export a program to OpenQASM 2, use [`qasm2.dump()`](/api/qiskit/qasm2#qiskit.qasm2.dump "qiskit.qasm2.dump") or [`qasm2.dumps()`](/api/qiskit/qasm2#qiskit.qasm2.dumps "qiskit.qasm2.dumps").

*   The specialized transpiler pass `LinearFunctionsSynthesis` has been removed following its deprecation in qiskit-terra 0.23.0. Since its deprecation it just has been a very thin wrapper around [`HighLevelSynthesis`](/api/qiskit/qiskit.transpiler.passes.HighLevelSynthesis "qiskit.transpiler.passes.HighLevelSynthesis"), which you should use instead.

*   You can no longer set [`QuantumCircuit.metadata`](/api/qiskit/qiskit.circuit.QuantumCircuit#metadata "qiskit.circuit.QuantumCircuit.metadata") to be `None`, following deprecation in qiskit-terra 0.24.0. Its type is [`dict`](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.12)"), so to clear it, set it to `{}`.

*   The functions [`process_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.process_fidelity "qiskit.quantum_info.process_fidelity"), [`average_gate_fidelity()`](/api/qiskit/quantum_info#qiskit.quantum_info.average_gate_fidelity "qiskit.quantum_info.average_gate_fidelity"), [`gate_error()`](/api/qiskit/quantum_info#qiskit.quantum_info.gate_error "qiskit.quantum_info.gate_error") and [`diamond_norm()`](/api/qiskit/quantum_info#qiskit.quantum_info.diamond_norm "qiskit.quantum_info.diamond_norm") will no longer attempt to coerce arbitrary inputs to their marked expected types, following the deprecation in qiskit-terra 0.17.0. Pass inputs of the marked types to each argument directly.

*   The module path `qiskit.circuit.qpy_serialization` has been removed, following its deprecation in qiskit-terra 0.23.0. For QPY serialization, use [`qiskit.qpy`](/api/qiskit/qpy#module-qiskit.qpy "qiskit.qpy"), which is the new location.

*   The attribute `Register.name_format` has been removed following its deprecation in qiskit-terra 0.23.0. There is no restriction on register names any more, and the regular expression there was simply `[a-z][a-zA-Z0-9_]*`.

*   The `link_interval_dt` key of `QiskitTimelineStyle` has been removed. You should use the new name `link_interval_percent`.

*   The import path `qiskit.transpiler.passes.scheduling.calibration_creators` is removed. The transpiler passes it housed, [`RZXCalibrationBuilder`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilder "qiskit.transpiler.passes.RZXCalibrationBuilder") and [`RZXCalibrationBuilderNoEcho`](/api/qiskit/qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho "qiskit.transpiler.passes.RZXCalibrationBuilderNoEcho") can be imported directly from [`qiskit.transpiler.passes`](/api/qiskit/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes").

*   The import path `qiskit.transpiler.passes.scheduling.rzx_templates` is removed. You should import [`rzx_templates()`](/api/qiskit/transpiler_passes#qiskit.transpiler.passes.rzx_templates "qiskit.transpiler.passes.rzx_templates") from [`qiskit.transpiler.passes`](/api/qiskit/transpiler_passes#module-qiskit.transpiler.passes "qiskit.transpiler.passes") directly.

*   The minimum version required for symengine was bumped to >=0.11. This allows to simplify some code in [`ParameterExpression.is_real()`](/api/qiskit/qiskit.circuit.ParameterExpression#is_real "qiskit.circuit.ParameterExpression.is_real").

*   Added `BasePrimitiveJob` class as an abstract job class for Primitives and made `PrimitiveJob` inherit `BasePrimitiveJob` instead of [`JobV1`](/api/qiskit/qiskit.providers.JobV1 "qiskit.providers.JobV1").

*   A pattern for the pass piepline construction was upgraded. The syntactic sugar shown below for instantiation of flow controller was removed.

    ```python
    from qiskit.transpiler import PassManager

    pm = PassManager()
    pm.append(my_pass, condition=condition_callable, do_while=do_while_callable)
    ```

    Instead of using this keyword argument pattern, you should explicitly instantiate the flow controller.

    ```python
    from qiskit.passmanager.flow_controllers import ConditionalController, DoWhileController

    pm = PassManager()
    pm.append(
      ConditionalController(
        DoWhileController(my_pass, do_while=do_while_callable),
        condition=condition_callable,
      )
    )
    ```

    Note that you can manage the pecking order of controllers when you want to nest them, which was not possible with keyword arguments. You can also build the pipeline with the constructor of the pass manager like below because there is no reason to call the append method now.

    ```python
    pm = PassManager(
      ConditionalController(
        DoWhileController(my_pass, do_while=do_while_callable),
        condition=condition_callable,
      )
    )
    ```

*   The append method of built-in flow controllers was removed. This includes

    *   `ConditionalController.append()`
    *   `DoWhileController.append()`
    *   `FlowControllerLinear.append()`

    The task pipeline in a flow controller is frozen, and it must be passed when the controller instance is created.

*   Removed methods `qiskit.transpiler.PassManager.passes()` and `qiskit.transpiler.StagedPassManager.passes()` that generates a representation of inset passes in the form of list of dictionary, however, this format doesn’t efficiently represent more complicated pass pipeline, which may include conditional branching and nested conditions. Instead of using this representation, please use following pattern

    ```python
    pm = PassManager(...)
    pm.to_flow_controller().tasks
    ```

    This directly returns a linearized base task instances in tuple format.

*   The `max_iteration` argument was removed from [`qiskit.transpiler.PassManager.append()`](/api/qiskit/qiskit.transpiler.PassManager#append "qiskit.transpiler.PassManager.append") and [`qiskit.transpiler.PassManager.replace()`](/api/qiskit/qiskit.transpiler.PassManager#replace "qiskit.transpiler.PassManager.replace").

*   The following legacy classes were removed from the pass manager and transpiler module.

    *   `qiskit.passmanager.flow_controllers.FlowController`
    *   `qiskit.transpiler.fencedobjs.FencedObject`
    *   `qiskit.transpiler.fencedobjs.FencedPropertySet`
    *   `qiskit.transpiler.fencedobjs.FencedDAGCircuit`
    *   `qiskit.transpiler.runningpassmanager.RunningPassManager`

<span id="relnotes-1-0-0rc1-deprecation-notes" />

### Deprecation Notes

*   `PrimitiveJob.submit()` and `PrimitiveJob.wait_for_final_state()` are deprecated and will be removed in the future release.

<span id="relnotes-1-0-0rc1-bug-fixes" />

<span id="id2" />

### Bug Fixes

*   Fixed the return of improper measurement schedules in examples like the following:

    ```python
    # import a fake backend which is a sub-class of BackendV2.
    from qiskit.providers.fake_provider import FakePerth
    backend = FakePerth()
    sched = backend.instruction_schedule_map.get('measure', [0])
    ```

    This unexpectedly returned a measure schedule including all device qubits, when only one was requested. Now this code returns a schedule for qubit 0 as intended.

*   Fixed an issue in the `text` circuit drawer when displaying operations that were not [`circuit.instruction.Instruction`](/api/qiskit/qiskit.circuit.Instruction "qiskit.circuit.instruction.Instruction") class. These operations would cause the drawer to fail. Examples were [`Clifford`](/api/qiskit/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford") and [`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation").

*   Fixed an issue with the [`SetLayout`](/api/qiskit/qiskit.transpiler.passes.SetLayout "qiskit.transpiler.passes.SetLayout") transpiler pass where an invalid integer list input that contained duplicate entries which would result in an invalid [`Layout`](/api/qiskit/qiskit.transpiler.Layout "qiskit.transpiler.Layout") being generated and subsequent transpiler passes would fail with a cryptic error. This is now caught when [`SetLayout.run()`](/api/qiskit/qiskit.transpiler.passes.SetLayout#run "qiskit.transpiler.passes.SetLayout.run") is called an [`InvalidLayoutError`](/api/qiskit/transpiler#qiskit.transpiler.InvalidLayoutError "qiskit.transpiler.InvalidLayoutError") error will be raised indicating there are duplicate entries in the integer list.

*   QPY (using [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") and [`qpy.load()`](/api/qiskit/qpy#qiskit.qpy.load "qiskit.qpy.load")) will now correctly serialize and deserialize quantum circuits with annotated operations ([`AnnotatedOperation`](/api/qiskit/qiskit.circuit.AnnotatedOperation "qiskit.circuit.AnnotatedOperation")).

*   Calling [`copy()`](/api/qiskit/qiskit.circuit.QuantumCircuit#copy "qiskit.circuit.QuantumCircuit.copy") or [`copy_empty_like()`](/api/qiskit/qiskit.circuit.QuantumCircuit#copy_empty_like "qiskit.circuit.QuantumCircuit.copy_empty_like") on a `BlueprintCircuit` will now correctly propagate the [`global_phase`](/api/qiskit/qiskit.circuit.QuantumCircuit#global_phase "qiskit.circuit.QuantumCircuit.global_phase") to the copy. Previously, the global phase would always be zero after the copy.

*   [`QuantumCircuit.compose()`](/api/qiskit/qiskit.circuit.QuantumCircuit#compose "qiskit.circuit.QuantumCircuit.compose") will now correctly raise a [`CircuitError`](/api/qiskit/circuit#qiskit.circuit.CircuitError "qiskit.circuit.CircuitError") when there are duplicates in the `qubits` or `clbits` arguments.

*   QPY (using [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") and [`qpy.load()`](/api/qiskit/qpy#qiskit.qpy.load "qiskit.qpy.load")) will now correctly serialize and deserialize quantum circuits with Clifford operators ([`Clifford`](/api/qiskit/qiskit.quantum_info.Clifford "qiskit.quantum_info.Clifford")).

*   Fixed an issue in the `mpl` circuit drawer where the text would print beyond the end of the box for a [`SwitchCaseOp`](/api/qiskit/qiskit.circuit.SwitchCaseOp "qiskit.circuit.SwitchCaseOp") if the default case was empty.

*   The qubit-argument broadcasting of [`QuantumCircuit.delay()`](/api/qiskit/qiskit.circuit.QuantumCircuit#delay "qiskit.circuit.QuantumCircuit.delay") now correctly produces individual [`Delay`](/api/qiskit/qiskit.circuit.Delay "qiskit.circuit.Delay") instructions for each qubit, as intended. Previously, when given certain iterables (such as [`set`](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.12)")s), it would instead silently produce an invalid circuit that might fail in unusual locations.

*   Fixed an issue when using [`transpile()`](/api/qiskit/compiler#qiskit.compiler.transpile "qiskit.compiler.transpile") or running a preset pass manager (such as generated by [`generate_preset_pass_manager()`](/api/qiskit/transpiler_preset#qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager "qiskit.transpiler.preset_passmanagers.generate_preset_pass_manager")) when targeting a backend that has disjoint connectivity adding extra barriers to the output [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit"). In some cases several single qubit [`Barrier`](/api/qiskit/qiskit.circuit.library.Barrier "qiskit.circuit.library.Barrier") directives would be included in the output circuit right before any final measurements in the circuit. This was internal state generated by the internal processing for disjoint connectivity that was incorrectly being added into the output circuit. Fixed [#11649](https://github.com/Qiskit/qiskit/issues/11649)

*   Fixed a bug that results in an error when a user tries to load .calibration data of a gate in [`Target`](/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") in a particular situation. This occurs when the backend reports only partial calibration data, for example referencing a waveform pulse in a command definition but not including that waveform pulse in the pulse library. In this situation, the Qiskit pulse object cannot be built, resulting in a failure to build the pulse schedule for the calibration. Now when calibration data is incomplete the [`Target`](/api/qiskit/qiskit.transpiler.Target "qiskit.transpiler.Target") treats it as equivalent to no calibration being reported at all and does not raise an exception.

*   The [`Operator.power()`](/api/qiskit/qiskit.quantum_info.Operator#power "qiskit.quantum_info.Operator.power") method now works with floating-point exponents, matching the documented description.

*   Fixed an issue with the `OptimizeSwapBeforeMeasure` pass where it would incorrectly optimize circuits involving swap and measure instructions. This commit fixes the bug by changing `DAGCircuit.successors` to `DAGCircuit.descendants`. Also, added a couple of extra tests to ensure that the bug is fixed. For example:

    ```python
    from qiskit import QuantumCircuit
    from qiskit.transpiler.passes import OptimizeSwapBeforeMeasure
    pass_ = OptimizeSwapBeforeMeasure()
    qc = QuantumCircuit(2, 1)
    qc.swap(0, 1)
    qc.measure(0, 0)
    qc.measure(0, 0)
    print(qc.draw())
    print(pass_(qc).draw())
    ```

    would previously print:

    ```python
            ┌─┐┌─┐
    q_0: ─X─┤M├┤M├
          │ └╥┘└╥┘
    q_1: ─X──╫──╫─
             ║  ║
    c: 1/════╩══╩═
             0  0
         ┌─┐
    q_0: ┤M├───
         └╥┘┌─┐
    q_1: ─╫─┤M├
          ║ └╥┘
    c: 1/═╩══╩═
          0  0
    ```

    and now the second circuit is correctly optimized to:

    ```python
    q_0: ──────
         ┌─┐┌─┐
    q_1: ┤M├┤M├
         └╥┘└╥┘
    c: 1/═╩══╩═
          0  0
    ```

*   Fixed an issue with the QPY serialization when a [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") contained multiple custom instructions instances that have the same [`name`](/api/qiskit/qiskit.circuit.Instruction#name "qiskit.circuit.Instruction.name") attribute. In QPY format versions before [Version 11](/api/qiskit/qpy#qpy-version-11) the QPY payload did not differentiate between these instances and would only serialize the properties of the first instance in a circuit. This could potentially cause an incorrect deserialization if the other properties of the custom instruction were different but the names were the same. This has been fixed in QPY [Version 11](/api/qiskit/qpy#qpy-version-11) so that each instance of a custom instruction is serialized individually and there will no longer be a potential conflict with overlapping names. Fixes [#8941](https://github.com/Qiskit/qiskit/issues/8941)

*   Fix a bug in the [`StabilizerState`](/api/qiskit/qiskit.quantum_info.StabilizerState "qiskit.quantum_info.StabilizerState") string representation.

*   A bug where [`convert_to_target()`](/api/qiskit/qiskit.providers.convert_to_target "qiskit.providers.convert_to_target") of [`BackendV2Converter`](/api/qiskit/qiskit.providers.BackendV2Converter "qiskit.providers.BackendV2Converter") raised an unexpected error was solved. The bug occured when the backend to convert included calibrations for a gate that didn’t have a definition in the backend properties. Such gate is now broadcasted to all qubits as an ideal error-free instruction, even when calibrations for a finite set of qubits are reported.

*   [`InstructionDurations.from_backend()`](/api/qiskit/qiskit.transpiler.InstructionDurations#from_backend "qiskit.transpiler.InstructionDurations.from_backend") now returns an instance of any subclass of [`InstructionDurations`](/api/qiskit/qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") instead of the base class.

*   The [`UnitarySynthesis`](/api/qiskit/qiskit.transpiler.passes.UnitarySynthesis "qiskit.transpiler.passes.UnitarySynthesis") transpiler pass will now generate an error on initialization when a nonexistent sythesis plugin is specified, rather than waiting until runtime to raise. Fixed [#11355](https://github.com/Qiskit/qiskit/issues/11355).

*   The OpenQASM 3 exporters [`qasm3.dump()`](/api/qiskit/qasm3#qiskit.qasm3.dump "qiskit.qasm3.dump") and [`dumps()`](/api/qiskit/qasm3#qiskit.qasm3.dumps "qiskit.qasm3.dumps") will now correctly output files claiming to be version `3.0` rather than the unqualified `3`, since the OpenQASM 3 project has now standardised on versioning.

*   The parametric form of [`XXPlusYYGate`](/api/qiskit/qiskit.circuit.library.XXPlusYYGate "qiskit.circuit.library.XXPlusYYGate") and [`XXMinusYYGate`](/api/qiskit/qiskit.circuit.library.XXMinusYYGate "qiskit.circuit.library.XXMinusYYGate") returned from `get_standard_gate_name_mapping()` now correctly includes the $\beta$ parameter as well as the initial $\theta$ rotation.

*   The [`TemplateOptimization`](/api/qiskit/qiskit.transpiler.passes.TemplateOptimization "qiskit.transpiler.passes.TemplateOptimization") pass will now return parametric expressions using the native symbolic expression format of [`ParameterExpression`](/api/qiskit/qiskit.circuit.ParameterExpression "qiskit.circuit.ParameterExpression"), rather than always using Sympy. For most supported platforms, this means that the expressions will be Symengine objects. Previously, the pass could return mismatched objects, which could lead to later failures in parameter-handling code.

<span id="relnotes-unreleased-notes-preview-stable-0-46" />

<span id="id3" />

## Unreleased Notes Preview

<span id="relnotes-unreleased-notes-preview-stable-0-46-bug-fixes" />

<span id="id4" />

### Bug Fixes

*   Update properties and configuration information of [`FakeOpenPulse2Q`](/api/qiskit/qiskit.providers.fake_provider.FakeOpenPulse2Q "qiskit.providers.fake_provider.FakeOpenPulse2Q") backend. Missing gate properties were added for some gates defined in the pulse defaults so that the gates defined in the two locations were consistent.

*   [`InstructionDurations.from_backend()`](/api/qiskit/qiskit.transpiler.InstructionDurations#from_backend "qiskit.transpiler.InstructionDurations.from_backend") now returns an instance of any subclass of [`InstructionDurations`](/api/qiskit/qiskit.transpiler.InstructionDurations "qiskit.transpiler.InstructionDurations") instead of the base class.

<span id="relnotes-0-46-0-stable-0-46" />

<span id="id5" />
