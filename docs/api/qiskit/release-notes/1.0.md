---
title: Qiskit 1.0 release notes
description: New features and bug fixes
---
# Qiskit 1.0 release notes
  
## 1.0.1

<span id="relnotes-1-0-1-prelude" />

### Prelude

Qiskit 1.0.1 is a patch release fixing a small number of bugs identified in the Qiskit 1.0.0 release.

<span id="relnotes-1-0-1-bug-fixes" />

### Bug Fixes

*   Fixed a bug in the conversion of custom pulse instructions to the legacy [`qiskit.qobj`](/api/qiskit/qobj#module-qiskit.qobj "qiskit.qobj") format. The bug was introduced in Qiskit 1.0.0 and caused conversion of instructions with custom pulse shapes to raise an error. After the fix, the conversion is carried out correctly, and the custom pulse is converted to a `pulse.Waveform` as it should. Fixed [#11828](https://github.com/Qiskit/qiskit/issues/11828).

*   Fixed an issue in the [`InverseCancellation`](/api/qiskit/qiskit.transpiler.passes.InverseCancellation "qiskit.transpiler.passes.InverseCancellation") transpiler pass where in some cases it would incorrectly cancel a self-inverse parameterized gate even if the parameter value didn’t match. Fixed [#11815](https://github.com/Qiskit/qiskit/issues/11815).

*   [`BasePassManager.run()`](/api/qiskit/qiskit.passmanager.BasePassManager#run "qiskit.passmanager.BasePassManager.run") will no longer leak the previous [`PropertySet`](/api/qiskit/qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet") into new workflows when called more than once. Previously, the same [`PropertySet`](/api/qiskit/qiskit.passmanager.PropertySet "qiskit.passmanager.PropertySet") as before would be used to initialize follow-on runs, which could mean that invalid property information was being given to tasks. The behavior now matches that of Qiskit 0.44. Fixed [#11784](https://github.com/Qiskit/qiskit/issues/11784).

*   A bug has been fixed in `convert_durations_to_dt()` where the function assumed its inputs were all in seconds, rather than reading the actual unit. This could lead to wrong orders of magnitude in the reported circuit durations.

<span id="relnotes-1-0-0" />

<span id="id2" />

## 1.0.0

<span id="relnotes-1-0-0-prelude" />

<span id="id3" />

### Prelude

We are very pleased to release Qiskit 1.0.0. This release is the culmination of 7 years of development to mature Qiskit into a stable, high- performance SDK for quantum computing, and is the start of a new era for the Qiskit project and community. Besides general performance and stability improvements, the most significant changes with the 1.0.0 release relate to the stability policy, release cycles, and versioning. Qiskit is now formally using [semantic versioning](https://semver.org/), and this means that, for the entire lifecycle of the 1.x release series, the project is committed to maintaining backwards compatibility in its public documented APIs. We’re also now starting to offer bugfix support for major versions, so that you continue to have a supported branch for 6 months after the release of the next major version. This starts now with the 1.x and 0.x major series: the 0.46.x release will continue to be supported, with periodic patch releases that contain bug fixes, for 6 months after the release of 1.0. That is, 0.46.x will be supported until 2024-08. You can see the full details of the new policy here:

[start/install#qiskit-versioning](/start/install#qiskit-versioning)

Also of key importance in this release is the change in packaging. Since the Qiskit 0.7 release in 2018-12, when Qiskit introduced its [elements](https://medium.com/qiskit/qiskit-and-its-fundamental-elements-bcd7ead80492) model, the `qiskit` package you would install has been a meta-package (or package of packages) that installs the combined elements comprising Qiskit. As announced in previous releases (for more details see the [0.44.0](/api/qiskit/release-notes/0.44#0440), [0.45.3](/api/qiskit/release-notes/0.45#prelude), and [0.46.0](/api/qiskit/release-notes/0.46#prelude) release notes, along with this [blog post](https://research.ibm.com/blog/qiskit-application-modules)) with the 1.0 release we’re completing a transition to have a single `qiskit` package exposing only the core SDK (what was previously `qiskit-terra`). This means that for releases >= 1.0.0, we have stopped using the `qiskit-terra` package and will only be publishing `qiskit`. As this change in packaging structure is not fully supported by the Python package installer `pip`, it is not possible to just use `pip install -U qiskit` to upgrade from qiskit 0.46.0 to 1.0.0. It is strongly recommended that to upgrade to Qiskit 1.0.0 you create a separate virtual environment to isolate the installation. There is a detailed migration guide that explains the packaging changes and how to install Qiskit 1.0.0 in different scenarios which can be found here:

[https://qisk.it/1-0-packaging-migration](https://qisk.it/1-0-packaging-migration)

As with all of our major releases, Qiskit 1.0.0 also has a plethora of new features, the highlights for this release are:

> *   The [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") class’s internal [`data`](/api/qiskit/qiskit.circuit.QuantumCircuit#data "qiskit.circuit.QuantumCircuit.data") structure has been rewritten in Rust to greatly improve the memory efficiency of the [`QuantumCircuit`](/api/qiskit/qiskit.circuit.QuantumCircuit "qiskit.circuit.QuantumCircuit") objects by caching the arguments of the instructions.
> *   A new version of the primitives interface definition in [`qiskit.primitives`](/api/qiskit/primitives#module-qiskit.primitives "qiskit.primitives") with the [`BaseSamplerV2`](/api/qiskit/qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2") and [`BaseEstimatorV2`](/api/qiskit/qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") abstract classes. This new version of the interface adds support for performing vectorized calls to the primitive so that sweeps over parameter value sets and observables can be efficiently specified.
> *   A new experimental native OpenQASM 3 parser [`qiskit.qasm3.loads_experimental()`](/api/qiskit/qasm3#qiskit.qasm3.loads_experimental "qiskit.qasm3.loads_experimental") and [`qiskit.qasm3.load_experimental()`](/api/qiskit/qasm3#qiskit.qasm3.load_experimental "qiskit.qasm3.load_experimental"). This new parser is still under development and still has several limitations and is still experimental. However, for where it is usable, the new parser is significantly faster and has better diagnostic error message that allows to debug where an OpenQASM 3 program is invalid. This new parser is written in Rust and based on a newly developed Rust library for parsing OpenQASM3 which can be found here: [https://github.com/Qiskit/openqasm3\_parser](https://github.com/Qiskit/openqasm3_parser)

Finally, the Qiskit 1.0.0 release was an opportunity to clean up some technical debt accumulated over the past 7 years of development. You’ll notice that the Qiskit 1.0.0 release is virtually free of `DeprecationWarning`s being emitted, and, at the same time, the upgrade section of the 1.0.0 release notes is longer than usual. These are direct consequences of the technical debt cleanup. To help with the migration from 0.46.x to 1.0.0, besides the release notes, we have also published a dedicated migration guide which can be found here:

[api/migration-guides/qiskit-1.0-features](/api/migration-guides/qiskit-1.0-features)

This guide is meant to complement the release notes and have a targeted advice for how to migrate the API changes after the removal of the deprecated functionality from the 0.46.0 release.

<span id="relnotes-1-0-0-primitives-features" />

### Primitives Features

*   Version 2 of the primitives is introduced via a new base class for both the sampler and the estimator, along with new types for their inputs and outputs. The emphasis of this new version is on performing vectorized calls to the primitive `run()` methods, so that sweeps over parameter value sets and observables can be efficiently specified. See [`StatevectorSampler`](/api/qiskit/qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler") and [`StatevectorEstimator`](/api/qiskit/qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") for reference implementations of the V2 primitives.

    Moreover, the estimator has gained a `precision` argument in the [`run()`](/api/qiskit/qiskit.primitives.BaseEstimatorV2#run "qiskit.primitives.BaseEstimatorV2.run") method that specifies the targeted precision of the expectation value estimates. Analogously, the sampler has moved `shots` out of the options and into the arguments of the [`run()`](/api/qiskit/qiskit.primitives.BaseSamplerV2#run "qiskit.primitives.BaseSamplerV2.run") method. The sampler has also been changed to return the outputs (e.g. bitstrings) from every shot, rather than providing a [`Counts`](/api/qiskit/qiskit.result.Counts "qiskit.result.Counts")-like return, and also to store data from separate [`ClassicalRegister`](/api/qiskit/qiskit.circuit.ClassicalRegister "qiskit.circuit.ClassicalRegister")s . This enables derived classes to implement sampler support for circuits with classical control flow.

    The primitive V2 base classes are:

    *   [`BaseSamplerV2`](/api/qiskit/qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2")
    *   [`BaseEstimatorV2`](/api/qiskit/qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2")

    The new types which are used for inputs and outputs are:

    *   `SamplerPubLike`: primitive unified bloc (PUB) of sampler inputs; a union type of allowed inputs to a sampler
    *   `EstimatorPubLike`: Primitive unified bloc (PUB) of estimator inputs; a union type of allowed inputs to an estimator
    *   [`PubResult`](/api/qiskit/qiskit.primitives.PubResult "qiskit.primitives.PubResult"): the data and metadata resulting from a single PUB’s execution
    *   [`DataBin`](/api/qiskit/qiskit.primitives.DataBin "qiskit.primitives.DataBin"): A namespace to hold data from a single PUB’s execution
    *   [`BitArray`](/api/qiskit/qiskit.primitives.BitArray "qiskit.primitives.BitArray"): an array-valued collection of bit values in a dense format
    *   [`PrimitiveResult`](/api/qiskit/qiskit.primitives.PrimitiveResult "qiskit.primitives.PrimitiveResult"): an iterable of [`PubResult`](/api/qiskit/qiskit.primitives.PubResult "qiskit.primitives.PubResult")s along with metadata

*   The reference implementation [`StatevectorEstimator`](/api/qiskit/qiskit.primitives.StatevectorEstimator "qiskit.primitives.StatevectorEstimator") of [`BaseEstimatorV2`](/api/qiskit/qiskit.primitives.BaseEstimatorV2 "qiskit.primitives.BaseEstimatorV2") was added. As seen in the example below, this estimator (and all V2 estimators) supports providing arrays of observables and/or arrays of parameter value sets that are attached to particular circuits.

    Each tuple of `(circuit, observables, <optional> parameter values, <optional> precision)`, called an estimator primitive unified bloc (PUB), produces its own array-based result. The `run()` method can be given many pubs at once.

    ```python
    from qiskit.circuit import Parameter, QuantumCircuit
    from qiskit.primitives import StatevectorEstimator
    from qiskit.quantum_info import Pauli, SparsePauliOp

    import matplotlib.pyplot as plt
    import numpy as np

    # Define a circuit with two parameters.
    circuit = QuantumCircuit(2)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.ry(Parameter("a"), 0)
    circuit.rz(Parameter("b"), 0)
    circuit.cx(0, 1)
    circuit.h(0)

    # Define a sweep over parameter values, where the second axis is over
    # the two parameters in the circuit.
    params = np.vstack([
        np.linspace(-np.pi, np.pi, 100),
        np.linspace(-4 * np.pi, 4 * np.pi, 100)
    ]).T

    # Define three observables. Many formats are supported here including
    # classes such as qiskit.quantum_info.SparsePauliOp. The inner length-1
    # lists cause this array of observables to have shape (3, 1), rather
    # than shape (3,) if they were omitted.
    observables = [
        [SparsePauliOp(["XX", "IY"], [0.5, 0.5])],
        [Pauli("XX")],
        [Pauli("IY")]
    ]

    # Instantiate a new statevector simulation based estimator object.
    estimator = StatevectorEstimator()

    # Estimate the expectation value for all 300 combinations of
    # observables and parameter values, where the pub result will have
    # shape (3, 100). This shape is due to our array of parameter
    # bindings having shape (100,), combined with our array of observables
    # having shape (3, 1)
    pub = (circuit, observables, params)
    job = estimator.run([pub])

    # Extract the result for the 0th pub (this example only has one pub).
    result = job.result()[0]

    # Error-bar information is also available, but the error is 0
    # for this StatevectorEstimator.
    result.data.stds

    # Pull out the array-based expectation value estimate data from the
    # result and plot a trace for each observable.
    for idx, pauli in enumerate(observables):
        plt.plot(result.data.evs[idx], label=pauli)
    plt.legend()
    ```

*   The reference implementation [`StatevectorSampler`](/api/qiskit/qiskit.primitives.StatevectorSampler "qiskit.primitives.StatevectorSampler") of [`BaseSamplerV2`](/api/qiskit/qiskit.primitives.BaseSamplerV2 "qiskit.primitives.BaseSamplerV2") was added. As seen in the example below, this sampler (and all V2 samplers) supports providing arrays of parameter value sets to bind against a single circuit.

    Each tuple of `(circuit, <optional> parameter values, <optional> shots)`, called a sampler primitive unified bloc (PUB), produces its own array-based result. The `run()` method can be given many pubs at once.

    ```python
    from qiskit.circuit import (
        Parameter, QuantumCircuit, ClassicalRegister, QuantumRegister
    )
    from qiskit.primitives import StatevectorSampler

    import matplotlib.pyplot as plt
    import numpy as np

    # Define our circuit registers, including classical registers
    # called 'alpha' and 'beta'.
    qreg = QuantumRegister(3)
    alpha = ClassicalRegister(2, "alpha")
    beta = ClassicalRegister(1, "beta")

    # Define a quantum circuit with two parameters.
    circuit = QuantumCircuit(qreg, alpha, beta)
    circuit.h(0)
    circuit.cx(0, 1)
    circuit.cx(1, 2)
    circuit.ry(Parameter("a"), 0)
    circuit.rz(Parameter("b"), 0)
    circuit.cx(1, 2)
    circuit.cx(0, 1)
    circuit.h(0)
    circuit.measure([0, 1], alpha)
    circuit.measure([2], beta)

    # Define a sweep over parameter values, where the second axis is over.
    # the two parameters in the circuit.
    params = np.vstack([
        np.linspace(-np.pi, np.pi, 100),
        np.linspace(-4 * np.pi, 4 * np.pi, 100)
    ]).T

    # Instantiate a new statevector simulation based sampler object.
    sampler = StatevectorSampler()

    # Start a job that will return shots for all 100 parameter value sets.
    pub = (circuit, params)
    job = sampler.run([pub], shots=256)

    # Extract the result for the 0th pub (this example only has one pub).
    result = job.result()[0]

    # There is one BitArray object for each ClassicalRegister in the
    # circuit. Here, we can see that the BitArray for alpha contains data
    # for all 100 sweep points, and that it is indeed storing data for 2
    # bits over 256 shots.
    assert result.data.alpha.shape == (100,)
    assert result.data.alpha.num_bits == 2
    assert result.data.alpha.num_shots == 256

    # We can work directly with a binary array in performant applications.
    raw = result.data.alpha.array

    # For small registers where it is anticipated to have many counts
    # associated with the same bitstrings, we can turn the data from,
    # for example, the 22nd sweep index into a dictionary of counts.
    counts = result.data.alpha.get_counts(22)

    # Or, convert into a list of bitstrings that preserve shot order.
    bitstrings = result.data.alpha.get_bitstrings(22)
    print(bitstrings)
    ```

<span id="relnotes-1-0-0-providers-upgrade-notes" />

### Providers Upgrade Notes

*   The deprecated [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") module has been migrated to the `qiskit-ibm-runtime` Python package. For this reason, the following elements in the [`qiskit.providers.fake_provider`](/api/qiskit/providers_fake_provider#module-qiskit.providers.fake_provider "qiskit.providers.fake_provider") have been removed following their deprecation in Qiskit 0.46:

    > *   `qiskit.providers.fake_provider.FakeProvider`
    > *   `qiskit.providers.fake_provider.FakeProviderForBackendV2`
    > *   `qiskit.providers.fake_provider.FakeProviderFactory`
    > *   `qiskit.providers.fake_provider.fake_backends.FakeBackendV2`
    > *   any fake backend contained in `qiskit.providers.fake_provider.backends` (accessible through the provider)
    > *   `qiskit.providers.fake_provider.FakeQasmSimulator`
    > *   `qiskit.providers.fake_provider.FakeJob`
    > *   `qiskit.providers.fake_provider.FakeQobj`

    To use the new fake provider module, you can run `pip install qiskit-ibm-runtime` and replace the qiskit import path (`qiskit.providers.fake_provider`) with the new import path (`qiskit_ibm_runtime.fake_provider`). Migration example:

    ```python
    # Legacy path
    from qiskit.providers.fake_provider import FakeProvider, FakeSherbrooke
    backend1 = FakeProvider().get_backend("fake_ourense")
    backend2 = FakeSherbrooke()

    # New path
    # run "pip install qiskit-ibm-runtime"
    from qiskit_ibm_runtime.fake_provider import FakeProvider, FakeSherbrooke
    backend1 = FakeProvider().get_backend("fake_ourense")
    backend2 = FakeSherbrooke()
    ```

    Additionally, the following fake backends designed for special testing purposes have been superseded by the new [`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") class, and are also removed following their deprecation in Qiskit 0.46:

    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2`
    > *   `` `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendV2LegacyQubitProps ``
    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackend5QV2`
    > *   `qiskit.providers.fake_provider.fake_backend_v2.FakeBackendSimple`

    Migration example to the new [`GenericBackendV2`](/api/qiskit/qiskit.providers.fake_provider.GenericBackendV2 "qiskit.providers.fake_provider.GenericBackendV2") class:

    ```python
    # Legacy path
    from qiskit.providers.fake_provider import FakeBackend5QV2
    backend = FakeBackend5QV2()

    # New path
    from qiskit.providers.fake_provider import GenericBackendV2
    backend = GenericBackendV2(num_qubits=5)
    # note that this class will generate 5q backend with generic
    # properties that serves the same purpose as FakeBackend5QV2
    # but will generate different results
    ```

<span id="relnotes-1-0-0-bug-fixes" />

<span id="id4" />

### Bug Fixes

*   Fixed an issue with the [`qpy.dump()`](/api/qiskit/qpy#qiskit.qpy.dump "qiskit.qpy.dump") function where, when the `use_symengine` flag was set to a truthy object that evaluated to `True` but was not actually the boolean `True`, the generated QPY payload would be corrupt. For example, if you set `use_symengine` to [`HAS_SYMENGINE`](/api/qiskit/utils#qiskit.utils.optionals.HAS_SYMENGINE "qiskit.utils.optionals.HAS_SYMENGINE"), this object evaluates to `True` when cast as a bool, but isn’t actually `True`.

*   Fixed an issue with the [`circuit_drawer()`](/api/qiskit/qiskit.visualization.circuit_drawer "qiskit.visualization.circuit_drawer") function and [`QuantumCircuit.draw()`](/api/qiskit/qiskit.circuit.QuantumCircuit#draw "qiskit.circuit.QuantumCircuit.draw") method when loading a matplotlib style via the user configuration file.

