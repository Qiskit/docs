---
title: What are primitives?
description: Introduction to primitives in Qiskit and Qiskit Runtime, and an explanation of available primitives

---

# What are primitives?


In computing, a primitive is the smallest processing instruction for a given abstraction level. Put simply, they are the simplest building blocks from which a user can create something useful - and since primitives abstract away implementation details, users can accomplish tasks without needing to worry about low-level specifics.  The computational model proposed by primitives moves quantum programming one step closer to where classical programming is today, where the focus is less on the hardware details and more on the results you are trying to achieve. With this in mind, Qiskit has introduced its first two primitives: Estimator and Sampler.

## Estimator

The Estimator primitive computes expectation values of observables with respect to states prepared by quantum circuits. Users generally specify a list of circuits, observables, and possibly some additional configuration, with which the program can efficiently evaluate expectation values and variances.

## Sampler 

The Sampler primitive calculates probabilities or quasi-probability distributions of bitstrings from quantum circuits. Quasi-probability distributions are similar to regular probabilities, except they may include negative values, which can occur when using certain error mitigation techniques.

Primitives work most effectively when they are supported by both Qiskit and the backend provider. The Qiskit module `qiskit.primitives` provides the required support on the Qiskit side, and providers like IBM’s Qiskit Runtime enable access to appropriate backends through native implementations of their own primitives.

## Benefits of Qiskit primitives

For Qiskit users, primitives allow you to write quantum code for a specific backend without having to explicitly manage every detail. In addition, because of the additional layer of abstraction, you may be able to more easily access advanced hardware capabilities of a given provider. For example, with Qiskit Runtime primitives, you can leverage the latest advancements in error mitigation and suppression by toggling options such as `optimization_level` and `resilience_level`, rather than building your own implementation of these techniques.

For hardware providers, implementing primitives natively means you can provide your users with a more “out-of-the-box” way to access your hardware features. It is therefore easier for your users to benefit from your hardware's best capabilities.

## How to use Qiskit primitives

The `qiskit.primitives` module enables the development of primitive-style quantum programs and was specifically designed to simplify switching between different types of backends. The module provides three separate classes for each primitive type: 

1. `Sampler` and `Estimator`

These classes are reference implementations of both primitives and use Qiskit’s built-in simulator. They leverage Qiskit’s `quantum_info` module in the background, producing results based on ideal statevector simulations.

2. `BaseSampler` and `BaseEstimator`

These are abstract base classes that define a common interface for implementing primitives. All other classes in the `qiskit.primitives` module inherit from these base classes, and developers should use these if they are interested in developing their own primitives-based execution model for a specific backend provider. These classes may also be useful for those who want to do highly customized processing and find the existing primitives implementations too simple for their needs.

3. `BackendSampler` and `BackendEstimator`

If a provider does not support primitives natively, you can use these classes to “wrap” any backend into a primitive. Users can write primitive-style code for providers that don’t yet have a primitives-based interface. These classes can be used just like the regular Sampler and Estimator, except they should be initialized with an additional backend argument for selecting which backend to run on.

## Next steps

<Admonition type="tip" title="Recommendations">
    - Review detailed [primitives examples.](primitives-examples)
    - Practice with primitives by working through the [Cost function lesson](https://learning.quantum-computing.ibm.com/course/variational-algorithm-design/cost-functions#primitives) in IBM Quantum Learning.
</Admonition>