---
title: Introduction to the transpiler
description: Introduction to the transpiler

---


# Introduction to the transpiler

Transpilation is the process of rewriting a given input circuit to match the topology of a specific quantum device and optimize the circuit instructions for execution on present-day noisy quantum systems.  

A central component of Qiskit, the transpiler is designed for modularity and extensibility. The goal is to be able to easily write new circuit transformations (known as transpiler **passes**), and combine them with other existing passes.  Which passes are chained together and in which order has a major effect on the final outcome. This pipeline is determined by a **pass manager**, which schedules the passes and also allows passes to communicate with each other by providing a shared space. In this way, the transpiler opens up the door for research into aggressive optimization of quantum circuits.

This documentation covers the tooling and workflows available to Qiskit users.  If you're using primitives and are only interested in st using the default transpilation options, look to the section [Configure error suppression for Qiskit Runtime.](../run/configure-runtime-compilation)



## Default Transpilation
The basic usage of the transpiler is to call the `qiskit.compiler.transpile()`](../api/qiskit/qiskit.compiler) function.  This will generate one of the present `PassManager`s based on, among other options, an `optimization_level` flag which can be set to either 0, 1, 2, or 3.  Higher levels generate more optimized circuits, at the expense of longer transpilation times.  Each of these preset `PassMangers` are composed of six basic stages:

1. `init` - This pass runs any initial passes that are required before we start embedding the circuit to the backend.  This typically involves unrolling custom instructions and converting the circuit to all single- and two-qubit gates.
1. `layout` - This pass applies a *layout*, mapping/assigning the virtual qubits in your circuit to the physical qubits of a backend.
1. `routing` - This pass runs after a layout has been applied and will inject gates (i.e., SWAPs) in the original circuit in order to make it compatible with the backend's connectivity/coupling map.
1. `translation` - This pass translates the gates in the circuit to the backend's basis set of instructions.
1. `optimization` - This pass runs an optimization loop to find more efficient decompositions of your quantum circuit until a condition is met (such as a fixed depth).
1. `scheduling` - This pass is for any hardware-aware optimizations that improve the efficiency of the executed microwave pulse instructions.

Each of the preset pass managers include these steps and the primary difference between them are the specific that are called at each stage, set by the `optimization_level` flag.

## Customizing Passes
For more advanced users, one can customize their own set of `PassManager` objects and determine the ordering in which each stage is run.  This can dramatically change the final circuit which is output. If fact, oftentimes a bespoke approach to transpiling one's quantum algorithm produces more efficient error suppression than the default approach.  This involves rewriting quantum circuits to match hardware constraints and suppressing the effects of noise.  The flow of logic for this tool chain is quite customizable and need not be linear.  One can prepare iterative loops, conditional branches, and other complex behaviors.  A good starting place when developing your own set of passes is by looking to the default sequence of transformations:

