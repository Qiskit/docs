---
title: Transpilation passes beyond the standard set
description: Passes not included in the transpiler default optimization levels.

---

Many transpiler passes within Qiskit are optional and not executed in any of the default `optimization_level`s. In some cases, they can take the place of default passes within those stages, others can be written outside of Qiskit and executed as plugins (**provide links for both**). Here we introduce a pass, `PadDynamicalDecoupling` that adds an error suppression technique called dynamical decoupling to the circuit. Because this pass only operates on scheduled circuits and involves gates that are not necessarily basis gates of our `target`, we will need the `ALAPScheduleAnalysis` and `BasisTranslator` passes as well.

First, import necessary libraries for building a circuit and working with passes. In particular, the `PassManager` is how we manage custom passes.

```python
    from qiskit import transpile
    from qiskit.circuit.library import EfficientSU2, XGate, YGate

    from qiskit.providers.fake_provider import FakeSherbrooke
    from qiskit.transpiler import PassManager, InstructionProperties
    from qiskit.transpiler.passes import BasisTranslator
    from qiskit.transpiler.passes.scheduling import ALAPScheduleAnalysis, PadDynamicalDecoupling

    import numpy as np
```

We will work with the backend `FakeSherbrooke`. We get the `target` information from the `backend` and save the operation names as `basis_gates`, because we will need to modify the `target` to add timing information for the gates used in dynamical decoupling.

```python
    backend = FakeSherbrooke()

    target = backend.target
    basis_gates = list(target.operation_names)
```

We first build an ansatz circuit we will work with for this example. Dynamical decoupling often works best when there is a lot of idle time in the quantum circuits, i.e. has qubits that are not being operated while others are active. We can see this is the case in this circuit because the two-qubit `ecr` gates are applied sequentially in this ansatz.

```python
    qc = EfficientSU2(12, entanglement='circular', reps=1)
    qc_t = transpile(qc, target=target, seed_transpiler=12345)
    qc_t.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```
![Ansatz transpiled to `FakeSherbrooke`](/images/transpile/custom_passes/qc_transpiled.png)

A dynamical decoupling sequence is a series of gates that compose to the identity and are spaced regularly in time. They suppress decoherence by changing the effect of noise channels by flipping the qubits around the Bloch sphere (for a thorough description, see https://arxiv.org/abs/1904.06560). These are similar to refocusing pulses used in nuclear magnetic resonance. Here we'll create a simple sequence called XY4 consisting of four gates.

```python
    X = XGate()
    Y = YGate()

    dd_sequence = list((X, Y, X, Y))
```

Because of the regular timing of dynamical decoupling sequences, we must add information about the `YGate` to the `target` because it is *not* a basis gate, whereas the `XGate` is. We know *a priori* that the `YGate` has the same duration and error as the `XGate`, however, so we can just retrieve those properties from the `target` and add them back for the `YGates`s. This is also why we needed to save the `basis_gates` separately, since we are adding the `YGate` instruction to the `target` although it is not an actual basis gate of `FakeSherbrooke`.

```python
    y_gate_properties = {}
    for qubit in range(target.num_qubits):        
        y_gate_properties.update({
            (qubit,): InstructionProperties(
                duration = target['x'][(qubit,)].duration,
                error = target['x'][(qubit,)].error)})

    target.add_instruction(YGate(), y_gate_properties)
```

Ansatz circuits such as `EfficientSU2` are parameterized so they much have value bound to them before being sent to the actual backend. Here we use `.assign_parameters` to attach random values generated by `numpy.random`.
```python
    qc_t.assign_parameters(np.random.uniform(-np.pi, np.pi, qc_t.num_parameters), inplace=True)
```

Now it is time to execute the custom passes. We instantiate the `PassManager` with `ALAPScheduleAnalysis` and `PadDynamicalDecoupling`. `ALAPScheduleAnalysis` must be run first because the scheduling must occur, which adds timing information about the quantum circuit, before the regularly-spaced dynamical decoupliong sequences can be added. These passes are run on the circuit with `.run()`.
```python
    pm = PassManager([
        ALAPScheduleAnalysis(target=target),
        PadDynamicalDecoupling(target=target, dd_sequence=dd_sequence),
        ])
    qc_dd = pm.run(qc_t)
```

We can use the visualization tool `timeline_drawer` to see the timing of the circuit, and confirm that indeed a regularly-spaced sequence of `XGate`s and `YGate`s appear in the circuit.
```python
    from qiskit.visualization import timeline_drawer

    timeline_drawer(qc_dd, show_idle=False)
```
![Description](/images/transpile/custom_passes/timeline_dd.png)

Lastly, because the `YGate` is not an actual basis gate of our backend, we must manually apply the `BasisTranslator` pass (this *is* a default pass, but one that is executed before scheduling, so we need to apply it again). The session equivalence library is a library of circuit equivalences that allows the transpiler to decompose circuits into basis gates, as also specified as an argument.
```python
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    qc_dd = BasisTranslator(sel, basis_gates)(qc_dd)
    qc_dd.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```
![Description](/images/transpile/custom_passes/qc_dd_basis.png)

We can see the absence of `YGate`s in our circuit, and we have explicit timing information in the form of `Delay` gates. This transpiled circuit with dynamical decoupling can now be sent to the backend.


