---
title: Transpilation passes beyond the standard set
description: Passes not included in the transpiler default optimization levels.

---
# Custom passes 

Many transpiler passes within Qiskit are optional and are not executed in any of the default optimization levels. In some cases, they can take the place of default passes within those stages. Others can be written outside of Qiskit and executed as plugins. Here we introduce a pass, `PadDynamicalDecoupling`, that adds an error suppression technique called _dynamical decoupling_ to the circuit. Because this pass only operates on scheduled circuits and involves gates that are not necessarily basis gates of our `target`, we will need the `ALAPScheduleAnalysis` and `BasisTranslator` passes as well.

First, import necessary libraries for building a circuit and working with passes. In particular, the `PassManager` is how we manage custom passes:

```python
    from qiskit import transpile
    from qiskit.circuit.library import EfficientSU2, XGate, YGate

    from qiskit.providers.fake_provider import FakeSherbrooke
    from qiskit.transpiler import PassManager, InstructionProperties
    from qiskit.transpiler.passes import BasisTranslator
    from qiskit.transpiler.passes.scheduling import ALAPScheduleAnalysis, PadDynamicalDecoupling

    import numpy as np
```

We will work with the backend `FakeSherbrooke`. We get the `target` information from the `backend` and save the operation names as `basis_gates` because we will need to modify the `target` to add timing information for the gates used in dynamical decoupling.

```python
    backend = FakeSherbrooke()

    target = backend.target
    basis_gates = list(target.operation_names)
```

Build an ansatz circuit to work with. Dynamical decoupling often works best when there is a lot of idle time in the quantum circuits. That is, there are qubits that are not being used while others are active. We can see this is the case in this circuit because the two-qubit `ecr` gates are applied sequentially in this ansatz.

```python
    qc = EfficientSU2(12, entanglement='circular', reps=1)
    qc_t = transpile(qc, target=target, seed_transpiler=12345)
    qc_t.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```
![Ansatz transpiled to `FakeSherbrooke`](/images/transpile/custom_passes/qc_transpiled.png)

A _dynamical decoupling sequence_ is a series of gates that compose to the identity and are spaced regularly in time. They flip the qubits around the Bloch sphere which changes the effect of noise channels, therefore suppressing decoherence. For a full description, see [A Quantum Engineer's Guide to Superconducting Qubits](https://arxiv.org/abs/1904.06560). These are similar to refocusing pulses used in nuclear magnetic resonance. Here we'll create a simple sequence called XY4 consisting of four gates.

```python
    X = XGate()
    Y = YGate()

    dd_sequence = list((X, Y, X, Y))
```

Because of the regular timing of dynamical decoupling sequences, we must add information about the `YGate` to the `target` because it is *not* a basis gate, whereas the `XGate` is. We know *a priori* that the `YGate` has the same duration and error as the `XGate`, however, so we can just retrieve those properties from the `target` and add them back for the `YGates`s. This is also why we needed to save the `basis_gates` separately, since we are adding the `YGate` instruction to the `target` although it is not an actual basis gate of `FakeSherbrooke`.

```python
    y_gate_properties = {}
    for qubit in range(target.num_qubits):        
        y_gate_properties.update({
            (qubit,): InstructionProperties(
                duration = target['x'][(qubit,)].duration,
                error = target['x'][(qubit,)].error)})

    target.add_instruction(YGate(), y_gate_properties)
```

Ansatz circuits such as `EfficientSU2` are parameterized, so they much have value bound to them before being sent to the backend. Here we use `.assign_parameters` to attach random values generated by `numpy.random`.

```python
    qc_t.assign_parameters(np.random.uniform(-np.pi, np.pi, qc_t.num_parameters), inplace=True)
```

Next, we execute the custom passes. We instantiate the `PassManager` with `ALAPScheduleAnalysis` and `PadDynamicalDecoupling`.  We must run `ALAPScheduleAnalysis` first to add timing information about the quantum circuit before the regularly-spaced dynamical decoupliong sequences can be added. These passes are run on the circuit with `.run()`.

```python
    pm = PassManager([
        ALAPScheduleAnalysis(target=target),
        PadDynamicalDecoupling(target=target, dd_sequence=dd_sequence),
        ])
    qc_dd = pm.run(qc_t)
```

We can use the visualization tool `timeline_drawer` to see the circuit's timing and confirm that a regularly-spaced sequence of `XGate`s and `YGate`s appear in the circuit.

```python
    from qiskit.visualization import timeline_drawer

    timeline_drawer(qc_dd, show_idle=False)
```
![Description](/images/transpile/custom_passes/timeline_dd.png)

Last, because the `YGate` is not an actual basis gate of our backend, we must manually apply the `BasisTranslator` pass (this is a default pass, but it is executed before scheduling, so we need to apply it again). The session equivalence library is a library of circuit equivalences that allows the transpiler to decompose circuits into basis gates, as also specified as an argument.

```python
    from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel

    qc_dd = BasisTranslator(sel, basis_gates)(qc_dd)
    qc_dd.draw('mpl', style='iqp', fold=-1, idle_wires=False)
```
![Description](/images/transpile/custom_passes/qc_dd_basis.png)

We can see the absence of `YGate`s in our circuit, and we have explicit timing information in the form of `Delay` gates. This transpiled circuit with dynamical decoupling can now be sent to the backend.


