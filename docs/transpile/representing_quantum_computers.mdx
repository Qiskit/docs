---
title: Representing quantum computers
description: The necessary backend information for successfully transpiling quantum circuits

---

# Representing quantum computers

To construct an equivalent circuit that can run on a specific backend, the transpiler needs certain details about the backend.  Typically, this information is found in the `backend` or `target = backend.target` class, so you don't need to pass anything further to the transpiler. (TODO: check with Matthew about how this is moving, seems there is no `target` attribute for older `Backend` classes). However, if more infomation is provided, the transpiler can use it to try to produce the best circuit to run on that hardware.  

<Admonition type="note">
Because many of the underlying transpilation algorithms are stochastic, there is no guarantee that a better circuit will be found. 
</Admonition>

<span id="default-config"></span>
## Default configuration

The simplest use of the transpiler is to provide all the backend infomation by providing the `backend` or `target` (TODO: only available on newer backends?). To better understand how the transpiler works, construct a circuit and transpile it with different information:

Import the necessary libraries and instantiate the backend:

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    target = backend.target
```

Construct a 12-qubit circuit with circular entanglement:

```python
    qc = QuantumCircuit(12)
    qc.h(0)
    _ = [qc.cx(idx, idx+1) for idx in range(11)]
    qc.cx(11, 0)
    qc.draw('mpl')
```
![The 12-qubit test circuit](/images/transpile/representing_quantum_computers/qc-circular.png)

Transpile the circuit with the simplest options. This example uses `optimization_level=2` to highlight a feature:

```python
    qc_t_target = transpile(qc, target=target, optimization_level=2, seed_transpiler=12345)
    qc_t_target.draw('mpl', style='iqp', idle_wires=False)
```
![The transpiled 12-qubit test circuit using Target information](/images/transpile/representing_quantum_computers/qc_t_target.png)

This example is used in later sections of this topic to illustrate that the coupling map and basis gates are the essential pieces of information to pass to the transpiler for optimal circuit construction. The backend can usually select default settings for other information that is not passed in, such as timing and scheduling. (TODO: check!) 

Providing the backend properties, including the gates' error rates, allows the transpiler to select the best set of qubits on the backend.

## Coupling Map

The coupling map is a graph that specifies which qubits are connected and hence have 2-qubit gates between them. Sometimes this graph is directional, meaning that the 2-qubit gates can only go in one direction. However, the transpiler can always flip a gate's direction by adding additional 1-qubit gates. An abstract quantum circuit can always be represented on this graph, even if its connectivity is limited, by introducting SWAP gates to move the quantum information around. 

The qubits from our abstract circuits are called _virtual qubits_ and those on the coupling map are _physical qubits_. The transpiler provides a mapping between virtual and physical qubits. One of the first steps in transpilation, the _routing_ stage, performs this mapping.

<Admonition type="note">
Although the routing stage it intertwined with the _layout_ stage, which selects the actual qubits, we will consider them as separate stages for simplicity. The combination of routing and layout is called _qubit mapping_. (TODO: insert link to page explaining transpile stages.  Also link to learn more about qubit mapping?) 
</Admonition>

Pass the `coupling_map` keyword argument to see its effect on the transpiler:

```python
    coupling_map = target.build_coupling_map()
    # coupling_map = backend.configuration().coupling_map

    qc_t_cm_lv0 = transpile(qc, coupling_map=coupling_map, optimization_level=0, seed_transpiler=12345)
    qc_t_cm_lv0.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to coupling map with optimization level 0](/images/transpile/representing_quantum_computers/qc_t_cm_lv0.png)

As shown above, several SWAP gates were inserted (each consisting of three CX gates), which will cause a lot of errors on current devices. To see which qubits are selected on the actual qubit topology, use `plot_circuit_layout` from Qiskit Visualizations:

```python
    from qiskit.visualization import plot_circuit_layout

    plot_circuit_layout(qc_t_cm_lv0, backend, view='physical')
```
![Circuit Layout for optimization level 0](/images/transpile/representing_quantum_computers/circ_layout_lv0.png)



```python
    qc_t_cm_lv2 = transpile(qc, coupling_map=coupling_map, optimization_level=2, seed_transpiler=12345)
    qc_t_cm_lv2.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to coupling map with optimization level 2](/images/transpile/representing_quantum_computers/qc_t_cm_lv2.png)

Now we do not have any SWAPs inserted, and the physical qubits selected are the same when using the Target class *(TODO: actually they should probably be different).*

```python
    from qiskit.visualization import plot_circuit_layout

    plot_circuit_layout(qc_t_cm_lv2, backend, view='physical')
```
![Circuit Layout for optimization level 2](/images/transpile/representing_quantum_computers/circ_layout_lv2.png)

Now the layout is in a ring, which respects the connectivity of the circuit, which is why there are no SWAP gatess. This is a much better circuit for execution.

## Basis gates

The limited instruction set of the quantum backend is the set of basis gates, and every gate in the circuit must be translated to the elements of this set. This set should consist of single- and two-qubit gates that provide a universal gates set, meaning any quantum operation can be decomposed into them.  This is done by the _basis translator_ (*link*), and the basis gates may be specified as a keyword argument to the transpiler to provide this information.

```python
    basis_gates = list(target.operation_names)
    # basis_gates = backend.operation_names
    print(basis_gates)
```
`['rz', 'sx', 'x', 'ecr', 'measure', 'delay']`

The default single-qubit gates on _ibm_sherbrooke_ are `rz`, `x`, and `sx`, and the default two-qubit gate is `ecr` which standes for echoed cross resonsance. CX gates are constructed from `ecr` gates, so on some backends `ecr` is specified as the two-qubit basis gate while on others `cx` is default. The `ecr` gates is the _entangling_ part of the `cx` gate. If one desires to use a gate that is not in the basis gate set, instructions for custom gates can be provided using pulse gates (*link*). In addition to the control gates, there is also `delay` and `measurement` instructions.

```python
    qc_t_cm_bg_lv2 = transpile(qc, coupling_map=coupling_map, basis_gates=basis_gates, optimization_level=2, seed_transpiler=12345)
    qc_t_cm_bg_lv2.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to coupling map and basis gates with optimization level 2](/images/transpile/representing_quantum_computers/qc_t_cm_bg_lv2.png)

Note that the CX's have been decomposed to `ecr` gates and single-qubit basis gates.

## Backend Properties

*Cannot actually do this with modern backends... see Build your own target section*

## Error map

*Not intended for users*

## Build your own target

While the `target` object contains everything we need to target a backend, this section will show how to build your own target and we will just add the error rates from the instruction properties. On its own, the target contains this information already, for example the instruction properties of the echoed cross resonance gate between qubit 0 and 1 is retrieved visualization

```python
    target['ecr'][(1, 0)]
```
`InstructionProperties(duration=5.333333333333332e-07, error=0.006969730734746021, calibration=PulseQobj)`

shows that the gate is 533Î¼s with an error of 0.7%. In order to reveal this information to the transpiler, we will build our own target model and populate it with value from the actual backend `FakeSherbrooke`.

```python
    from qiskit.transpiler import Target

    err_targ = Target.from_configuration(basis_gates=basis_gates, coupling_map=coupling_map, num_qubits=target.num_qubits)

    for idx in range(len(target.instructions)):
        err_targ[target.instructions[idx][0].name][target.instructions[idx][1]] = target.instruction_properties(idx)
```

then we transpile with our new target `err_targ` as the target

```python
    qc_t_cm_bg_et_lv2 = transpile(qc, target=err_targ, optimization_level=2, seed_transpiler=12345)
    qc_t_cm_bg_et_lv2.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to our target model with optimization level 2](/images/transpile/representing_quantum_computers/qc_t_cm_bg_et_lv2.png)

When using older backends without the `target` attribute, we can achieve the same effect by passing `backend.properties()` to the transpiler directly.

```python
    qc_t_cm_bg_bp_lv2 = transpile(qc, coupling_map=coupling_map, basis_gates=basis_gates, backend_properties=backend.properties(), optimization_level=2, seed_transpiler=12345)
```

