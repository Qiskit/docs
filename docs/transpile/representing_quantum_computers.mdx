---
title: Representing quantum computers
description: The necessary backend information for successfully transpiling quantum circuits

---

# Representing quantum computers

To construct an equivalent circuit that can run on a specific backend, the transpiler needs certain details about the backend.  Typically, this information is found in the `backend` or `target = backend.target` class, so you don't need to pass anything further to the transpiler. (TODO: check with Matthew about how this is moving, seems there is no `target` attribute for older `Backend` classes). However, if more infomation is provided, the transpiler can use it to try to produce the best circuit to run on that hardware.  

<Admonition type="note">
Because many of the underlying transpilation algorithms are stochastic, there is no guarantee that a better circuit will be found. 
</Admonition>

<span id="default-config"></span>
## Default configuration

The simplest use of the transpiler is to provide all the backend infomation by providing the `backend` or `target` (TODO: only available on newer backends?). To better understand how the transpiler works, construct a circuit and transpile it with different information:

Import the necessary libraries and instantiate the backend:

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.providers.fake_provider import FakeSherbrooke

    backend = FakeSherbrooke()
    target = backend.target
```

Construct a 12-qubit circuit with circular entanglement:

```python
    qc = QuantumCircuit(12)
    qc.h(0)
    _ = [qc.cx(idx, idx+1) for idx in range(11)]
    qc.cx(11, 0)
    qc.draw('mpl')
```
![The 12-qubit test circuit](/images/transpile/representing_quantum_computers/qc-circular.png)

Transpile the circuit with the simplest options. This example uses `optimization_level=2` to highlight a feature:

```python
    qc_t_target = transpile(qc, target=target, optimization_level=2, seed_transpiler=12345)
    qc_t_target.draw('mpl', style='iqp', idle_wires=False)
```
![The transpiled 12-qubit test circuit using Target information](/images/transpile/representing_quantum_computers/qc_t_target.png)

This example is used in later sections of this topic to illustrate that the coupling map and basis gates are the essential pieces of information to pass to the transpiler for optimal circuit construction. The backend can usually select default settings for other information that is not passed in, such as timing and scheduling. (TODO: check!) 

Providing the backend properties, including the gates' error rates, allows the transpiler to select the best set of qubits on the backend.

## Coupling Map

The coupling map is a graph that specifies which qubits are connected and hence have 2-qubit gates between them. Sometimes this graph is directional, meaning that the 2-qubit gates can only go in one direction. However, the transpiler can always flip a gate's direction by adding additional 1-qubit gates. An abstract quantum circuit can always be represented on this graph, even if its connectivity is limited, by introducting SWAP gates to move the quantum information. 

The qubits from our abstract circuits are called _virtual qubits_ and those on the coupling map are _physical qubits_. The transpiler provides a mapping between virtual and physical qubits. One of the first steps in transpilation, the _routing_ stage, performs this mapping.

<Admonition type="note">
Although the routing stage it intertwined with the _layout_ stage, which selects the actual qubits, we will consider them as separate stages for simplicity. The combination of routing and layout is called _qubit mapping_. (TODO: insert link) 
</Admonition>

Pass the `coupling_map` keyword argument to see its effect on the transpiler:

```python
    coupling_map = target.build_coupling_map()
    # coupling_map = backend.configuration().coupling_map

    qc_t_cm_lv0 = transpile(qc, coupling_map=coupling_map, optimization_level=0, seed_transpiler=12345)
    qc_t_cm_lv0.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to coupling map](/images/transpile/representing_quantum_computers/qc_t_cm_lv0.png)

As shown above, several SWAP gates were inserted (each consisting of three CX gates), which will cause a lot of errors on current devices. To see which qubits are selected on the actual qubit topology, use `plot_circuit_layout` from Qiskit Visualizations:

```python
    from qiskit.visualization import plot_circuit_layout

    plot_circuit_layout(qc_t_cm_lv0, backend, view='physical')
```
![Circuit Layout for optimization level 0](/images/transpile/representing_quantum_computers/circ_layout_lv0.png)

Now we do not have any SWAPs inserted, and the physical qubits selected are the same when using the Target class (TODO: actually they should probably be different).

**Question: why aren't there any SWAPs instarted?  It looks like it still uses the coupling_map that's specified in qc_t_cm_lv0, but this one uses optimization_level=2; so I think more needs to be added to this explanation.**

```python
    qc_t_cm_lv2 = transpile(qc, coupling_map=coupling_map, optimization_level=2, seed_transpiler=12345)
    qc_t_cm_lv2.draw('mpl', style='iqp', idle_wires=False)
```
![Test circuit transpiled to coupling map](/images/transpile/representing_quantum_computers/qc_t_cm_lv2.png)

**Same image description as the previous section.**


Now the layout is in a ring, which respects the connectivity of the circuit, hence there are no extra SWAP gatess and we have a much better circuit for execution.

**image?**

## Basis gates

## Backend Properties