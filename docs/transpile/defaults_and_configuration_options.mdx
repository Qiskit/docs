---
title: Transpilation defaults and configuration options
description: Default settings and configuration options including optimization and approximation degree

---

# Transpilation default settings and configuration options

You can pass circuits to the `transpile()` method and use all default settings, or you can use parameters to fine tune the transpilation. 

## All available parameters:

Following are all of the available parameters for the `transpile()` method.  There are two classes of arguments: those that describe the target of compilation, and those that influence how the transpiler works.


All parameters except `circuits` are optional.  For full details, see the (Transpiler API documentation)[https://docs.quantum-computing.ibm.com/api/qiskit/transpiler#transpiler-api].

Do we want this whole list?  If so, I'll add descriptions from (https://docs.quantum-computing.ibm.com/api/qiskit/compiler#compilation-routines)

Parameters used to describe the compilation target:

- `circuits` (`_CircuitT`) - One or more circuits to transpile. This is the only required parameter.
- backend (Backend)
- backend_properties (BackendProperties)
- basis_gates (List[str])
- coupling_map (CouplingMap | List[List[int]])
- dt (float) 
- ignore_backend_supplied_default_methods (bool)
- inst_map (List[InstructionScheduleMap])
- instruction_durations (List[Tuple[str, Iterable[int], float, Iterable[float], str]] | List[Tuple[str, Iterable[int], float, Iterable[float]]] | List[Tuple[str, Iterable[int], float, str]] | List[Tuple[str, Iterable[int], float]] | InstructionDurations)
- target (Target)
- timing_constraints (Dict[str, int]) 

Parameters used to influence how the transpiler works:

- approximation_degree (float | None) - Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation). The default value is 1.0.  Specifying `None` sets the approximation degree to the reported error rate. (optimization stage)
- callback (Callable[[BasePass, DAGCircuit, float, PropertySet, int], Any])
- hls_config (HLSConfig) (init stage)
- init_method (str) (init stage)
- initial_layout (Layout | Dict | List) (layout stage)
- layout_method (str) (layout stage)
- optimization_level (int) (0 or 1: optimization stage)
- optimization_method (str) (optimization stage)
- output_name (str | List[str])
- routing_method (str) (routing stage)
- scheduling_method (str) (scheduling stage)
- seed_transpiler (int) (layout/routing stages?)
- translation_method (str) (translation state)
- unitary_synthesis_method (str) (init stage, could check with re-synthesis in optimization stage)
- unitary_synthesis_plugin_config (dict) (init stage, could check with re-synthesis in optimization stage)

## Commonly used parameters 
 
### Optimization level

Decomposing quantum circuits into the basis gate set of the target device and the addition of swap gates needed to match hardware topology cause an increase the depth and gate count of quantum circuits. To mitigate this increased complexity, you can set the `optimization_level`.  Setting this value calls an optmization routine that optimizes circuits by combining or eliminating gates. In some cases these methods are so effective the output circuits have lower depth than the inputs. In other cases, not much can be done, and the computation may be difficult to perform on noisy devices. Choosing the best optimization level might take trial and error, as it depends heavily on the circuit being transpiled and the backend being targeted. By default, `optimization_level=1` is used.

The `optimization_level` setting specifies how much optimization to perform on the circuits. Higher levels generate more optimized circuits by increasing the heuristic effort spent trying to optimize, at the expense of longer compile times.  The default level is 1. 

- `optimization_level=0`: Trivial optimization, which maps the circuit to the backend with no explicit optimization.
- `optimization_level=1-3`: Increasinly complex optimization, with heuristic algorithms thta are used to find a layout and insert swaps, with the goal of improving the overall performance of the circuit.  The number of iterations that these algorithms run increases with higher optimization levels. 

Example, specifying `optimization_level=0`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
    plot_circuit_layout(new_circ_lv0, backend)
```
![Layout with optimization level 0](/images/transpile/optimization-level-0.png)

Example, specifying `optimization_level=3`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
    plot_circuit_layout(new_circ_lv3, backend)
```
![Layout with optimization level 3](/images/transpile/optimization-level-3.png)


### Approximation degree

Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation).  Smaller values trade output accuracy for ease of execution (that is, fewer gates).  The default value is 1.0.

In two qubit unitary synthesis, it is used to specify the target fidelity of the output decomposition. That is, how much error is introduced when a matrix representation of a circuit is converted to discrete gates. If the approximation degree is a lower value (more approximation), the output circuit from synthesis will differ more from the input matrix, but will also likely have fewer gates and is easier to run. 

The approximation degree is a heuristic that corresponds to fidelity of the two-qubit KAK synthesis used in optimization levels 2 and 3. Since CX is the most expensive gate in terms of error, it may be beneficial to decrease the number of them at the cost of fidelity in synthesis (this technique was used to increase quantum volume on IBM devices: https://arxiv.org/abs/1811.12926). Approximation degree 1.0 (the default) corresponds to no approximation, and it is well known that any arbitrary two-qubit operation can be decomposed perfectly with a maximum of three CX’s through the KAK decomposition. When degrees less than 1.0, circuits with one or two CX’s may be synthesized, leading to less error from the hardware, but more from the approximation.

### seed_transpiler

Sets random seed for the stochastic parts of the transpiler

**When / Why use this?**

**All of the examples just set the value seed_transpiler=11, with no explanation.  That's probably not particularly helpful**

### initial_layout

Specifies the initial position of virtual qubits on physical qubits. If this layout makes the circuit compatible with the `coupling_map` constraints, it will be used. The final layout is not guaranteed to be the same, as the transpiler might permute qubits through swaps or other means. Multiple formats are supported.  The accepted formats are listed below, with examples of their use:

**Do we need in-context examples?**

* `Layout` instance

* Dict * 

  - Virtual to physical:

```python
    {qr[0]: 0,
    qr[1]: 3,
    qr[2]: 5}
```

  - Physical to virtual:

```python
    {0: qr[0],
    3: qr[1],
    5: qr[2]}
```

* List

  - Virtual to physical:

    `[0, 3, 5]  # Virtual qubits are ordered (in addition to named)`

  - Physical to virtual:

    `[qr[0], None, None, qr[1], None, qr[2]]`

### *_method 

These options influence how the transpiler works and are used to try and get better, different, or specific output from the transpiler.
 
**Do we need some examples?**

**Do we need more details? If we add descriptions of all of the parameters above, this would just be dup content.**

* `init_method` (str) - The plugin to use for the initialization stage. To see a list of installed plugins, run [list_stage_plugins(init).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)

* `layout_method` (str) - The layout selection pass (`trivial`, `dense`, `noise_adaptive`, `sabre`). This can also be the external plugin name to use for the layout stage. To see a list of installed plugins, run [list_stage_plugins(layout).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)

* `optimization_method` (str) - The plugin to use for the optimization stage. To see a list of installed plugins, run [list_stage_plugins(optimization).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)

* `routing_method` (str) - Name of routing pass (`basic`, `lookahead`, `stochastic`, `sabre`, `none`). This can also be the external plugin name to use for the routing stage. To see a list of installed plugins, run [list_stage_plugins(routing).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)

* `scheduling_method` (str) - Name of scheduling pass. This can also be the external plugin name to use for the scheduling stage. To see a list of installed plugins, run [list_stage_plugins(scheduling).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)
  * `as_soon_as_possible`: Schedule instructions greedily: as early as possible on a qubit resource (alias: `asap`).
  * `as_late_as_possible`: Schedule instructions late.  That is, keep qubits in the ground state when possible (alias: `alap`).

* `translation_method` (str) - Name of translation pass (`unroller`, `translator`, `synthesis`). This can also be the external plugin name to use for the translation stage. To see a list of installed plugins, run [list_stage_plugins(translation).](https://docs.quantum-computing.ibm.com/api/qiskit/transpiler_plugins#plugin-api)

* `unitary_synthesis_method` (str) - The name of the unitary synthesis method to use. By default `default` is used. To see a list of installed plugins, run [unitary_synthesis_plugin_names().](https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.transpiler.passes.synthesis.plugin.unitary_synthesis_plugin_names#qiskittranspilerpassessynthesispluginunitary_synthesis_plugin_names)


## Next steps

<Admonition type="tip" title="Recommendation">
    - Learn how to use [Predefined pass managers.](link)
    - Learn how to use [Custom pass managers.](link)
    - [Set the optimization level when using Qiskit Runtime.](../run/advanced_runtime_options)
    - API doc for transpile
</Admonition>