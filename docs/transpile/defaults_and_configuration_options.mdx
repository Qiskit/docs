---
title: Transpilation defaults and configuration options
description: Default settings and configuration options including optimization and approximation degree

---

# Transpilation default settings and configuration options

Transpilation is the process of rewriting a given input circuit to match the topology of a specific quantum device, to optimize the circuit for execution on present day noisy quantum systems, or both. You can pass circuits to the `transpile()` method and use all default settings, or you can fine-tune the transpilation by using the available parameters. 

## All available parameters:

Following are all of the available parameters for the `transpile()` method.  There are two classes of arguments: those that describe the target of compilation, these are things like backend and target (along with the legacy BackendV1 formats like basis_gates, inst_map). By default most users just use backend and provide a backend object, only if you have a more advanced use case do you specify any of the other arguments to describe a backend. 

The other options are things that purely influence how the transpiler does its job, these are things like optimization_level and the *_method arguments which are more commonly used to try and get better, different, or specific output from the transpiler.


All parameters except `circuits` are optional.  For full details, see the (Transpiler API documentation)[https://docs.quantum-computing.ibm.com/api/qiskit/transpiler#transpiler-api].

Do we want this whole list?  If so, I'll add descriptions from (https://docs.quantum-computing.ibm.com/api/qiskit/compiler#compilation-routines)

- `circuits` (`_CircuitT`) - One or more circuits to transpile. This is the only required parameter.
- approximation_degree (float | None) - Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation). The default value is 1.0.  Specifying `None` sets the approximation degree to the reported error rate.
- backend (Backend)
- backend_properties (BackendProperties)
- basis_gates (List[str])
- callback (Callable[[BasePass, DAGCircuit, float, PropertySet, int], Any])
- coupling_map (CouplingMap | List[List[int]])
- dt (float) 
- hls_config (HLSConfig)
- ignore_backend_supplied_default_methods (bool)
- init_method (str)
- initial_layout (Layout | Dict | List)
- inst_map (List[InstructionScheduleMap])
- instruction_durations (List[Tuple[str, Iterable[int], float, Iterable[float], str]] | List[Tuple[str, Iterable[int], float, Iterable[float]]] | List[Tuple[str, Iterable[int], float, str]] | List[Tuple[str, Iterable[int], float]] | InstructionDurations)
- layout_method (str)
- optimization_level (int)
- optimization_method (str)
- output_name (str | List[str])
- routing_method (str)
- scheduling_method (str)
- seed_transpiler (int)
- target (Target)
- timing_constraints (Dict[str, int]) –
- translation_method (str) 
- unitary_synthesis_method (str)
- unitary_synthesis_plugin_config (dict)

## Commonly used parameters 
 
### Optimization level

Set the optimization level

Decomposing quantum circuits into the basis gate set of the target device and the addition of swap gates needed to match hardware topology cause an increase the depth and gate count of quantum circuits. To mitigate this increased complexity, you can set the `optimization_level`.  Setting this value calls an optmization routine that optimizes circuits by combining or eliminating gates. In some cases these methods are so effective the output circuits have lower depth than the inputs. In other cases, not much can be done, and the computation may be difficult to perform on noisy devices. 

Different gate optimizations are turned on with different `optimization_level` values. In general, the higher the number, the more optimized it is, at the expense of longer processing time. Choosing the best optimization level might take trial and error, as it depends heavily on the circuit being transpiled and the backend being targeted. By default, `optimization_level=1` is used.

Levels: 


The `optimization_level` setting specifies how much optimization to perform on the circuits. Higher levels generate more optimized circuits by increasing the heuristic effort spent trying to optimize, at the expense of longer compile times. 

- `optimization_level=0`: Trivial optimization, which maps the circuit to the backend with no explicit optimization.
- `optimization_level=1`: Light optimization, which includes a noise-adaptive layout, maps the circuit, collapses adjacent gates, and uses heuristic algorithms to find a layout and insert swaps, with the goal to improving the overall performance of the circuit. This is the default value. 
- `optimization_level=2`: Medium optimization, includes the processes for level 1 and a gate-cancellation procedure based on gate commutation relationships. Additionally, the same heuristic layout and swap insertion technique is used, but with an increased number of iterations.
- `optimization_level=3`: Heavy optimization, which performs the optimization included in levels 1 - 2 and resynthesizes two-qubit gate blocks in the circuit. It uses the same heuristic layout and swap insertion technique but with a further increased number of iterations.

<Table>
  <thead>
    <Tr>
      <Th>Optimization Level</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>0</Td>
      <Td>
        No optimization: typically used for hardware characterization
        - Basic translation
        - Layout (as specified)
        - Routing (stochastic swaps)
      </Td>
    </Tr>
    <Tr>
      <Td>1</Td>
      <Td>
        Light optimization (default):

        -   Layout (trivial → vf2 → SabreLayout if routing is required)
        -   Routing (SabreSWAPs if needed)
        -   1Q gate optimization
        -   Error suppression: VF2PostLayout
      </Td>
    </Tr>
    <Tr>
      <Td>2</Td>
      <Td>
        Medium optimization:
          - Layout/Routing: Optimization level 1 (without trivial) + heuristic optimized with greater
        search depth and trials of optimization function
        -   Commutative cancelation
        -   1q gate optimization
        -   Error suppression: VF2PostLayout
      </Td>
    </Tr>
    <Tr>
      <Td>3 (default)</Td>
      <Td>
        High Optimization:

        - Optimization level 2 + heuristic optimized on layout/routing further with greater effort/trials
        - Two qubit KAK optimization
        - Error suppression: VF2PostLayout
      </Td>
    </Tr>
  </tbody>
</Table>

Example, specifying `optimization_level=0`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
    plot_circuit_layout(new_circ_lv0, backend)
```
![Layout with optimization level 0](/images/transpile/optimization-level-0.png)

Example, specifying `optimization_level=3`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
    plot_circuit_layout(new_circ_lv3, backend)
```
![Layout with optimization level 3](/images/transpile/optimization-level-3.png)


### Approximation degree

Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation).  Smaller values trade output accuracy for ease of execution (that is, fewer gates).  The default value is 1.0.

In two qubit unitary synthesis, it is used to specify the target fidelity of the output decomposition. That is, how much error is introduced when a matrix representation of a circuit is converted to discrete gates. If the approximation degree is a lower value (more approximation), the output circuit from synthesis will differ more from the input matrix, but will also likely have fewer gates and is easier to run. 

### seed_transpiler

### initial_layout

### *_method 


## Next steps

<Admonition type="tip" title="Recommendation">
    - Learn how to use [Predefined pass managers.](link)
    - Learn how to use [Custom pass managers.](link)
    - [Set the optimization level when using Qiskit Runtime.](../run/advanced_runtime_options)
    - API doc for transpile
</Admonition>