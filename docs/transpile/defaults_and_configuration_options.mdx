---
title: Transpilation defaults and configuration options
description: Default settings and configuration options including optimization and approximation degree

---

# Transpilation default settings and configuration options

Transpilation is the process of rewriting a given input circuit to match the topology of a specific quantum device, to optimize the circuit for execution on present day noisy quantum systems, or both. You can pass circuits to the `transpile()` method and use all default settings, or you can fine-tune the transpilation by using the available parameters. 

## All available parameters:

Following are all of the available parameters for the `transpile()` method.  There are two classes of arguments: those that describe the target of compilation, and those that influence how the transpiler works.


All parameters except `circuits` are optional.  For full details, see the (Transpiler API documentation)[https://docs.quantum-computing.ibm.com/api/qiskit/transpiler#transpiler-api].

Do we want this whole list?  If so, I'll add descriptions from (https://docs.quantum-computing.ibm.com/api/qiskit/compiler#compilation-routines)

Parameters used to describe the compilation target:

- `circuits` (`_CircuitT`) - One or more circuits to transpile. This is the only required parameter.
- backend (Backend)
- backend_properties (BackendProperties)
- basis_gates (List[str])
- coupling_map (CouplingMap | List[List[int]])
- dt (float) 
- ignore_backend_supplied_default_methods (bool)
- inst_map (List[InstructionScheduleMap])
- target (Target)

Parameters used to influence how the transpiler works:

- approximation_degree (float | None) - Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation). The default value is 1.0.  Specifying `None` sets the approximation degree to the reported error rate.
- callback (Callable[[BasePass, DAGCircuit, float, PropertySet, int], Any])
- hls_config (HLSConfig)
- init_method (str)
- initial_layout (Layout | Dict | List)
- instruction_durations (List[Tuple[str, Iterable[int], float, Iterable[float], str]] | List[Tuple[str, Iterable[int], float, Iterable[float]]] | List[Tuple[str, Iterable[int], float, str]] | List[Tuple[str, Iterable[int], float]] | InstructionDurations)
- layout_method (str)
- optimization_level (int)
- optimization_method (str)
- output_name (str | List[str])
- routing_method (str)
- scheduling_method (str)
- seed_transpiler (int)
- timing_constraints (Dict[str, int]) 
- translation_method (str) 
- unitary_synthesis_method (str)
- unitary_synthesis_plugin_config (dict)

## Commonly used parameters 
 
### Optimization level

Set the optimization level

Decomposing quantum circuits into the basis gate set of the target device and the addition of swap gates needed to match hardware topology cause an increase the depth and gate count of quantum circuits. To mitigate this increased complexity, you can set the `optimization_level`.  Setting this value calls an optmization routine that optimizes circuits by combining or eliminating gates. In some cases these methods are so effective the output circuits have lower depth than the inputs. In other cases, not much can be done, and the computation may be difficult to perform on noisy devices. 

Different gate optimizations are turned on with different `optimization_level` values. In general, the higher the number, the more optimized it is, at the expense of longer processing time. Choosing the best optimization level might take trial and error, as it depends heavily on the circuit being transpiled and the backend being targeted. By default, `optimization_level=1` is used.

The `optimization_level` setting specifies how much optimization to perform on the circuits. Higher levels generate more optimized circuits by increasing the heuristic effort spent trying to optimize, at the expense of longer compile times.  The default level is 1. 

- `optimization_level=0`: Trivial optimization, which maps the circuit to the backend with no explicit optimization.
- `optimization_level=1-3`: Increasinly complex optimization, with heuristic algorithms thta are used to find a layout and insert swaps, with the goal of improving the overall performance of the circuit.  The number of iterations that these algorithms run increases with higher optimization levels. 

Example, specifying `optimization_level=0`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv0 = transpile(ghz, backend=backend, optimization_level=0)
    plot_circuit_layout(new_circ_lv0, backend)
```
![Layout with optimization level 0](/images/transpile/optimization-level-0.png)

Example, specifying `optimization_level=3`: 

```python
    from qiskit import QuantumCircuit, transpile
    from qiskit.visualization import plot_circuit_layout
    from qiskit.providers.fake_provider import FakeVigo
    backend = FakeVigo()

    ghz = QuantumCircuit(3, 3)
    ghz.h(0)
    ghz.cx(0,range(1,3))
    ghz.barrier()
    ghz.measure(range(3), range(3))

    new_circ_lv3 = transpile(ghz, backend=backend, optimization_level=3)
    plot_circuit_layout(new_circ_lv3, backend)
```
![Layout with optimization level 3](/images/transpile/optimization-level-3.png)


### Approximation degree

Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation).  Smaller values trade output accuracy for ease of execution (that is, fewer gates).  The default value is 1.0.

In two qubit unitary synthesis, it is used to specify the target fidelity of the output decomposition. That is, how much error is introduced when a matrix representation of a circuit is converted to discrete gates. If the approximation degree is a lower value (more approximation), the output circuit from synthesis will differ more from the input matrix, but will also likely have fewer gates and is easier to run. 

### seed_transpiler

### initial_layout

### *_method 


## Next steps

<Admonition type="tip" title="Recommendation">
    - Learn how to use [Predefined pass managers.](link)
    - Learn how to use [Custom pass managers.](link)
    - [Set the optimization level when using Qiskit Runtime.](../run/advanced_runtime_options)
    - API doc for transpile
</Admonition>