---
title: View backend information
description: View information about IBM Quantum hardware

---

# View backend information

In contrast to the [system configuration](#system-configuration-values) that remains static on the timescale of typical experiments, the **properties** of a system are dynamical quantities that update at system calibration time. Systems are nominally calibrated once over a 24-hour period, and the system properties update once this calibration sequence is complete. The properties play a critical role in quantum circuit execution, as the parameters within the properties are utilized for noise-aware circuit mapping and optimization (transpilation). Additionally, system properties are used for constructing noise models of a system for use in classical simulation methods.

You can most easily obtain a quantum system’s properties with Qiskit, but you can also obtain them by downloading the “calibrations” CSV file for a given system on IBM Quantum (see [View system configuration](#view-system-configuration) for more information).

*   **system name** - `system.properties().backend_name` gives the name of the system.

*   **system version** - `system.properties().backend_version` specifies the version of the system, as described [in the system versioning section](#system-versioning).

*   **last update date** - `system.properties().last_update_date` gives the local time at which the properties information was last updated. This is the time at which the full properties file was returned from the system. Individual elements in the properties give the times at which they were computed. Depending on the device calibration schedule, these times can be markedly different than the last update date.

*   **qubits** - `system.properties().qubits` contains information on the physical attributes of the qubits. This includes the qubit frequency in GHz, T1 and T2 times in µs, and readout error. As shown below, the readout\_error is further partitioned into `prob_meas0_prep1` and `prob_meas1_prep0`, indicating the probability of preparing a given computational basis state, but measuring the orthogonal state. The readout error is taken to be the average of these two values. Note that `prob_meas0_prep1` is usually the dominant factor in the readout error due to relaxation during the measurement process. The qubits field is a list indexed by the qubit number.

    ```python
    [Nduv(datetime.datetime(2020, 12, 7, 9, 5, 37, tzinfo=tzlocal()), T1, us, 134.6122100394965),
     Nduv(datetime.datetime(2020, 12, 7, 9, 6, 19, tzinfo=tzlocal()), T2, us, 69.51042482642832),
     Nduv(datetime.datetime(2020, 12, 7, 9, 21, 20, tzinfo=tzlocal()), frequency, GHz, 4.743896496595851),
     Nduv(datetime.datetime(2020, 12, 7, 9, 21, 20, tzinfo=tzlocal()), anharmonicity, GHz, -0.31386048358781926),
     Nduv(datetime.datetime(2020, 12, 7, 9, 4, 47, tzinfo=tzlocal()), readout_error, , 0.06969999999999998),
     Nduv(datetime.datetime(2020, 12, 7, 9, 4, 47, tzinfo=tzlocal()), prob_meas0_prep1, , 0.0796),
     Nduv(datetime.datetime(2020, 12, 7, 9, 4, 47, tzinfo=tzlocal()), prob_meas1_prep0, , 0.0598),
     Nduv(datetime.datetime(2020, 12, 7, 9, 4, 47, tzinfo=tzlocal()), readout_length, ns, 5813.333333333333)
    ]
    ```

    We see that each qubit parameter is expressed as an `Nduv` (name, date, unit value) object containing the local time at which the parameter was updated, the parameter name, parameter units, and the actual numerical parameter value.

    *   **gates** - `system.properties().gates` gives detailed information on each gate that the system supports executing. For every single-qubit gate listed in the system basis gates, there exists an entry in the properties that gives the details of that gate, for each qubit on which the gate can be applied. Each entry is in the form of a `Gate` object:

        ```python
        Gate(gate='u2', name='u2_0', parameters=[Nduv('2020-06-06T09:06:46Z', gate_error, , 0.00022436814887248838), Nduv('2020-06-06T10:03:18Z', gate_length, ns, 35.55555555555556)], qubits=[0])
        ```

        and lists the kind of gate (`u2` in the example), its name, a list specifying the qubits on which the gate acts, and a `parameters` attribute, `gates.parameters`:

        ```python
        [Nduv('2020-06-06T09:06:46Z', gate_error, , 0.00022436814887248838),
         Nduv('2020-06-06T10:03:18Z', gate_length, ns, 35.55555555555556)]
        ```

        containing `Nduv` objects specifying the gate error and gate length.

        The same holds for multi-qubit gates, where there is an entry for each directed edge in the system [coupling map](#coupling-map). For symmetric coupling maps, the directionality of the underlying gate is still important. For example,

        ```python
        Gate(gate='cx', name='cx3_4', parameters=[Nduv('2020-06-06T10:03:18Z', gate_error, , 0.009793933588297388), Nduv('2020-06-06T10:03:18Z', gate_length, ns, 327.1111111111111)], qubits=[3, 4])
        ```

        versus

        ```python
        Gate(gate='cx', name='cx4_3', parameters=[Nduv('2020-06-06T10:03:18Z', gate_error, , 0.009793933588297388), Nduv('2020-06-06T10:03:18Z', gate_length, ns, 362.66666666666663)], qubits=[4, 3])
        ```
