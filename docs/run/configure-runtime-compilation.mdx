---
title: Configure runtime compilation
description: How to use runtime compilation techniques

---

# Configure runtime compilation for Qiskit Runtime

Runtime compilation techniques optimize and transform your circuit to minimize errors. Runtime compilation adds some classical pre-processing overhead to your overall runtime. Therefore, it is important to achieve a balance between perfecting your results and ensuring that your job completes in a reasonable amount of time.

Primitives let you employ runtime compilation by setting the optimization level (`optimization_level` option) and by choosing advanced runtime compilation options.

<Admonition type="note" title="Important:">
To ensure faster and more efficient results, as of 15 Feb 2024, circuits and observables need to be transformed to only use instructions supported by the system (referred to as *instruction set architecture (ISA)* circuits) before being submitted to the Qiskit Runtime primitives.  See the [transpilation documentation](../transpile) for instructions to transform circuits.  Due to this change, transpilation options (`options.transpilation.xxx`) are no longer supported and will be ignored. Additionally, `optimization_level`  no longer performs routing or layout operations.
</Admonition>



## Set the optimization level

The `optimization_level` setting specifies how much optimization to perform on the circuits. Higher levels generate more optimized circuits, at the expense of longer compile times.

<Admonition>
  In current primitive versions, optimization levels 2 and 3 behave identically to level 1.
</Admonition>

<Admonition type="note" title="Important:">
To ensure faster and more efficient results, as of 15 Feb 2024, Qiskit Runtime primitives will no longer transpile circuits.  Instead, you must submit locally-transpiled (*instruction set architecture (ISA)*) circuits.  See the [transpilation documentation](../transpile) for instructions.  Due to this change, transpilation options (`options.transpilation.xxx`) are no longer supported and will be ignored. Additionally, `optimization_level`  no longer performs routing or layout operations.
</Admonition>


<Table>
  <thead>
    <Tr>
      <Th>Optimization Level</Th>
      <Th>Estimator & Sampler</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>0</Td>
      <Td>
        No optimization: typically used for hardware characterization or debugging

        - Basis translation
        - Layout (as specified)
        - Routing (stochastic swaps)
      </Td>
    </Tr>
    <Tr>
      <Td>1, 2, 3</Td>
      <Td>
        Light optimization:
        -   Single-qubit gate optimization
        -   Two-qubit gate optimization
        -   Error suppression: dynamical decoupling
      </Td>
    </Tr>
  </tbody>
</Table>

<Admonition>
  The primitives expect circuits in a form suitable to execute on the target system. You may use the Qiskit transpiler locally to translate abstract circuits into this target circuit form. 
  
At present, the primitives will attempt low-cost transformations if given a circuit that is not already in target form, but in the future, primitives will error on such circuits. It is therefore recommended that users take advantage of the local compilation capabilities of the Qiskit transpiler wherever possible.
  
  For instructions on preparing circuits for primitive queries, see the [Submit pre-transpiled circuits](https://learning.quantum.ibm.com/tutorial/submitting-user-transpiled-circuits-using-primitives) tutorial.
</Admonition>

<Admonition type="note">
  If using an IBM Cloud Qiskit Runtime service instance with Q-CTRL performance management enabled, there is no need to specify runtime optimization or resilience levels, as the strategy includes an automatic preset.
  
  Q-CTRL defaults to `optimization_level=3` and `resilience_level=1`.
  Setting `optimization_level` or `resilience_level` equal to 0 will result in an
  execution error. Levels 1, 2, and 3 are permitted but will not impact performance.
  Setting other options will likewise not impact performance, and it may result in a
  runtime warning. For more information visit the [Q-CTRL documentation](https://docs.q-ctrl.com/q-ctrl-embedded).
</Admonition>

### Example: configure Estimator with optimization levels

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp

service = QiskitRuntimeService()
backend = service.backend("ibmq_qasm_simulator")
options = Options(optimization_level=1)

psi = RealAmplitudes(num_qubits=2, reps=2)
H = SparsePauliOp.from_list([("II", 1), ("IZ", 2), ("XI", 3)])
theta = [0, 1, 1, 2, 3, 5]

pm = generate_preset_pass_manager(backend=backend)
isa_circuit = pm.run(psi)
isa_observable = H.apply_layout(isa_circuit.layout)

estimator = Estimator (options=options, backend=backend)

job = estimator.run(isa_circuits=[isa_circuit], isa_observables=[isa_observable], parameter_values=[theta])
psi1_H1 = job.result()
```

<Admonition type="note">
  If the optimization level is not specified, the service uses `optimization_level = 1`.
</Admonition>

### Example: configure Sampler with optimization levels

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

service = QiskitRuntimeService()
backend = service.backend("ibmq_qasm_simulator")
options = Options(optimization_level=1)

pm = generate_preset_pass_manager(backend=backend)
isa_circuits = pm.run(circuits)

sampler = Sampler(options=options, backend=backend)
```


## Next steps

<Admonition type="tip" title="Recommendations">
    - Try a tutorial that uses optimization levels, such as the [Variational quantum eigensolver](https://learning.quantum.ibm.com/tutorial/variational-quantum-eigensolver) tutorial.
    - Learn how to transpile locally in the [Transpile](../transpile/) section.
    - Try the [Submit pre-transpiled circuits](https://learning.quantum.ibm.com/tutorial/submitting-user-transpiled-circuits-using-primitives) tutorial.
</Admonition>