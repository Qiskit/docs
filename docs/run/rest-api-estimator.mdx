---
title: Estimator Primitive with REST APIs
description: How to use the Estimator primitive with Qiskit Runtime REST APIs.

---

# Estimator Primitive with REST APIs

The steps in this topic describe how to set up primitives with REST APIs, explore the options you can use to configure them, and invoke them in any program of your choice.

<Admonition type="note">
    This documentation utilizes the `requests` module of python to demonstrate the Qiskit Runtime REST APIs. However, this workflow can be executed using any language/framework that supports working with REST APIs. The official documentation for the API Reference can be found [here](https://docs.quantum.ibm.com/api/runtime/tags/jobs).
</Admonition>


<span id="start-estimator"></span>
## Get started with Estimator

### 1. Initialize the account

Because Qiskit Runtime `Estimator` is a managed service, you first need to initialize your account. You can then select the simulator or real system you want to use to calculate the expectation value.


### 2. Create a QASM circuit

You need at least one circuit as the input to the `Estimator` primitive.


* Define a QASM quantum circuit e.g. 

```python
qasm_string='''
OPENQASM 3;
include "stdgates.inc";
qreg q[2];
creg c[2];
x q[0];
cx q[0], q[1];
c[0] = measure q[0]; 
c[1] = measure q[1];
'''  
```


### 3. Invoke the Qiskit Transpiler Service



### 4. Run the Quantum Circuit using the EstimatorV2 API


<Admonition type="note">
    The jobs below use [Qiskit Runtime V2 primitives](https://docs.quantum.ibm.com/api/migration-guides/v2-primitives). Both SamplerV2 and EstimatorV2 take one or more primitive unified blocs (PUBs) as the input. Each PUB is a tuple that contains one circuit and the data broadcasted to that circuit, which can be multiple observables and parameters. Each PUB returns a result.
</Admonition>


```python
import requests

url = 'https://api.quantum-computing.ibm.com/runtime/jobs'
headers = {
    'Content-Type': 'application/json',
    'x-access-token':auth_id,
    'x-qx-client-application': 'qiskit-version-2/0.39.2/'+'your_application' # specifying the application you might be running from. For an actual Integration project, this option is invaluable to know where jobs are coming from. At this time the "qiskit-version-2/0.39.2/" string is a necessary prefix.
    }
job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "start_session": "False", # set to False if you just need to run a single job.  
    "params": {
        "pubs": [ #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
            [resulting_qasm, # QASM circuit
             {"IIZII": 1, "XIZZZ": 2.3}, # Observable
             None # parameter values
             ]], 
        "version": 2 # this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
}}

response = requests.post(url, headers=headers, json=job_input)

if response.status_code == 200:
    job_id = response.json().get('id')
    print("Job created:",response.text)
else:
    print(f"Error: {response.status_code}")
```


### 5. Check Job Status and Get Results

Next, pass the job ID to the API:

```python
response_status_singlejob= requests.get(url+'/'+job_id, headers=headers)
response_status_singlejob.json().get('state')
```
Output

```text
>>> Job ID: 58223448-5100-4dec-a47a-942fb30edced
>>> Job Status: JobStatus.RUNNING
```

Get job results:
```python
response_result= requests.get(url+'/'+job_id+'/results', headers=headers)

res_dict=response_result.json()

estimator_result=res_dict['results']
print(estimator_result)
```
Output
```text
[{'data': {'evs': 0.7428980350102542, 'stds': 0.029884014518789213, 'ensemble_standard_error': 0.03261147170624149}, 'metadata': {'shots': 10016, 'target_precision': 0.01, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32}}]
```

### 6. Working with Runtime Options

Error mitigation techniques allow users to mitigate circuit errors by modeling the device noise at the time of execution. This typically results in quantum pre-processing overhead related to model training and classical post-processing overhead to mitigate errors in the raw results by using the generated model.

The error mitigation techniques built in to primitives are advanced resilience options. To specify these options, use the resilience_level option when submitting your job.
Sampler V2 does not support specifying resilience levels. However, you can turn on or off individual error mitigation / suppression methods. 

You will see examples of three such error mitigation / suppression techniques when used with the Estimator Primitive. The examples given below demonstrate the default options for error mitigation / suppression techniques but more options for [Dynamical decoupling](https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/options/dynamical_decoupling_options.py), [Twirling](https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/options/twirling_options.py) and [TREX + ZNE](https://github.com/Qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/options/resilience_options.py) can be further explored. 

<Tabs>

   <TabItem value="TREX + ZNE" label="TREX + ZNE">

  ```python
import requests

url = 'https://api.quantum-computing.ibm.com/runtime/jobs'
headers = {
    'Content-Type': 'application/json',
    'x-access-token':auth_id,
    'x-qx-client-application': 'qiskit-version-2/0.39.2/'+'your_application' # specifying the application you might be running from. For an actual Integration project, this option is invaluable to know where jobs are coming from. At this time the "qiskit-version-2/0.39.2/" string is a necessary prefix.
    }
job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "start_session": "False", # set to False if you just need to run a single job.  
    "params": {
        "pubs": [ #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
            [resulting_qasm, # QASM circuit
             {"IIZII": 1, "XIZZZ": 2.3}, # Observable
             None # parameter values
             ]],
        "version": 2, # this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options": {
            "resilience": {
              "measure_mitigation": True,
              "zne_mitigation": True,
              "zne": {
                  "extrapolator":["exponential", "linear"],
                  "noise_factors":[1, 3, 5],
              },
              #"pec_mitigation": False,
              #"pec": None,
              #"layer_noise_learning":None,
          },
        },
    }
}

response = requests.post(url, headers=headers, json=job_input)

if response.status_code == 200:
    job_id = response.json().get('id')
    print("Job created:",response.text)
else:
    print(f"Error: {response.status_code}")
```

  </TabItem>

  <TabItem value="Dynamical Decoupling" label="Dynamical Decoupling">

  ```python
import requests

url = 'https://api.quantum-computing.ibm.com/runtime/jobs'
headers = {
    'Content-Type': 'application/json',
    'x-access-token':auth_id,
    'x-qx-client-application': 'qiskit-version-2/0.39.2/'+'your_application' # specifying the application you might be running from. For an actual Integration project, this option is invaluable to know where jobs are coming from. At this time the "qiskit-version-2/0.39.2/" string is a necessary prefix.
    }
job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "start_session": "False", # set to False if you just need to run a single job.  
    "params": {
        "pubs": [ #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
            [resulting_qasm, # QASM circuit
             {"IIZII": 1, "XIZZZ": 2.3}, # Observable
             None # parameter values
             ]],
        "version": 2, # this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options": {
            "dynamical_decoupling": { 
                "enable": True,
                "sequence_type": 'XpXm',
                "extra_slack_distribution": 'middle',
                "scheduling_method": 'alap',
            },
        },
    }
}

response = requests.post(url, headers=headers, json=job_input)

if response.status_code == 200:
    job_id = response.json().get('id')
    print("Job created:",response.text)
else:
    print(f"Error: {response.status_code}")
```

  </TabItem>

  <TabItem value="Twirling" label="Twirling">

  ```python
import requests

url = 'https://api.quantum-computing.ibm.com/runtime/jobs'
headers = {
    'Content-Type': 'application/json',
    'x-access-token':auth_id,
    'x-qx-client-application': 'qiskit-version-2/0.39.2/'+'your_application' # specifying the application you might be running from. For an actual Integration project, this option is invaluable to know where jobs are coming from. At this time the "qiskit-version-2/0.39.2/" string is a necessary prefix.
    }
job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "start_session": "False", # set to False if you just need to run a single job.  
    "params": {
        "pubs": [ #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
            [resulting_qasm, # QASM circuit
             {"IIZII": 1, "XIZZZ": 2.3}, # Observable
             None # parameter values
             ]],
        "version": 2, # this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options": {
            "twirling": { 
                "enable_gates": True, 
                "enable_measure": True,
                "num_randomizations": "auto",
                "shots_per_randomization": "auto",
                "strategy": "active-accum",
                },
        },
    }
}

response = requests.post(url, headers=headers, json=job_input)

if response.status_code == 200:
    job_id = response.json().get('id')
    print("Job created:",response.text)
else:
    print(f"Error: {response.status_code}")
```


  </TabItem>
</Tabs>

### 7. Submitting Jobs in a Session

One or more `Estimator` jobs can be submitted to the same `session` by specifying the session ID. 


<Admonition type="note">
    The `<parameter values>` in a `PUB` can either be a single parameter or a list of parameters. It also supports `numpy` broadcasting. 
</Admonition>


<Tabs>
  <TabItem value="1 circuit, 4 observables" label="1 circuit, 4 observables">
    ```python
    job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "session_id": sessionId, # This specifies the previously created Session 
    "params": {
        "pubs": [[resulting_qasm, [obs1, obs2, obs3, obs4]]], #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "version": 2, #this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options":{
                "transpilation":{"optimization_level": 1},
                "twirling": {"enable_gates": True,"enable_measure": True}, #c.f. documentation at https://docs.quantum.ibm.com/run/configure-error-mitigation#custom-error-settings-v2-primitives 
                # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)                     
                    },
    }

}
```
  </TabItem>

  <TabItem value="1 circuit, 4 observables, 2 parameter sets" label="1 circuit, 4 observables, 2 parameter sets">
  
    ```python
    job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "session_id": sessionId, # This specifies the previously created Session 
    "params": {
        "pubs": [[resulting_qasm, [[obs1], [obs2], [obs3], [obs4]], [[vals1], [vals2]]]], #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "version": 2, #this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options":{
                "transpilation":{"optimization_level": 1},
                "twirling": {"enable_gates": True,"enable_measure": True}, #c.f. documentation at https://docs.quantum.ibm.com/run/configure-error-mitigation#custom-error-settings-v2-primitives 
                # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)                     
                    },
    }
}
```
  </TabItem>

  <TabItem value="2 circuits, 2 observables" label="2 circuits, 2 observables">

  ```python
    job_input = {
    'program_id': 'estimator',
    "backend": backend, 
    "hub": "ibm-q",
    "group": "open",
    "project": "main",
    "session_id": sessionId, # This specifies the previously created Session 
    "params": {
        "pubs": [[resulting_qasm, obs1],[resulting_qasm, obs2]], #primitive unified blocs (PUBs) containing one circuit each. c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "version": 2, #this defines the version of the Qiskit Runtime Primitive to use, c.f. https://docs.quantum.ibm.com/api/migration-guides/v2-primitives
        "options":{
                "transpilation":{"optimization_level": 1},
                "twirling": {"enable_gates": True,"enable_measure": True}, #c.f. documentation at https://docs.quantum.ibm.com/run/configure-error-mitigation#custom-error-settings-v2-primitives 
                # "dynamical_decoupling": {"enable": True, "sequence_type": "XpXm"},   #(optional)                     
                    },
    }
}
```
  </TabItem>
</Tabs>






## Next steps

<Admonition type="tip" title="Recommendations">
    - Learn how to [test locally](../verify/local-testing-mode) before running on quantum computers.
    - Review detailed [primitives examples.](primitives-examples)
    - Read [Migrate to V2 primitives](/api/migration-guides/v2-primitives).
    - Practice with primitives by working through the [Cost function lesson](https://learning.quantum.ibm.com/course/variational-algorithm-design/cost-functions#primitives) in IBM Quantum Learning.
    - Learn how to transpile locally in the [Transpile](../transpile/) section.
    - Try the [Submit pre-transpiled circuits](https://learning.quantum.ibm.com/tutorial/submitting-user-transpiled-circuits-using-primitives) tutorial.
</Admonition>