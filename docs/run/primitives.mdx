---
title: Introduction to primitives
description: Introduction to primitives in Qiskit and Qiskit Runtime, and an explanation of available primitives

---

# Introduction to primitives

Computing systems are built upon multiples layers of **abstraction**. We generate abstractions by generalizing certain
details of *how* the technology works, to allow us to focus our attention on the details that are relevant for a
specific task. The level of abstraction we choose to work with will depend on how we want to interact with the computer.
The closer we get to the hardware, the lower-level we would need the abstractions to be (for example, we could
want to manipulate electrical signals), and vice-versa, the more complex the task we want to perform,
the higher-level abstractions we would need (for example, we could be using a programming library to perform
algebraic calculations).

In this context, a **primitive** is the smallest processing instruction for a given **abstraction** level. Primitives
represent the simplest building block from which one can create something **useful**.

In quantum computing, we are used to working at lower levels of abstraction, where we manually intervene on what
gate is applied to what qubit. As we move towards larger systems and more complex workflows, we can get greater
benefits from working at higher levels of abstraction. We have identified two fundamental
operations we commonly apply on quantum states: we either sample from them, or use them to compute expectation values
of observables. These two operations have motivated the design of *the first two Qiskit Primitives: Sampler and
Estimator*. The computational model introduced by the Qiskit Primitives moves quantum programming one step closer to where classical
programming is today, where the focus is less on the hardware details and more on the results you are trying to achieve.


[//]: # (Fundamental to quantum computation is the need to sample and estimate data. With this in mind, Qiskit has introduced its first two primitives: Estimator and Sampler.)

<Admonition type="note" title="What is the difference between the open-source and Qiskit Runtime primitives?">

  The open-source primitives contain the base classes (to define interfaces) and a reference implementation. The Qiskit Runtime primitives provide a more sophisticated implementation (such as with error mitigation) as a cloud-based service.

</Admonition>

## Estimator

The Estimator primitive computes expectation values of observables with respect to states prepared by quantum circuits. Users generally specify a list of circuits, observables, and possibly some additional configuration, with which the program can efficiently evaluate expectation values and variances.

## Sampler

The Sampler primitive calculates probabilities or quasi-probability distributions of bitstrings from quantum circuits. Quasi-probability distributions are similar to regular probabilities, except they may include negative values, which can occur when using certain error mitigation techniques.

Primitives work most effectively when they are supported by both Qiskit and the backend provider. The Qiskit module `qiskit.primitives` provides the required support on the Qiskit side, and providers like IBM’s Qiskit Runtime enable access to appropriate backends through native implementations of their own primitives.

## Benefits of Qiskit primitives

For Qiskit users, primitives allow you to write quantum code for a specific backend without having to explicitly manage every detail. In addition, because of the additional layer of abstraction, you may be able to more easily access advanced hardware capabilities of a given provider. For example, with Qiskit Runtime primitives, you can leverage the latest advancements in error mitigation and suppression by toggling options such as `optimization_level` and `resilience_level`, rather than building your own implementation of these techniques.

For hardware providers, implementing primitives natively means you can provide your users with a more “out-of-the-box” way to access your hardware features. It is therefore easier for your users to benefit from your hardware's best capabilities.

## How to use Qiskit primitives

The `qiskit.primitives` module enables the development of primitive-style quantum programs and was specifically designed to simplify switching between different types of backends. The module provides three separate classes for each primitive type:

1. `Sampler` and `Estimator`

These classes are reference implementations of both primitives and use Qiskit’s built-in simulator. They leverage Qiskit’s `quantum_info` module in the background, producing results based on ideal statevector simulations.

2. `BaseSampler` and `BaseEstimator`

These are abstract base classes that define a common interface for implementing primitives. All other classes in the `qiskit.primitives` module inherit from these base classes, and developers should use these if they are interested in developing their own primitives-based execution model for a specific backend provider. These classes may also be useful for those who want to do highly customized processing and find the existing primitives implementations too simple for their needs.

3. `BackendSampler` and `BackendEstimator`

If a provider does not support primitives natively, you can use these classes to “wrap” any backend into a primitive. Users can write primitive-style code for providers that don’t yet have a primitives-based interface. These classes can be used just like the regular Sampler and Estimator, except they should be initialized with an additional backend argument for selecting which backend to run on.

## Next steps

<Admonition type="tip" title="Recommendations">
    - Review detailed [primitives examples.](primitives-examples)
    - Practice with primitives by working through the [Cost function lesson](https://learning.quantum-computing.ibm.com/course/variational-algorithm-design/cost-functions#primitives) in IBM Quantum Learning.
</Admonition>
