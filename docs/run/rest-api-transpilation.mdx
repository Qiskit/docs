---
title: Qiskit Transpiler Service using REST API
description: How to run a quantum computing job in a Qiskit Runtime session.
---

# Qiskit transpiler service using REST API

The circuit provided will need to be mapped to instructions fitting to the hardware basis instructions of the QPU, which is a process known as Transpilation

* You can either transpile [locally via Qiskit](https://docs.quantum.ibm.com/transpile/defaults-and-configuration-options) before generating the QASM string, or:

* Use the [Cloud Transpiler API](https://cloud-transpiler.quantum.ibm.com/docs)

<Admonition type="note">
    [Transpilation is necessary](https://docs.quantum.ibm.com/announcements/product-updates/2024-02-14-qiskit-runtime-primitives-update) prior to submitting a circuit to IBM Quantum backends. 
</Admonition>

### Query the Cloud Transpilation service

Query the [Cloud Transpilation service](https://cloud-transpiler.quantum-computing.ibm.com/docs) and provide your QASM string as input. See more details and documentation [here](https://docs.quantum.ibm.com/api/qiskit-transpiler-service-rest). 

<Admonition type="note">
    This experimental service is only available for IBM Quantum Premium Plan users.
</Admonition>

<Tabs>
    <TabItem value="Qiskit Transpiler" label="Qiskit Transpiler">
        ```python
backend='ibm_brisbane' #choose your IBM Backend

headers = {
    "accept": "application/json",
    "Authorization": f"Bearer {token}",
    "Content-Type": "application/json",
        }
body= {
    "qasm_circuits": qasm_string,
}
params = {
        "backend": backend,
        "optimization_level": 1,
        "ai": "false", # "true", "false" and "auto"
        }

resp = requests.post(
            "https://cloud-transpiler.quantum.ibm.com/transpile",
            headers=headers,
            json=body,
            params=params,
        )
        ```
    </TabItem>

    <TabItem value="AI Transpiler" label="AI Transpiler">
        ```python
backend='ibm_brisbane' #choose your IBM Backend

headers = {
    "accept": "application/json",
    "Authorization": f"Bearer {token}",
    "Content-Type": "application/json",
        }
body= {
    "qasm_circuits": qasm_string,
}
params = {
        "backend": backend,
        "optimization_level": 1,
        "ai": "true", # "true", "false" and "auto"
        "coupling_map": [],
        "qiskit_transpile_options": [],
        "ai_layout_mode": 'OPTIMIZE', # 'KEEP', 'OPTIMIZE', 'IMPROVE'
        }

resp = requests.post(
            "https://cloud-transpiler.quantum.ibm.com/transpile",
            headers=headers,
            json=body,
            params=params,
        )
        ```
    </TabItem>
</Tabs>


<Admonition type="note">
    Since there may be cases where it’s better to forego the use of AI-powered passes, we’ve developed a third option for the ai parameter that gives users the best of both worlds. Set the ai parameter to `ai="auto"`, and this will enable the system to decide automatically whether to apply the standard Qiskit heuristic passes or the new AI-powered passes based on the particulars of your circuit.
</Admonition>

### Request results based on the `task_id`

Request the transpilation service results using the `task_id`

```python
task_id=resp.json()['task_id']
res = requests.get(url=f"https://cloud-transpiler.quantum.ibm.com/transpile/{task_id}", headers=headers)

if res.json().get("state") == "SUCCESS":
    resulting_qasm=res.json().get("result")[0].get("qasm")

print(resulting_qasm)
```
Output
```text
OPENQASM 3.0; include "stdgates.inc"; gate rzx_140040114706704(_gate_p_0) _gate_q_0, _gate_q_1 {   h _gate_q_1;   cx _gate_q_0, _gate_q_1;   rz(pi/4) _gate_q_1;   cx _gate_q_0, _gate_q_1;   h _gate_q_1; } gate rzx_140040024191376(_gate_p_0) _gate_q_0, _gate_q_1 {   h _gate_q_1;   cx _gate_q_0, _gate_q_1;   rz(-pi/4) _gate_q_1;   cx _gate_q_0, _gate_q_1;   h _gate_q_1; } gate ecr _gate_q_0, _gate_q_1 {   rzx_140040114706704(pi/4) _gate_q_0, _gate_q_1;   x _gate_q_0;   rzx_140040024191376(-pi/4) _gate_q_0, _gate_q_1; } bit[2] c; rz(-pi) $0; sx $0; rz(pi/2) $0; rz(-pi/2) $1; sx $1; rz(-pi) $1; ecr $1, $0; rz(-pi/2) $0; sx $0; rz(pi/2) $0; rz(pi/2) $1; sx $1; rz(pi/2) $1; barrier $0, $1; c[0] = measure $0; c[1] = measure $1;
```

## Next steps

<Admonition type="tip" title="Recommendations">
    - Review detailed [Sampler](rest-api-sampler) and [Estimator](rest-api-estimator) primitives examples.
    - Read [Migrate to V2 primitives](/api/migration-guides/v2-primitives).
    - Practice with primitives by working through the [Cost function lesson](https://learning.quantum.ibm.com/course/variational-algorithm-design/cost-functions#primitives) in IBM Quantum Learning.
    - Learn how to transpile locally in the [Transpile](../transpile/) section.
</Admonition>