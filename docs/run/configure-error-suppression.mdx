---
title: Configure error suppression
description: How to use error suppression techniques

---

# Configure error suppression

Error suppression techniques optimize and transform your circuit at the point of compilation to minimize errors. This is the most basic error handling technique.

Error suppression typically results in some classical pre-processing overhead added to your overall runtime. Therefore, it is important to achieve a balance between perfecting your results and ensuring that your job completes in a reasonable amount of time.

Primitives let you employ error suppression techniques by setting the optimization level (`optimization_level` option) and by choosing advanced transpilation options.

## Setting the optimization level

The `optimization_level` setting specifies how much optimization to perform on the circuits. Higher levels generate more optimized circuits, at the expense of longer transpilation times.


<Table>
  <thead>
    <Tr>
      <Th>Optimization Level</Th>
      <Th>Estimator & Sampler</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>0</Td>
      <Td>
        No optimization: typically used for hardware characterization

        - Basic translation
        - Layout (as specified)
        - Routing (stochastic swaps)
      </Td>
    </Tr>
    <Tr>
      <Td>1</Td>
      <Td>
        Light optimization:

        -   Layout (trivial → vf2 → SabreLayout if routing is required)
        -   Routing (SabreSWAPs if needed)
        -   1Q gate optimization
        -   Error suppression: dynamical decoupling
      </Td>
    </Tr>
    <Tr>
      <Td>2</Td>
      <Td>
        Medium optimization:
          - Layout/Routing: Optimization level 1 (without trivial) + heuristic optimized with greater
        search depth and trials of optimization function
        -   Commutative cancelation
        -   Error suppression: dynamical decoupling
      </Td>
    </Tr>
    <Tr>
      <Td>3 (default)</Td>
      <Td>
        High Optimization:

        - Optimization level 2 + heuristic optimized on layout/routing further with greater effort/trials
        - Two qubit KAK optimization
        - Error suppression: dynamical decoupling
      </Td>
    </Tr>
  </tbody>
</Table>

### Example: configure Estimator with optimization levels

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Estimator, Options
from qiskit.circuit.library import RealAmplitudes
from qiskit.quantum_info import SparsePauliOp

service = QiskitRuntimeService()
backend = service.backend("ibmq_qasm_simulator")
options = Options(optimization_level=2)

psi = RealAmplitudes(num_qubits=2, reps=2)
H = SparsePauliOp.from_list([("II", 1), ("IZ", 2), ("XI", 3)])
theta = [0, 1, 1, 2, 3, 5]

estimator = Estimator (options=options, backend=backend)

job = estimator.run(circuits=[psi], observables=[H], parameter_values=[theta])
psi1_H1 = job.result()
```

<Admonition type="note">
  If the optimization level is not specified, the service uses `optimization_level = 3`.
</Admonition>

### Example: configure Sampler with optimization levels

```python
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options

service = QiskitRuntimeService()
backend = service.backend("ibmq_qasm_simulator")
options = Options(optimization_level=3)

sampler = Sampler(options=options, backend=backend)
```


<span id="transpilation-table"></span>
## Advanced transpilation options

You also have the ability to tune a variety of advanced options to configure your transpilation strategy further. These methods can be used alongside optimization levels. They allow you to change the options of interest and let your optimization level manage the rest.

Most of the transpilation options are inherited from [qiskit.compiler.transpile](/api/qiskit/compiler#compilation-routines).

| Options                                                         | Description                                                                                                                                                                                                                         |
| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| options.transpilation.initial\_layout(Union\[dict, List, None]) | Initial position of virtual qubits on physical qubits.                                                                                                                                                                              |
| options.transpilation.layout\_method (Optional\[str])           | Name of layout selection pass. One of `trivial`, `dense`, `noise_adaptive`, `sabre`.                                                                                                                                                |
| options.transpilation.routing\_method (Optional\[str])          | Name of routing pass: `basic`, `lookahead`, `stochastic`, `sabre`, `none`.                                                                                                                                                          |
| options.transpilation.skip\_transpilation (bool)                | This option is specific to Qiskit Runtime primitives. Allows for skipping transpilation entirely. If you use this method, make sure to verify that your circuit is written using the basis gates on the backend you are running on. |
| options.transpilation.approximation\_degree (Optional\[float])  | Heuristic dial used for circuit approximation (1.0=no approximation, 0.0=maximal approximation). Defaults to no approximation for all optimization levels                                                                           |
