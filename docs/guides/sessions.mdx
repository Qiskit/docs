---
title: Sessions
description: An overview of Qiskit Runtime sessions and when to use them.

---
# Introduction to Qiskit Runtime sessions

<Admonition type="note">
Session execution mode is not supported in the Open Plan. Jobs will run in job mode instead.
</Admonition>

## What is a session?

A session is a Qiskit Runtime feature that lets you efficiently run multi-job iterative workloads on quantum computers. Using sessions helps avoid delays caused by queuing each job separately, which can be particularly useful for iterative tasks that require frequent communication between classical and quantum resources.

<Admonition type="note">
The queuing time does not decrease for the first job submitted within a session. Therefore, a session does not provide any benefits when running a single job. Additionally, sessions do not work on simulators because simulators do not have a queue.
</Admonition>

## Advantages of using sessions

There are several benefits to using sessions:

- Efficiency: Multiple jobs from a single algorithm run can be run sequentially without interruptions.
- Flexibility: You can submit jobs, check results, and submit new jobs within an active session without needing to start a new one.

For instructions to start a session, see [Run a job in a session](/guides/run-jobs-session).

<span id="ends"></span>
## End a session

A session ends in the following circumstances:

* The maximum timeout (TTL) value is reached, resulting in the cancelation of all queued jobs.
* The session is manually canceled, resulting in the cancelation of all queued jobs.
* The session is manually closed.  The session stops accepting new jobs but continues to run queued jobs with priority.
* If you use Session as a context manager, that is,  `with Session()`, the session is automatically closed when the context ends (the same behavior as using `session.close()`).

<Admonition type = "note">
When a session ends, the QPU finishes running any job that is currently running.
</Admonition>

## Usage patterns

Sessions are especially useful for algorithms that require classical post-processing, where jobs submitted within the interactive time-out are processed immediately. If you want to submit jobs in a batch instead, see [Run jobs in a batch.](run-jobs-batch)

Example: Run an iterative workload that uses the classical SciPy optimizer to minimize a cost function. In this model, SciPy uses the output of the cost function to calculate its next input.

```python
def cost_func(params, ansatz, hamiltonian, estimator):
    # Return estimate of energy from estimator

    energy = estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0]
    return energy

x0 = 2 * np.pi * np.random.random(num_params)

session = Session(backend=backend)

# If using qiskit-ibm-runtime earlier than 0.24.0, change `mode=` to `session=`
estimator = Estimator(mode=session, options={"shots": int(1e4)})
res = minimize(cost_func, x0, args=(ansatz, hamiltonian, estimator), method="cobyla")

# Close the session because we didn't use a context manager.
session.close()
```

## Next steps

<Admonition type="tip" title="Recommendations">
  - Try an example in the [Quantum approximate optimization algorithm (QAOA)](https://learning.quantum.ibm.com/tutorial/quantum-approximate-optimization-algorithm) tutorial.
  - Review the [Session API](/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Session) reference.
  - Review the execution modes [best practices.](execution-modes#best-practices)
  - Learn how to [run a job in a session.](./run-jobs-session)
</Admonition>