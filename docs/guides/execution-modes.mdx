---
title: Introduction to execution modes
description: An overview of the available execution modes in Qiskit Runtime; sessions, batch, and single jobs.

---
# Introduction to Qiskit Runtime execution modes

When Qiskit Runtime was first introduced, users could only execute circuits as individual jobs. As different types of quantum workloads emerged, we recognized the need for different scheduling strategies. The execution modes determine how your jobs are scheduled, and choosing the right execution mode allows your workload to run efficiently within your budget. There are three execution modes: job mode, session mode, and batch mode.

## Job mode

A single primitive request of the estimator or the sampler made without a context manager. Circuits and inputs are packaged as primitive unified blocs (PUBs) and submitted as an execution task on the quantum computer. To run in job mode, specify `mode=backend` when instantiating a primitive. See [Primitives examples](/guides/primitives-examples) for examples.

## Batch mode

A multi-job manager for efficiently running experiments comprising multi-job workloads. These workloads are made up of independently executable jobs that have no conditional relationship with each other. With batch mode, users submit their jobs all at once. The system parallelizes or threads the pre-processing step of each primitive job to more tightly package quantum execution across jobs, and then runs the quantum execution of each job in quick succession to deliver the most efficient results.


![This diagram illustrates jobs submitted in a batch.  It shows five jobs, numbered 0 through 4, in a queue. The jobs are a mix of Estimator and Sampler.](/images/guides/batch.avif 'Figure 1: Batch execution')

<Admonition type="note" title="Notes">
    - When batching, jobs are not guaranteed to run in the order they are submitted. Also, while your batch jobs will run as closely together as possible, they don't get exclusive access to the backend. Therefore, your batch jobs might run in parallel with other users' jobs if there is enough processing capacity on the QPU. Additionally, QPU calibration jobs could run between the batched jobs.
    - The queuing time does not decrease for the first job submitted within a batch. Therefore, batches do not provide any benefits when running a single job.
    - Batches do not work on simulators because simulators do not have a queue.
</Admonition>

To run in batch mode, specify `mode=batch` when instantiating a primitive or run the job in a batch context manager. See [Run jobs in a batch](/guides/run-jobs-batch) for examples.

## Session mode

A dedicated window for running a multi-job workload.  During this window, the user has exclusive access of the system and no other jobs can run - including calibration jobs. This allows users to experiment with variational algorithms in a more predictable way and even run multiple experiments simultaneously, taking advantage of parallelism in the stack. Using sessions helps avoid delays caused by queuing each job separately, which can be particularly useful for iterative tasks that require frequent communication between classical and quantum resources.

 To run in session mode, specify `mode=session` when instantiating a primitive, or run the job in a session context manager. See [Run jobs in a session](/guides/run-jobs-session) for examples.

<Admonition type="note" title="Notes">
- The queuing time does not decrease for the first job submitted within a session. Therefore, sessions do not provide any benefits when running a single job.
- Sessions do not work on simulators because simulators do not have a queue.
- Session execution mode is not supported in the Open Plan. Jobs will run in job mode instead.
</Admonition>

## Basic workflow

The basic workflow for batches and sessions is similar:

1. The first job in a batch or session enters the normal queue. Note: for batches, the entire batch of jobs is scheduled together.
2. When the first job starts running, the maximum time to live (TTL) timer starts (and does not stop or pause until the end is reached).
3. The interactive TTL timer starts after each job is completed.  If there are no workload jobs ready within the interactive TTL window, the workload is temporarily deactivated and normal job selection resumes. A job can reactivate the deactivated workload if the batch or session has not reached its maximum TTL value.
   <Admonition type="note">
   The job must go through the normal queue to reactivate the workload.
   </Admonition>
3. If the maximum TTL value is reached, the workload ends and any remaining queued jobs fail. However, any jobs already running will run to completion.

The following video illustrates the session basic workflow, using sessions as an example:

<video title="A user starts a session job and becomes the priority user.  They submit jobs to the QPU while other users wait. After the prioritized user's session finishes, the next person's jobs can begin processing." className="max-w-auto h-auto" controls>
  <source src="/videos/guides/sessions/demo.mp4" type="video/mp4"></source>
</video>

For full details about the TTL timers, see the [Maximum execution time](/guides/max-execution-time) guide.

<span id="sessions-versus-batch-usage" />

## Choose the right execution mode

Utility-scale workloads can take many hours to complete, so it is important that both the classical and quantum resources are scheduled efficiently to streamline the execution. Execution modes provide flexibility in balancing the cost and time tradeoff to use resources optimally for your workloads. There are several aspects to consider when choosing which execution mode to use, such as _usage_, overall execution time (maximum TTL), and time between jobs (interactive TTL).

The the benefits of each are summarazed below:

- **Batch**
   - The entire batch of jobs is scheduled together and there is no additional queuing time for each.
   - The jobs' classical computation, such as compilation, is run in parallel. Thus, running multiple jobs in a batch is significantly faster than running them serially.
   - There is usually minimal delay between jobs, which can help avoid drift.
   - If you partition your workload into multiple jobs and run them in batch mode, you can get results from individual jobs, which makes them more flexible to work with. For example, if a job's results don't meet your expectations, you can cancel the remaining jobs. Also, if one job fails, you can re-submit it instead of re-running the entire workload.
- **Session**
   - All the benefits from batch mode.
   - Dedicated and exclusive access to the QPU during the session active window.
   - Useful for workloads that don’t have all inputs ready at the outset, for iterative workloads that require dedicated access, and for algorithms that require classical post-processing.
- **Job**
   - Easiest to use when running a small experiment.
   - Might run sooner than batch mode.

<span id="best-practices"></span>
### Recommendations and best practices

Generally, you can use batch mode unless you have workloads that don’t have all inputs ready at the outset.

- Use **batch** mode to submit multiple primitive jobs simultaneously to shorten processing time.
- Use **session** mode for iterative workloads, or if you need dedicated access to the QPU (quantum processing unit).
- Always use **job** mode to submit a single primitive request.
- Because sessions are generally more expensive, it is recommended that you use batch whenever you don't need the additional benefits from using sessions.

To ensure the most efficient use of the execution modes, the following practices are recommended:

- There is a fixed overhead associated with running a job. In general, if each of your jobs uses less than one minute of _QPU time_, consider combining several into one larger job (this applies to all execution modes). "QPU time" refers to time spent by the QPU complex to process your job.

- If each of your jobs consumes more than one minute of QPU time, or if combining jobs is not practical, you can still run multiple jobs in parallel. Every job goes through both classical and quantum processing. While a QPU can process only one job at a time, up to five classical jobs can be processed in parallel. You can take advantage of this by submitting multiple jobs in [batch](/guides/run-jobs-batch#partition) or [session](/guides/run-jobs-session#two-vqe) execution mode.

The above are general guidelines, and you should tune your workload to find the optimal ratio, especially when using sessions. For example, if you are using a session to get exclusive access to a backend, consider breaking up large jobs into smaller ones and running them in parallel. This might be more cost-effective because it can reduce wall clock time.

### Examples

#### Run a quantum variational algorithm

Running a quantum variational algorithm typically follows this flow:

1. Prepare the ansatz.
2. Evaluate the cost function on a QPU.
3. Take the result from the previous step and run it through a classical optimizer.
4. Adjust the parameters according to the output of (3), then go back to step (2).

In this case, if you were using job or batch mode, each job generated by step (2) needs to go back through the queue. This drastically increases the experiment length (wall clock time) due to the queuing time. It could also take longer to converge due to device drift.  That is, every iteration is supposed give you a better result, but device drift could make subsequent results worse.

In addition, if you use [PEA](/guides/error-mitigation-and-suppression-techniques#pea) or [PEC](/guides/error-mitigation-and-suppression-techniques#pec), you can [learn the noise model](/guides/noise-learning) once and apply it to subsequent jobs when running in dedicated session. This usually doesn't work with batch or job mode because the noise model could become stale by the time the next iteration runs.

#### Compare error mitigation settings

To compare the effects of the available error mitigation methods, you might follow this flow:

1. Construct a circuit and observable.
2. Submit primitive jobs that use different combinations of error mitigation settings.
3. Plot the results to observe the effects of the various settings.

In this case, all jobs (which are related but independant) are available at the outset. If you use batch mode, they are scheduled collectively so you only have to wait for them to go through the queue once.  Additionally, because the goal is to compare the effects of various error mitigation methods, it's beneficial that they run as closely together as possible. Thus, batch would be a good choice.  You _could_ run these jobs in a session, but because sessions are generally more expensive, it is recommended that you use batch whenever you don't need the additional benefits from using sessions.

## Next steps

<Admonition type="tip" title="Recommendations">
    - [Run a job in batch mode.](/guides/run-jobs-batch/)
    - [Run a job in session mode.](/guides/run-jobs-session)
</Admonition>